"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = filterItems;
exports.isRequired = isRequired;
exports.targetsSupported = targetsSupported;

var _semver = require("semver");

var _plugins = require("@babel/compat-data/plugins");

var _utils = require("./utils");

function targetsSupported(target, support) {
  var targetEnvironments = Object.keys(target);

  if (targetEnvironments.length === 0) {
    return false;
  }

  var unsupportedEnvironments = targetEnvironments.filter(function (environment) {
    var lowestImplementedVersion = (0, _utils.getLowestImplementedVersion)(support, environment);

    if (!lowestImplementedVersion) {
      return true;
    }

    var lowestTargetedVersion = target[environment];

    if ((0, _utils.isUnreleasedVersion)(lowestTargetedVersion, environment)) {
      return false;
    }

    if ((0, _utils.isUnreleasedVersion)(lowestImplementedVersion, environment)) {
      return true;
    }

    if (!_semver.valid(lowestTargetedVersion.toString())) {
      throw new Error("Invalid version passed for target \"".concat(environment, "\": \"").concat(lowestTargetedVersion, "\". ") + "Versions must be in semver format (major.minor.patch)");
    }

    return _semver.gt((0, _utils.semverify)(lowestImplementedVersion), lowestTargetedVersion.toString());
  });
  return unsupportedEnvironments.length === 0;
}

function isRequired(name, targets) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$compatData = _ref.compatData,
      compatData = _ref$compatData === void 0 ? _plugins : _ref$compatData,
      includes = _ref.includes,
      excludes = _ref.excludes;

  if (excludes != null && excludes.has(name)) return false;
  if (includes != null && includes.has(name)) return true;
  return !targetsSupported(targets, compatData[name]);
}

function filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
  var result = new Set();
  var options = {
    compatData: list,
    includes: includes,
    excludes: excludes
  };

  for (var item in list) {
    if (isRequired(item, targets, options)) {
      result.add(item);
    } else if (pluginSyntaxMap) {
      var shippedProposalsSyntax = pluginSyntaxMap.get(item);

      if (shippedProposalsSyntax) {
        result.add(shippedProposalsSyntax);
      }
    }
  }

  if (defaultIncludes) {
    defaultIncludes.forEach(function (item) {
      return !excludes.has(item) && result.add(item);
    });
  }

  if (defaultExcludes) {
    defaultExcludes.forEach(function (item) {
      return !includes.has(item) && result["delete"](item);
    });
  }

  return result;
}