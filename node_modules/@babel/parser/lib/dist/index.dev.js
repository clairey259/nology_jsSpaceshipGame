'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject5() {
  var data = _taggedTemplateLiteral(["placeholders"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["typescript"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["jsx"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["flow"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["pipelineOperator"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var Position = function Position(line, col, index) {
  _classCallCheck(this, Position);

  this.line = void 0;
  this.column = void 0;
  this.index = void 0;
  this.line = line;
  this.column = col;
  this.index = index;
};

var SourceLocation = function SourceLocation(start, end) {
  _classCallCheck(this, SourceLocation);

  this.start = void 0;
  this.end = void 0;
  this.filename = void 0;
  this.identifierName = void 0;
  this.start = start;
  this.end = end;
};

function createPositionWithColumnOffset(position, columnOffset) {
  var line = position.line,
      column = position.column,
      index = position.index;
  return new Position(line, column + columnOffset, index + columnOffset);
}

var ParseErrorCode = {
  SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
  SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
};

var reflect = function reflect(keys) {
  var last = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : keys.length - 1;
  return {
    get: function get() {
      return keys.reduce(function (object, key) {
        return object[key];
      }, this);
    },
    set: function set(value) {
      keys.reduce(function (item, key, i) {
        return i === last ? item[key] = value : item[key];
      }, this);
    }
  };
};

var instantiate = function instantiate(constructor, properties, descriptors) {
  return Object.keys(descriptors).map(function (key) {
    return [key, descriptors[key]];
  }).filter(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        descriptor = _ref4[1];

    return !!descriptor;
  }).map(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        key = _ref6[0],
        descriptor = _ref6[1];

    return [key, typeof descriptor === "function" ? {
      value: descriptor,
      enumerable: false
    } : typeof descriptor.reflect === "string" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor];
  }).reduce(function (instance, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
        key = _ref8[0],
        descriptor = _ref8[1];

    return Object.defineProperty(instance, key, Object.assign({
      configurable: true
    }, descriptor));
  }, Object.assign(new constructor(), properties));
};

var ModuleErrors = {
  ImportMetaOutsideModule: {
    message: "import.meta may appear only with 'sourceType: \"module\"'",
    code: ParseErrorCode.SourceTypeModuleError
  },
  ImportOutsideModule: {
    message: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
    code: ParseErrorCode.SourceTypeModuleError
  }
};
var NodeDescriptions = {
  ArrayPattern: "array destructuring pattern",
  AssignmentExpression: "assignment expression",
  AssignmentPattern: "assignment expression",
  ArrowFunctionExpression: "arrow function expression",
  ConditionalExpression: "conditional expression",
  CatchClause: "catch clause",
  ForOfStatement: "for-of statement",
  ForInStatement: "for-in statement",
  ForStatement: "for-loop",
  FormalParameters: "function parameter list",
  Identifier: "identifier",
  ImportSpecifier: "import specifier",
  ImportDefaultSpecifier: "import default specifier",
  ImportNamespaceSpecifier: "import namespace specifier",
  ObjectPattern: "object destructuring pattern",
  ParenthesizedExpression: "parenthesized expression",
  RestElement: "rest element",
  UpdateExpression: {
    "true": "prefix operation",
    "false": "postfix operation"
  },
  VariableDeclarator: "variable declaration",
  YieldExpression: "yield expression"
};

var toNodeDescription = function toNodeDescription(_ref9) {
  var type = _ref9.type,
      prefix = _ref9.prefix;
  return type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];
};

var StandardErrors = {
  AccessorIsGenerator: function AccessorIsGenerator(_ref10) {
    var kind = _ref10.kind;
    return "A ".concat(kind, "ter cannot be a generator.");
  },
  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
  BadGetterArity: "A 'get' accesor must not have any formal parameters.",
  BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
  BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
  ConstructorClassField: "Classes may not have a field named 'constructor'.",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
  ConstructorIsAccessor: "Class constructor may not be an accessor.",
  ConstructorIsAsync: "Constructor can't be an async function.",
  ConstructorIsGenerator: "Constructor can't be a generator.",
  DeclarationMissingInitializer: function DeclarationMissingInitializer(_ref11) {
    var kind = _ref11.kind;
    return "Missing initializer in ".concat(kind, " declaration.");
  },
  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
  DecoratorStaticBlock: "Decorators can't be used with a static block.",
  DeletePrivateField: "Deleting a private field is not allowed.",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class.",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: function DuplicateExport(_ref12) {
    var exportName = _ref12.exportName;
    return "`".concat(exportName, "` has already been exported. Exported identifiers must be unique.");
  },
  DuplicateProto: "Redefinition of __proto__ property.",
  DuplicateRegExpFlags: "Duplicate regular expression flag.",
  ElementAfterRest: "Rest element must be last element.",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
  ExportBindingIsString: function ExportBindingIsString(_ref13) {
    var localName = _ref13.localName,
        exportName = _ref13.exportName;
    return "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '".concat(localName, "' as '").concat(exportName, "' } from 'some-module'`?");
  },
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
  ForInOfLoopInitializer: function ForInOfLoopInitializer(_ref14) {
    var type = _ref14.type;
    return "'".concat(type === "ForInStatement" ? "for-in" : "for-of", "' loop variable declaration may not have an initializer.");
  },
  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
  IllegalBreakContinue: function IllegalBreakContinue(_ref15) {
    var type = _ref15.type;
    return "Unsyntactic ".concat(type === "BreakStatement" ? "break" : "continue", ".");
  },
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
  IllegalReturn: "'return' outside of function.",
  ImportBindingIsString: function ImportBindingIsString(_ref16) {
    var importName = _ref16.importName;
    return "A string literal cannot be used as an imported binding.\n- Did you mean `import { \"".concat(importName, "\" as foo }`?");
  },
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
  ImportCallArity: function ImportCallArity(_ref17) {
    var maxArgumentCount = _ref17.maxArgumentCount;
    return "`import()` requires exactly ".concat(maxArgumentCount === 1 ? "one argument" : "one or two arguments", ".");
  },
  ImportCallNotNewExpression: "Cannot use new with import(...).",
  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
  InvalidCodePoint: "Code point out of bounds.",
  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
  InvalidDecimal: "Invalid decimal.",
  InvalidDigit: function InvalidDigit(_ref18) {
    var radix = _ref18.radix;
    return "Expected number in radix ".concat(radix, ".");
  },
  InvalidEscapeSequence: "Bad character escape sequence.",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
  InvalidEscapedReservedWord: function InvalidEscapedReservedWord(_ref19) {
    var reservedWord = _ref19.reservedWord;
    return "Escape sequence in keyword ".concat(reservedWord, ".");
  },
  InvalidIdentifier: function InvalidIdentifier(_ref20) {
    var identifierName = _ref20.identifierName;
    return "Invalid identifier ".concat(identifierName, ".");
  },
  InvalidLhs: function InvalidLhs(_ref21) {
    var ancestor = _ref21.ancestor;
    return "Invalid left-hand side in ".concat(toNodeDescription(ancestor), ".");
  },
  InvalidLhsBinding: function InvalidLhsBinding(_ref22) {
    var ancestor = _ref22.ancestor;
    return "Binding invalid left-hand side in ".concat(toNodeDescription(ancestor), ".");
  },
  InvalidNumber: "Invalid number.",
  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
  InvalidOrUnexpectedToken: function InvalidOrUnexpectedToken(_ref23) {
    var unexpected = _ref23.unexpected;
    return "Unexpected character '".concat(unexpected, "'.");
  },
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
  InvalidPrivateFieldResolution: function InvalidPrivateFieldResolution(_ref24) {
    var identifierName = _ref24.identifierName;
    return "Private name #".concat(identifierName, " is not defined.");
  },
  InvalidPropertyBindingPattern: "Binding member expression.",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
  LabelRedeclaration: function LabelRedeclaration(_ref25) {
    var labelName = _ref25.labelName;
    return "Label '".concat(labelName, "' is already declared.");
  },
  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
  MalformedRegExpFlags: "Invalid regular expression flag.",
  MissingClassName: "A class name is required.",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingSemicolon: "Missing semicolon.",
  MissingPlugin: function MissingPlugin(_ref26) {
    var missingPlugin = _ref26.missingPlugin;
    return "This experimental syntax requires enabling the parser plugin: ".concat(missingPlugin.map(function (name) {
      return JSON.stringify(name);
    }).join(", "), ".");
  },
  MissingOneOfPlugins: function MissingOneOfPlugins(_ref27) {
    var missingPlugin = _ref27.missingPlugin;
    return "This experimental syntax requires enabling one of the following parser plugin(s): ".concat(missingPlugin.map(function (name) {
      return JSON.stringify(name);
    }).join(", "), ".");
  },
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
  ModuleAttributesWithDuplicateKeys: function ModuleAttributesWithDuplicateKeys(_ref28) {
    var key = _ref28.key;
    return "Duplicate key \"".concat(key, "\" is not allowed in module attributes.");
  },
  ModuleExportNameHasLoneSurrogate: function ModuleExportNameHasLoneSurrogate(_ref29) {
    var surrogateCharCode = _ref29.surrogateCharCode;
    return "An export name cannot include a lone surrogate, found '\\u".concat(surrogateCharCode.toString(16), "'.");
  },
  ModuleExportUndefined: function ModuleExportUndefined(_ref30) {
    var localName = _ref30.localName;
    return "Export '".concat(localName, "' is not defined.");
  },
  MultipleDefaultsInSwitch: "Multiple default clauses.",
  NewlineAfterThrow: "Illegal newline after throw.",
  NoCatchOrFinally: "Missing catch or finally clause.",
  NumberIdentifier: "Identifier directly after number.",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
  ParamDupe: "Argument name clash.",
  PatternHasAccessor: "Object pattern can't contain getter or setter.",
  PatternHasMethod: "Object pattern can't contain methods.",
  PrivateInExpectedIn: function PrivateInExpectedIn(_ref31) {
    var identifierName = _ref31.identifierName;
    return "Private names are only allowed in property accesses (`obj.#".concat(identifierName, "`) or in `in` expressions (`#").concat(identifierName, " in obj`).");
  },
  PrivateNameRedeclaration: function PrivateNameRedeclaration(_ref32) {
    var identifierName = _ref32.identifierName;
    return "Duplicate private name #".concat(identifierName, ".");
  },
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
  RestTrailingComma: "Unexpected trailing comma after rest element.",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
  StaticPrototype: "Classes may not have static property named prototype.",
  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super.",
  TrailingDecorator: "Decorators must be attached to a class element.",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
  UnexpectedKeyword: function UnexpectedKeyword(_ref33) {
    var keyword = _ref33.keyword;
    return "Unexpected keyword '".concat(keyword, "'.");
  },
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
  UnexpectedPrivateField: "Unexpected private name.",
  UnexpectedReservedWord: function UnexpectedReservedWord(_ref34) {
    var reservedWord = _ref34.reservedWord;
    return "Unexpected reserved word '".concat(reservedWord, "'.");
  },
  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
  UnexpectedToken: function UnexpectedToken(_ref35) {
    var expected = _ref35.expected,
        unexpected = _ref35.unexpected;
    return "Unexpected token".concat(unexpected ? " '".concat(unexpected, "'.") : "").concat(expected ? ", expected \"".concat(expected, "\"") : "");
  },
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
  UnsupportedMetaProperty: function UnsupportedMetaProperty(_ref36) {
    var target = _ref36.target,
        onlyValidPropertyName = _ref36.onlyValidPropertyName;
    return "The only valid meta property for ".concat(target, " is ").concat(target, ".").concat(onlyValidPropertyName, ".");
  },
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
  UnterminatedComment: "Unterminated comment.",
  UnterminatedRegExp: "Unterminated regular expression.",
  UnterminatedString: "Unterminated string constant.",
  UnterminatedTemplate: "Unterminated template.",
  VarRedeclaration: function VarRedeclaration(_ref37) {
    var identifierName = _ref37.identifierName;
    return "Identifier '".concat(identifierName, "' has already been declared.");
  },
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
  YieldInParameter: "Yield expression is not allowed in formal parameters.",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
};
var StrictModeErrors = {
  StrictDelete: "Deleting local variable in strict mode.",
  StrictEvalArguments: function StrictEvalArguments(_ref38) {
    var referenceName = _ref38.referenceName;
    return "Assigning to '".concat(referenceName, "' in strict mode.");
  },
  StrictEvalArgumentsBinding: function StrictEvalArgumentsBinding(_ref39) {
    var bindingName = _ref39.bindingName;
    return "Binding '".concat(bindingName, "' in strict mode.");
  },
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
  StrictWith: "'with' in strict mode."
};
var UnparenthesizedPipeBodyDescriptions = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
var PipelineOperatorErrors = {
  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
  PipeTopicUnconfiguredToken: function PipeTopicUnconfiguredToken(_ref40) {
    var token = _ref40.token;
    return "Invalid topic token ".concat(token, ". In order to use ").concat(token, " as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"").concat(token, "\" }.");
  },
  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
  PipeUnparenthesizedBody: function PipeUnparenthesizedBody(_ref41) {
    var type = _ref41.type;
    return "Hack-style pipe body cannot be an unparenthesized ".concat(toNodeDescription({
      type: type
    }), "; please wrap it in parentheses.");
  },
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
};
var _excluded$1 = ["toMessage"],
    _excluded2$1 = ["message"];

function toParseErrorConstructor(_ref) {
  var toMessage = _ref.toMessage,
      properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);

  return function constructor(_ref42) {
    var loc = _ref42.loc,
        details = _ref42.details;
    return instantiate(SyntaxError, Object.assign({}, properties, {
      loc: loc
    }), {
      clone: function clone() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var loc = overrides.loc || {};
        return constructor({
          loc: new Position("line" in loc ? loc.line : this.loc.line, "column" in loc ? loc.column : this.loc.column, "index" in loc ? loc.index : this.loc.index),
          details: Object.assign({}, this.details, overrides.details)
        });
      },
      details: {
        value: details,
        enumerable: false
      },
      message: {
        get: function get() {
          return "".concat(toMessage(this.details), " (").concat(this.loc.line, ":").concat(this.loc.column, ")");
        },
        set: function set(value) {
          Object.defineProperty(this, "message", {
            value: value
          });
        }
      },
      pos: {
        reflect: "loc.index",
        enumerable: true
      },
      missingPlugin: "missingPlugin" in details && {
        reflect: "details.missingPlugin",
        enumerable: true
      }
    });
  };
}

function ParseErrorEnum(argument, syntaxPlugin) {
  if (Array.isArray(argument)) {
    return function (parseErrorTemplates) {
      return ParseErrorEnum(parseErrorTemplates, argument[0]);
    };
  }

  var ParseErrorConstructors = {};

  var _loop = function _loop() {
    var reasonCode = _Object$keys[_i2];
    var template = argument[reasonCode];

    var _ref2 = typeof template === "string" ? {
      message: function message() {
        return template;
      }
    } : typeof template === "function" ? {
      message: template
    } : template,
        message = _ref2.message,
        rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);

    var toMessage = typeof message === "string" ? function () {
      return message;
    } : message;
    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
      code: ParseErrorCode.SyntaxError,
      reasonCode: reasonCode,
      toMessage: toMessage
    }, syntaxPlugin ? {
      syntaxPlugin: syntaxPlugin
    } : {}, rest));
  };

  for (var _i2 = 0, _Object$keys = Object.keys(argument); _i2 < _Object$keys.length; _i2++) {
    _loop();
  }

  return ParseErrorConstructors;
}

var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(_templateObject())(PipelineOperatorErrors));
var defineProperty = Object.defineProperty;

var toUnenumerable = function toUnenumerable(object, key) {
  return defineProperty(object, key, {
    enumerable: false,
    value: object[key]
  });
};

function toESTreeLocation(node) {
  node.loc.start && toUnenumerable(node.loc.start, "index");
  node.loc.end && toUnenumerable(node.loc.end, "index");
  return node;
}

var estree = function estree(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass) {
      _inherits(ESTreeParserMixin, _superClass);

      function ESTreeParserMixin() {
        _classCallCheck(this, ESTreeParserMixin);

        return _possibleConstructorReturn(this, _getPrototypeOf(ESTreeParserMixin).apply(this, arguments));
      }

      _createClass(ESTreeParserMixin, [{
        key: "parse",
        value: function parse() {
          var file = toESTreeLocation(_get(_getPrototypeOf(ESTreeParserMixin.prototype), "parse", this).call(this));

          if (this.options.tokens) {
            file.tokens = file.tokens.map(toESTreeLocation);
          }

          return file;
        }
      }, {
        key: "parseRegExpLiteral",
        value: function parseRegExpLiteral(_ref43) {
          var pattern = _ref43.pattern,
              flags = _ref43.flags;
          var regex = null;

          try {
            regex = new RegExp(pattern, flags);
          } catch (e) {}

          var node = this.estreeParseLiteral(regex);
          node.regex = {
            pattern: pattern,
            flags: flags
          };
          return node;
        }
      }, {
        key: "parseBigIntLiteral",
        value: function parseBigIntLiteral(value) {
          var bigInt;

          try {
            bigInt = BigInt(value);
          } catch (_unused) {
            bigInt = null;
          }

          var node = this.estreeParseLiteral(bigInt);
          node.bigint = String(node.value || value);
          return node;
        }
      }, {
        key: "parseDecimalLiteral",
        value: function parseDecimalLiteral(value) {
          var decimal = null;
          var node = this.estreeParseLiteral(decimal);
          node.decimal = String(node.value || value);
          return node;
        }
      }, {
        key: "estreeParseLiteral",
        value: function estreeParseLiteral(value) {
          return this.parseLiteral(value, "Literal");
        }
      }, {
        key: "parseStringLiteral",
        value: function parseStringLiteral(value) {
          return this.estreeParseLiteral(value);
        }
      }, {
        key: "parseNumericLiteral",
        value: function parseNumericLiteral(value) {
          return this.estreeParseLiteral(value);
        }
      }, {
        key: "parseNullLiteral",
        value: function parseNullLiteral() {
          return this.estreeParseLiteral(null);
        }
      }, {
        key: "parseBooleanLiteral",
        value: function parseBooleanLiteral(value) {
          return this.estreeParseLiteral(value);
        }
      }, {
        key: "directiveToStmt",
        value: function directiveToStmt(directive) {
          var expression = directive.value;
          delete directive.value;
          expression.type = "Literal";
          expression.raw = expression.extra.raw;
          expression.value = expression.extra.expressionValue;
          var stmt = directive;
          stmt.type = "ExpressionStatement";
          stmt.expression = expression;
          stmt.directive = expression.extra.rawValue;
          delete expression.extra;
          return stmt;
        }
      }, {
        key: "initFunction",
        value: function initFunction(node, isAsync) {
          _get(_getPrototypeOf(ESTreeParserMixin.prototype), "initFunction", this).call(this, node, isAsync);

          node.expression = false;
        }
      }, {
        key: "checkDeclaration",
        value: function checkDeclaration(node) {
          if (node != null && this.isObjectProperty(node)) {
            this.checkDeclaration(node.value);
          } else {
            _get(_getPrototypeOf(ESTreeParserMixin.prototype), "checkDeclaration", this).call(this, node);
          }
        }
      }, {
        key: "getObjectOrClassMethodParams",
        value: function getObjectOrClassMethodParams(method) {
          return method.value.params;
        }
      }, {
        key: "isValidDirective",
        value: function isValidDirective(stmt) {
          var _stmt$expression$extr;

          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
        }
      }, {
        key: "parseBlockBody",
        value: function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          var _this2 = this;

          _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parseBlockBody", this).call(this, node, allowDirectives, topLevel, end, afterBlockParse);

          var directiveStatements = node.directives.map(function (d) {
            return _this2.directiveToStmt(d);
          });
          node.body = directiveStatements.concat(node.body);
          delete node.directives;
        }
      }, {
        key: "pushClassMethod",
        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

          if (method.typeParameters) {
            method.value.typeParameters = method.typeParameters;
            delete method.typeParameters;
          }

          classBody.body.push(method);
        }
      }, {
        key: "parsePrivateName",
        value: function parsePrivateName() {
          var node = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parsePrivateName", this).call(this);

          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return node;
            }
          }
          return this.convertPrivateNameToPrivateIdentifier(node);
        }
      }, {
        key: "convertPrivateNameToPrivateIdentifier",
        value: function convertPrivateNameToPrivateIdentifier(node) {
          var name = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "getPrivateNameSV", this).call(this, node);

          node = node;
          delete node.id;
          node.name = name;
          node.type = "PrivateIdentifier";
          return node;
        }
      }, {
        key: "isPrivateName",
        value: function isPrivateName(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return _get(_getPrototypeOf(ESTreeParserMixin.prototype), "isPrivateName", this).call(this, node);
            }
          }
          return node.type === "PrivateIdentifier";
        }
      }, {
        key: "getPrivateNameSV",
        value: function getPrivateNameSV(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return _get(_getPrototypeOf(ESTreeParserMixin.prototype), "getPrivateNameSV", this).call(this, node);
            }
          }
          return node.name;
        }
      }, {
        key: "parseLiteral",
        value: function parseLiteral(value, type) {
          var node = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parseLiteral", this).call(this, value, type);

          node.raw = node.extra.raw;
          delete node.extra;
          return node;
        }
      }, {
        key: "parseFunctionBody",
        value: function parseFunctionBody(node, allowExpression) {
          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parseFunctionBody", this).call(this, node, allowExpression, isMethod);

          node.expression = node.body.type !== "BlockStatement";
        }
      }, {
        key: "parseMethod",
        value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
          var inClassScope = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
          var funcNode = this.startNode();
          funcNode.kind = node.kind;
          funcNode = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parseMethod", this).call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          funcNode.type = "FunctionExpression";
          delete funcNode.kind;
          node.value = funcNode;

          if (type === "ClassPrivateMethod") {
            node.computed = false;
          }

          return this.finishNode(node, "MethodDefinition");
        }
      }, {
        key: "parseClassProperty",
        value: function parseClassProperty() {
          var _get2;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var propertyNode = (_get2 = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parseClassProperty", this)).call.apply(_get2, [this].concat(args));

          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          return propertyNode;
        }
      }, {
        key: "parseClassPrivateProperty",
        value: function parseClassPrivateProperty() {
          var _get3;

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          var propertyNode = (_get3 = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parseClassPrivateProperty", this)).call.apply(_get3, [this].concat(args));

          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          propertyNode.computed = false;
          return propertyNode;
        }
      }, {
        key: "parseObjectMethod",
        value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          var node = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parseObjectMethod", this).call(this, prop, isGenerator, isAsync, isPattern, isAccessor);

          if (node) {
            node.type = "Property";

            if (node.kind === "method") {
              node.kind = "init";
            }

            node.shorthand = false;
          }

          return node;
        }
      }, {
        key: "parseObjectProperty",
        value: function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          var node = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parseObjectProperty", this).call(this, prop, startPos, startLoc, isPattern, refExpressionErrors);

          if (node) {
            node.kind = "init";
            node.type = "Property";
          }

          return node;
        }
      }, {
        key: "isValidLVal",
        value: function isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return type === "Property" ? "value" : _get(_getPrototypeOf(ESTreeParserMixin.prototype), "isValidLVal", this).call(this, type, isUnparenthesizedInAssign, binding);
        }
      }, {
        key: "isAssignable",
        value: function isAssignable(node, isBinding) {
          if (node != null && this.isObjectProperty(node)) {
            return this.isAssignable(node.value, isBinding);
          }

          return _get(_getPrototypeOf(ESTreeParserMixin.prototype), "isAssignable", this).call(this, node, isBinding);
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node) {
          var isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (node != null && this.isObjectProperty(node)) {
            var key = node.key,
                value = node.value;

            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }

            this.toAssignable(value, isLHS);
          } else {
            _get(_getPrototypeOf(ESTreeParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
          }
        }
      }, {
        key: "toAssignableObjectExpressionProp",
        value: function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(Errors.PatternHasAccessor, {
              at: prop.key
            });
          } else if (prop.method) {
            this.raise(Errors.PatternHasMethod, {
              at: prop.key
            });
          } else {
            _get(_getPrototypeOf(ESTreeParserMixin.prototype), "toAssignableObjectExpressionProp", this).call(this, prop, isLast, isLHS);
          }
        }
      }, {
        key: "finishCallExpression",
        value: function finishCallExpression(unfinished, optional) {
          var node = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "finishCallExpression", this).call(this, unfinished, optional);

          if (node.callee.type === "Import") {
            node.type = "ImportExpression";
            node.source = node.arguments[0];

            if (this.hasPlugin("importAssertions")) {
              var _node$arguments$;

              node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
            }

            delete node.arguments;
            delete node.callee;
          }

          return node;
        }
      }, {
        key: "toReferencedArguments",
        value: function toReferencedArguments(node) {
          if (node.type === "ImportExpression") {
            return;
          }

          _get(_getPrototypeOf(ESTreeParserMixin.prototype), "toReferencedArguments", this).call(this, node);
        }
      }, {
        key: "parseExport",
        value: function parseExport(unfinished) {
          var node = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parseExport", this).call(this, unfinished);

          switch (node.type) {
            case "ExportAllDeclaration":
              node.exported = null;
              break;

            case "ExportNamedDeclaration":
              if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                node.type = "ExportAllDeclaration";
                node.exported = node.specifiers[0].exported;
                delete node.specifiers;
              }

              break;
          }

          return node;
        }
      }, {
        key: "parseSubscript",
        value: function parseSubscript(base, startPos, startLoc, noCalls, state) {
          var node = _get(_getPrototypeOf(ESTreeParserMixin.prototype), "parseSubscript", this).call(this, base, startPos, startLoc, noCalls, state);

          if (state.optionalChainMember) {
            if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
              node.type = node.type.substring(8);
            }

            if (state.stop) {
              var chain = this.startNodeAtNode(node);
              chain.expression = node;
              return this.finishNode(chain, "ChainExpression");
            }
          } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
            node.optional = false;
          }

          return node;
        }
      }, {
        key: "hasPropertyAsPrivateName",
        value: function hasPropertyAsPrivateName(node) {
          if (node.type === "ChainExpression") {
            node = node.expression;
          }

          return _get(_getPrototypeOf(ESTreeParserMixin.prototype), "hasPropertyAsPrivateName", this).call(this, node);
        }
      }, {
        key: "isOptionalChain",
        value: function isOptionalChain(node) {
          return node.type === "ChainExpression";
        }
      }, {
        key: "isObjectProperty",
        value: function isObjectProperty(node) {
          return node.type === "Property" && node.kind === "init" && !node.method;
        }
      }, {
        key: "isObjectMethod",
        value: function isObjectMethod(node) {
          return node.method || node.kind === "get" || node.kind === "set";
        }
      }, {
        key: "finishNodeAt",
        value: function finishNodeAt(node, type, endLoc) {
          return toESTreeLocation(_get(_getPrototypeOf(ESTreeParserMixin.prototype), "finishNodeAt", this).call(this, node, type, endLoc));
        }
      }, {
        key: "resetStartLocation",
        value: function resetStartLocation(node, start, startLoc) {
          _get(_getPrototypeOf(ESTreeParserMixin.prototype), "resetStartLocation", this).call(this, node, start, startLoc);

          toESTreeLocation(node);
        }
      }, {
        key: "resetEndLocation",
        value: function resetEndLocation(node) {
          var endLoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastTokEndLoc;

          _get(_getPrototypeOf(ESTreeParserMixin.prototype), "resetEndLocation", this).call(this, node, endLoc);

          toESTreeLocation(node);
        }
      }]);

      return ESTreeParserMixin;
    }(superClass)
  );
};

var TokContext = function TokContext(token, preserveSpace) {
  _classCallCheck(this, TokContext);

  this.token = void 0;
  this.preserveSpace = void 0;
  this.token = token;
  this.preserveSpace = !!preserveSpace;
};

var types = {
  brace: new TokContext("{"),
  j_oTag: new TokContext("<tag"),
  j_cTag: new TokContext("</tag"),
  j_expr: new TokContext("<tag>...</tag>", true)
};
{
  types.template = new TokContext("`", true);
}
var beforeExpr = true;
var startsExpr = true;
var isLoop = true;
var isAssign = true;
var prefix = true;
var postfix = true;

var ExportedTokenType = function ExportedTokenType(label) {
  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  _classCallCheck(this, ExportedTokenType);

  this.label = void 0;
  this.keyword = void 0;
  this.beforeExpr = void 0;
  this.startsExpr = void 0;
  this.rightAssociative = void 0;
  this.isLoop = void 0;
  this.isAssign = void 0;
  this.prefix = void 0;
  this.postfix = void 0;
  this.binop = void 0;
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.rightAssociative = !!conf.rightAssociative;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop != null ? conf.binop : null;
  {
    this.updateContext = null;
  }
};

var keywords$1 = new Map();

function createKeyword(name) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options.keyword = name;
  var token = createToken(name, options);
  keywords$1.set(name, token);
  return token;
}

function createBinop(name, binop) {
  return createToken(name, {
    beforeExpr: beforeExpr,
    binop: binop
  });
}

var tokenTypeCounter = -1;
var tokenTypes = [];
var tokenLabels = [];
var tokenBinops = [];
var tokenBeforeExprs = [];
var tokenStartsExprs = [];
var tokenPrefixes = [];

function createToken(name) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;

  ++tokenTypeCounter;
  tokenLabels.push(name);
  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
  tokenTypes.push(new ExportedTokenType(name, options));
  return tokenTypeCounter;
}

function createKeywordLike(name) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;

  ++tokenTypeCounter;
  keywords$1.set(name, tokenTypeCounter);
  tokenLabels.push(name);
  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
  tokenTypes.push(new ExportedTokenType("name", options));
  return tokenTypeCounter;
}

var tt = {
  bracketL: createToken("[", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  bracketHashL: createToken("#[", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  bracketBarL: createToken("[|", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  bracketR: createToken("]"),
  bracketBarR: createToken("|]"),
  braceL: createToken("{", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  braceBarL: createToken("{|", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  braceHashL: createToken("#{", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  braceR: createToken("}"),
  braceBarR: createToken("|}"),
  parenL: createToken("(", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  parenR: createToken(")"),
  comma: createToken(",", {
    beforeExpr: beforeExpr
  }),
  semi: createToken(";", {
    beforeExpr: beforeExpr
  }),
  colon: createToken(":", {
    beforeExpr: beforeExpr
  }),
  doubleColon: createToken("::", {
    beforeExpr: beforeExpr
  }),
  dot: createToken("."),
  question: createToken("?", {
    beforeExpr: beforeExpr
  }),
  questionDot: createToken("?."),
  arrow: createToken("=>", {
    beforeExpr: beforeExpr
  }),
  template: createToken("template"),
  ellipsis: createToken("...", {
    beforeExpr: beforeExpr
  }),
  backQuote: createToken("`", {
    startsExpr: startsExpr
  }),
  dollarBraceL: createToken("${", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  templateTail: createToken("...`", {
    startsExpr: startsExpr
  }),
  templateNonTail: createToken("...${", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  at: createToken("@"),
  hash: createToken("#", {
    startsExpr: startsExpr
  }),
  interpreterDirective: createToken("#!..."),
  eq: createToken("=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  assign: createToken("_=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  slashAssign: createToken("_=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  xorAssign: createToken("_=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  moduloAssign: createToken("_=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  incDec: createToken("++/--", {
    prefix: prefix,
    postfix: postfix,
    startsExpr: startsExpr
  }),
  bang: createToken("!", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  tilde: createToken("~", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  doubleCaret: createToken("^^", {
    startsExpr: startsExpr
  }),
  doubleAt: createToken("@@", {
    startsExpr: startsExpr
  }),
  pipeline: createBinop("|>", 0),
  nullishCoalescing: createBinop("??", 1),
  logicalOR: createBinop("||", 1),
  logicalAND: createBinop("&&", 2),
  bitwiseOR: createBinop("|", 3),
  bitwiseXOR: createBinop("^", 4),
  bitwiseAND: createBinop("&", 5),
  equality: createBinop("==/!=/===/!==", 6),
  lt: createBinop("</>/<=/>=", 7),
  gt: createBinop("</>/<=/>=", 7),
  relational: createBinop("</>/<=/>=", 7),
  bitShift: createBinop("<</>>/>>>", 8),
  bitShiftL: createBinop("<</>>/>>>", 8),
  bitShiftR: createBinop("<</>>/>>>", 8),
  plusMin: createToken("+/-", {
    beforeExpr: beforeExpr,
    binop: 9,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  modulo: createToken("%", {
    binop: 10,
    startsExpr: startsExpr
  }),
  star: createToken("*", {
    binop: 10
  }),
  slash: createBinop("/", 10),
  exponent: createToken("**", {
    beforeExpr: beforeExpr,
    binop: 11,
    rightAssociative: true
  }),
  _in: createKeyword("in", {
    beforeExpr: beforeExpr,
    binop: 7
  }),
  _instanceof: createKeyword("instanceof", {
    beforeExpr: beforeExpr,
    binop: 7
  }),
  _break: createKeyword("break"),
  _case: createKeyword("case", {
    beforeExpr: beforeExpr
  }),
  _catch: createKeyword("catch"),
  _continue: createKeyword("continue"),
  _debugger: createKeyword("debugger"),
  _default: createKeyword("default", {
    beforeExpr: beforeExpr
  }),
  _else: createKeyword("else", {
    beforeExpr: beforeExpr
  }),
  _finally: createKeyword("finally"),
  _function: createKeyword("function", {
    startsExpr: startsExpr
  }),
  _if: createKeyword("if"),
  _return: createKeyword("return", {
    beforeExpr: beforeExpr
  }),
  _switch: createKeyword("switch"),
  _throw: createKeyword("throw", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _try: createKeyword("try"),
  _var: createKeyword("var"),
  _const: createKeyword("const"),
  _with: createKeyword("with"),
  _new: createKeyword("new", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  _this: createKeyword("this", {
    startsExpr: startsExpr
  }),
  _super: createKeyword("super", {
    startsExpr: startsExpr
  }),
  _class: createKeyword("class", {
    startsExpr: startsExpr
  }),
  _extends: createKeyword("extends", {
    beforeExpr: beforeExpr
  }),
  _export: createKeyword("export"),
  _import: createKeyword("import", {
    startsExpr: startsExpr
  }),
  _null: createKeyword("null", {
    startsExpr: startsExpr
  }),
  _true: createKeyword("true", {
    startsExpr: startsExpr
  }),
  _false: createKeyword("false", {
    startsExpr: startsExpr
  }),
  _typeof: createKeyword("typeof", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _void: createKeyword("void", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _delete: createKeyword("delete", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _do: createKeyword("do", {
    isLoop: isLoop,
    beforeExpr: beforeExpr
  }),
  _for: createKeyword("for", {
    isLoop: isLoop
  }),
  _while: createKeyword("while", {
    isLoop: isLoop
  }),
  _as: createKeywordLike("as", {
    startsExpr: startsExpr
  }),
  _assert: createKeywordLike("assert", {
    startsExpr: startsExpr
  }),
  _async: createKeywordLike("async", {
    startsExpr: startsExpr
  }),
  _await: createKeywordLike("await", {
    startsExpr: startsExpr
  }),
  _from: createKeywordLike("from", {
    startsExpr: startsExpr
  }),
  _get: createKeywordLike("get", {
    startsExpr: startsExpr
  }),
  _let: createKeywordLike("let", {
    startsExpr: startsExpr
  }),
  _meta: createKeywordLike("meta", {
    startsExpr: startsExpr
  }),
  _of: createKeywordLike("of", {
    startsExpr: startsExpr
  }),
  _sent: createKeywordLike("sent", {
    startsExpr: startsExpr
  }),
  _set: createKeywordLike("set", {
    startsExpr: startsExpr
  }),
  _static: createKeywordLike("static", {
    startsExpr: startsExpr
  }),
  _yield: createKeywordLike("yield", {
    startsExpr: startsExpr
  }),
  _asserts: createKeywordLike("asserts", {
    startsExpr: startsExpr
  }),
  _checks: createKeywordLike("checks", {
    startsExpr: startsExpr
  }),
  _exports: createKeywordLike("exports", {
    startsExpr: startsExpr
  }),
  _global: createKeywordLike("global", {
    startsExpr: startsExpr
  }),
  _implements: createKeywordLike("implements", {
    startsExpr: startsExpr
  }),
  _intrinsic: createKeywordLike("intrinsic", {
    startsExpr: startsExpr
  }),
  _infer: createKeywordLike("infer", {
    startsExpr: startsExpr
  }),
  _is: createKeywordLike("is", {
    startsExpr: startsExpr
  }),
  _mixins: createKeywordLike("mixins", {
    startsExpr: startsExpr
  }),
  _proto: createKeywordLike("proto", {
    startsExpr: startsExpr
  }),
  _require: createKeywordLike("require", {
    startsExpr: startsExpr
  }),
  _keyof: createKeywordLike("keyof", {
    startsExpr: startsExpr
  }),
  _readonly: createKeywordLike("readonly", {
    startsExpr: startsExpr
  }),
  _unique: createKeywordLike("unique", {
    startsExpr: startsExpr
  }),
  _abstract: createKeywordLike("abstract", {
    startsExpr: startsExpr
  }),
  _declare: createKeywordLike("declare", {
    startsExpr: startsExpr
  }),
  _enum: createKeywordLike("enum", {
    startsExpr: startsExpr
  }),
  _module: createKeywordLike("module", {
    startsExpr: startsExpr
  }),
  _namespace: createKeywordLike("namespace", {
    startsExpr: startsExpr
  }),
  _interface: createKeywordLike("interface", {
    startsExpr: startsExpr
  }),
  _type: createKeywordLike("type", {
    startsExpr: startsExpr
  }),
  _opaque: createKeywordLike("opaque", {
    startsExpr: startsExpr
  }),
  name: createToken("name", {
    startsExpr: startsExpr
  }),
  string: createToken("string", {
    startsExpr: startsExpr
  }),
  num: createToken("num", {
    startsExpr: startsExpr
  }),
  bigint: createToken("bigint", {
    startsExpr: startsExpr
  }),
  decimal: createToken("decimal", {
    startsExpr: startsExpr
  }),
  regexp: createToken("regexp", {
    startsExpr: startsExpr
  }),
  privateName: createToken("#name", {
    startsExpr: startsExpr
  }),
  eof: createToken("eof"),
  jsxName: createToken("jsxName"),
  jsxText: createToken("jsxText", {
    beforeExpr: true
  }),
  jsxTagStart: createToken("jsxTagStart", {
    startsExpr: true
  }),
  jsxTagEnd: createToken("jsxTagEnd"),
  placeholder: createToken("%%", {
    startsExpr: true
  })
};

function tokenIsIdentifier(token) {
  return token >= 93 && token <= 128;
}

function tokenKeywordOrIdentifierIsKeyword(token) {
  return token <= 92;
}

function tokenIsKeywordOrIdentifier(token) {
  return token >= 58 && token <= 128;
}

function tokenIsLiteralPropertyName(token) {
  return token >= 58 && token <= 132;
}

function tokenComesBeforeExpression(token) {
  return tokenBeforeExprs[token];
}

function tokenCanStartExpression(token) {
  return tokenStartsExprs[token];
}

function tokenIsAssignment(token) {
  return token >= 29 && token <= 33;
}

function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
  return token >= 125 && token <= 127;
}

function tokenIsLoop(token) {
  return token >= 90 && token <= 92;
}

function tokenIsKeyword(token) {
  return token >= 58 && token <= 92;
}

function tokenIsOperator(token) {
  return token >= 39 && token <= 59;
}

function tokenIsPostfix(token) {
  return token === 34;
}

function tokenIsPrefix(token) {
  return tokenPrefixes[token];
}

function tokenIsTSTypeOperator(token) {
  return token >= 117 && token <= 119;
}

function tokenIsTSDeclarationStart(token) {
  return token >= 120 && token <= 126;
}

function tokenLabelName(token) {
  return tokenLabels[token];
}

function tokenOperatorPrecedence(token) {
  return tokenBinops[token];
}

function tokenIsRightAssociative(token) {
  return token === 57;
}

function tokenIsTemplate(token) {
  return token >= 24 && token <= 25;
}

function getExportedToken(token) {
  return tokenTypes[token];
}

{
  tokenTypes[8].updateContext = function (context) {
    context.pop();
  };

  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = function (context) {
    context.push(types.brace);
  };

  tokenTypes[22].updateContext = function (context) {
    if (context[context.length - 1] === types.template) {
      context.pop();
    } else {
      context.push(types.template);
    }
  };

  tokenTypes[138].updateContext = function (context) {
    context.push(types.j_expr, types.j_oTag);
  };
}
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

function isInAstralSet(code, set) {
  var pos = 0x10000;

  for (var i = 0, length = set.length; i < length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }

  return false;
}

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
}

function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

var reservedWords = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
var keywords = new Set(reservedWords.keyword);
var reservedWordsStrictSet = new Set(reservedWords.strict);
var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);

function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
}

function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}

function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}

function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}

function isKeyword(word) {
  return keywords.has(word);
}

function isIteratorStart(current, next, next2) {
  return current === 64 && next === 64 && isIdentifierStart(next2);
}

var reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);

function canBeReservedWord(word) {
  return reservedWordLikeSet.has(word);
}

var SCOPE_OTHER = 0,
    SCOPE_PROGRAM = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_ARROW = 4,
    SCOPE_SIMPLE_CATCH = 8,
    SCOPE_SUPER = 16,
    SCOPE_DIRECT_SUPER = 32,
    SCOPE_CLASS = 64,
    SCOPE_STATIC_BLOCK = 128,
    SCOPE_TS_MODULE = 256,
    SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
var BIND_KIND_VALUE = 1,
    BIND_KIND_TYPE = 2,
    BIND_SCOPE_VAR = 4,
    BIND_SCOPE_LEXICAL = 8,
    BIND_SCOPE_FUNCTION = 16,
    BIND_FLAGS_NONE = 64,
    BIND_FLAGS_CLASS = 128,
    BIND_FLAGS_TS_ENUM = 256,
    BIND_FLAGS_TS_CONST_ENUM = 512,
    BIND_FLAGS_TS_EXPORT_ONLY = 1024,
    BIND_FLAGS_FLOW_DECLARE_FN = 2048,
    BIND_FLAGS_TS_IMPORT = 4096;
var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
    BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
    BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
    BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
    BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
    BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
    BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
    BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
    BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
    BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
    BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
    BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
    BIND_TS_TYPE_IMPORT = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_TS_IMPORT,
    BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
var CLASS_ELEMENT_FLAG_STATIC = 4,
    CLASS_ELEMENT_KIND_GETTER = 2,
    CLASS_ELEMENT_KIND_SETTER = 1,
    CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
    CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
    CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
    CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
    CLASS_ELEMENT_OTHER = 0;

var Scope = function Scope(flags) {
  _classCallCheck(this, Scope);

  this["var"] = new Set();
  this.lexical = new Set();
  this.functions = new Set();
  this.flags = flags;
};

var ScopeHandler =
/*#__PURE__*/
function () {
  function ScopeHandler(parser, inModule) {
    _classCallCheck(this, ScopeHandler);

    this.parser = void 0;
    this.scopeStack = [];
    this.inModule = void 0;
    this.undefinedExports = new Map();
    this.parser = parser;
    this.inModule = inModule;
  }

  _createClass(ScopeHandler, [{
    key: "createScope",
    value: function createScope(flags) {
      return new Scope(flags);
    }
  }, {
    key: "enter",
    value: function enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
  }, {
    key: "exit",
    value: function exit() {
      var scope = this.scopeStack.pop();
      return scope.flags;
    }
  }, {
    key: "treatFunctionsAsVarInScope",
    value: function treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);
    }
  }, {
    key: "declareName",
    value: function declareName(name, bindingType, loc) {
      var scope = this.currentScope();

      if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, loc);

        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.add(name);
        } else {
          scope.lexical.add(name);
        }

        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          scope["var"].add(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR) break;
        }
      }

      if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    }
  }, {
    key: "maybeExportDefined",
    value: function maybeExportDefined(scope, name) {
      if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    }
  }, {
    key: "checkRedeclarationInScope",
    value: function checkRedeclarationInScope(scope, name, bindingType, loc) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.parser.raise(Errors.VarRedeclaration, {
          at: loc,
          identifierName: name
        });
      }
    }
  }, {
    key: "isRedeclaredInScope",
    value: function isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE)) return false;

      if (bindingType & BIND_SCOPE_LEXICAL) {
        return scope.lexical.has(name) || scope.functions.has(name) || scope["var"].has(name);
      }

      if (bindingType & BIND_SCOPE_FUNCTION) {
        return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope["var"].has(name);
      }

      return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
    }
  }, {
    key: "checkLocalExport",
    value: function checkLocalExport(id) {
      var name = id.name;
      var topLevelScope = this.scopeStack[0];

      if (!topLevelScope.lexical.has(name) && !topLevelScope["var"].has(name) && !topLevelScope.functions.has(name)) {
        this.undefinedExports.set(name, id.loc.start);
      }
    }
  }, {
    key: "currentScope",
    value: function currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
  }, {
    key: "currentVarScopeFlags",
    value: function currentVarScopeFlags() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var flags = this.scopeStack[i].flags;

        if (flags & SCOPE_VAR) {
          return flags;
        }
      }
    }
  }, {
    key: "currentThisScopeFlags",
    value: function currentThisScopeFlags() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var flags = this.scopeStack[i].flags;

        if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
          return flags;
        }
      }
    }
  }, {
    key: "inFunction",
    get: function get() {
      return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
    }
  }, {
    key: "allowSuper",
    get: function get() {
      return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
    }
  }, {
    key: "allowDirectSuper",
    get: function get() {
      return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
    }
  }, {
    key: "inClass",
    get: function get() {
      return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
    }
  }, {
    key: "inClassAndNotInNonArrowFunction",
    get: function get() {
      var flags = this.currentThisScopeFlags();
      return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
    }
  }, {
    key: "inStaticBlock",
    get: function get() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var flags = this.scopeStack[i].flags;

        if (flags & SCOPE_STATIC_BLOCK) {
          return true;
        }

        if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
          return false;
        }
      }
    }
  }, {
    key: "inNonArrowFunction",
    get: function get() {
      return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
    }
  }, {
    key: "treatFunctionsAsVar",
    get: function get() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
  }]);

  return ScopeHandler;
}();

var FlowScope =
/*#__PURE__*/
function (_Scope) {
  _inherits(FlowScope, _Scope);

  function FlowScope() {
    var _getPrototypeOf2;

    var _this3;

    _classCallCheck(this, FlowScope);

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    _this3 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FlowScope)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _this3.declareFunctions = new Set();
    return _this3;
  }

  return FlowScope;
}(Scope);

var FlowScopeHandler =
/*#__PURE__*/
function (_ScopeHandler) {
  _inherits(FlowScopeHandler, _ScopeHandler);

  function FlowScopeHandler() {
    _classCallCheck(this, FlowScopeHandler);

    return _possibleConstructorReturn(this, _getPrototypeOf(FlowScopeHandler).apply(this, arguments));
  }

  _createClass(FlowScopeHandler, [{
    key: "createScope",
    value: function createScope(flags) {
      return new FlowScope(flags);
    }
  }, {
    key: "declareName",
    value: function declareName(name, bindingType, loc) {
      var scope = this.currentScope();

      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        this.checkRedeclarationInScope(scope, name, bindingType, loc);
        this.maybeExportDefined(scope, name);
        scope.declareFunctions.add(name);
        return;
      }

      _get(_getPrototypeOf(FlowScopeHandler.prototype), "declareName", this).call(this, name, bindingType, loc);
    }
  }, {
    key: "isRedeclaredInScope",
    value: function isRedeclaredInScope(scope, name, bindingType) {
      if (_get(_getPrototypeOf(FlowScopeHandler.prototype), "isRedeclaredInScope", this).call(this, scope, name, bindingType)) return true;

      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
      }

      return false;
    }
  }, {
    key: "checkLocalExport",
    value: function checkLocalExport(id) {
      if (!this.scopeStack[0].declareFunctions.has(id.name)) {
        _get(_getPrototypeOf(FlowScopeHandler.prototype), "checkLocalExport", this).call(this, id);
      }
    }
  }]);

  return FlowScopeHandler;
}(ScopeHandler);

var BaseParser =
/*#__PURE__*/
function () {
  function BaseParser() {
    _classCallCheck(this, BaseParser);

    this.sawUnambiguousESM = false;
    this.ambiguousScriptDifferentAst = false;
  }

  _createClass(BaseParser, [{
    key: "hasPlugin",
    value: function hasPlugin(pluginConfig) {
      if (typeof pluginConfig === "string") {
        return this.plugins.has(pluginConfig);
      } else {
        var _pluginConfig = _slicedToArray(pluginConfig, 2),
            pluginName = _pluginConfig[0],
            pluginOptions = _pluginConfig[1];

        if (!this.hasPlugin(pluginName)) {
          return false;
        }

        var actualOptions = this.plugins.get(pluginName);

        for (var _i3 = 0, _Object$keys2 = Object.keys(pluginOptions); _i3 < _Object$keys2.length; _i3++) {
          var key = _Object$keys2[_i3];

          if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
            return false;
          }
        }

        return true;
      }
    }
  }, {
    key: "getPluginOption",
    value: function getPluginOption(plugin, name) {
      var _this$plugins$get;

      return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
    }
  }]);

  return BaseParser;
}();

function setTrailingComments(node, comments) {
  if (node.trailingComments === undefined) {
    node.trailingComments = comments;
  } else {
    var _node$trailingComment;

    (_node$trailingComment = node.trailingComments).unshift.apply(_node$trailingComment, _toConsumableArray(comments));
  }
}

function setLeadingComments(node, comments) {
  if (node.leadingComments === undefined) {
    node.leadingComments = comments;
  } else {
    var _node$leadingComments;

    (_node$leadingComments = node.leadingComments).unshift.apply(_node$leadingComments, _toConsumableArray(comments));
  }
}

function setInnerComments(node, comments) {
  if (node.innerComments === undefined) {
    node.innerComments = comments;
  } else {
    var _node$innerComments;

    (_node$innerComments = node.innerComments).unshift.apply(_node$innerComments, _toConsumableArray(comments));
  }
}

function adjustInnerComments(node, elements, commentWS) {
  var lastElement = null;
  var i = elements.length;

  while (lastElement === null && i > 0) {
    lastElement = elements[--i];
  }

  if (lastElement === null || lastElement.start > commentWS.start) {
    setInnerComments(node, commentWS.comments);
  } else {
    setTrailingComments(lastElement, commentWS.comments);
  }
}

var CommentsParser =
/*#__PURE__*/
function (_BaseParser) {
  _inherits(CommentsParser, _BaseParser);

  function CommentsParser() {
    _classCallCheck(this, CommentsParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(CommentsParser).apply(this, arguments));
  }

  _createClass(CommentsParser, [{
    key: "addComment",
    value: function addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      this.state.comments.push(comment);
    }
  }, {
    key: "processComment",
    value: function processComment(node) {
      var commentStack = this.state.commentStack;
      var commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      var i = commentStackLength - 1;
      var lastCommentWS = commentStack[i];

      if (lastCommentWS.start === node.end) {
        lastCommentWS.leadingNode = node;
        i--;
      }

      var nodeStart = node.start;

      for (; i >= 0; i--) {
        var commentWS = commentStack[i];
        var commentEnd = commentWS.end;

        if (commentEnd > nodeStart) {
          commentWS.containingNode = node;
          this.finalizeComment(commentWS);
          commentStack.splice(i, 1);
        } else {
          if (commentEnd === nodeStart) {
            commentWS.trailingNode = node;
          }

          break;
        }
      }
    }
  }, {
    key: "finalizeComment",
    value: function finalizeComment(commentWS) {
      var comments = commentWS.comments;

      if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
        if (commentWS.leadingNode !== null) {
          setTrailingComments(commentWS.leadingNode, comments);
        }

        if (commentWS.trailingNode !== null) {
          setLeadingComments(commentWS.trailingNode, comments);
        }
      } else {
        var node = commentWS.containingNode,
            commentStart = commentWS.start;

        if (this.input.charCodeAt(commentStart - 1) === 44) {
          switch (node.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              adjustInnerComments(node, node.properties, commentWS);
              break;

            case "CallExpression":
            case "OptionalCallExpression":
              adjustInnerComments(node, node.arguments, commentWS);
              break;

            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              adjustInnerComments(node, node.params, commentWS);
              break;

            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              adjustInnerComments(node, node.elements, commentWS);
              break;

            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              adjustInnerComments(node, node.specifiers, commentWS);
              break;

            default:
              {
                setInnerComments(node, comments);
              }
          }
        } else {
          setInnerComments(node, comments);
        }
      }
    }
  }, {
    key: "finalizeRemainingComments",
    value: function finalizeRemainingComments() {
      var commentStack = this.state.commentStack;

      for (var i = commentStack.length - 1; i >= 0; i--) {
        this.finalizeComment(commentStack[i]);
      }

      this.state.commentStack = [];
    }
  }, {
    key: "resetPreviousNodeTrailingComments",
    value: function resetPreviousNodeTrailingComments(node) {
      var commentStack = this.state.commentStack;
      var length = commentStack.length;
      if (length === 0) return;
      var commentWS = commentStack[length - 1];

      if (commentWS.leadingNode === node) {
        commentWS.leadingNode = null;
      }
    }
  }, {
    key: "takeSurroundingComments",
    value: function takeSurroundingComments(node, start, end) {
      var commentStack = this.state.commentStack;
      var commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      var i = commentStackLength - 1;

      for (; i >= 0; i--) {
        var commentWS = commentStack[i];
        var commentEnd = commentWS.end;
        var commentStart = commentWS.start;

        if (commentStart === end) {
          commentWS.leadingNode = node;
        } else if (commentEnd === start) {
          commentWS.trailingNode = node;
        } else if (commentEnd < start) {
          break;
        }
      }
    }
  }]);

  return CommentsParser;
}(BaseParser);

var lineBreak = /\r\n?|[\n\u2028\u2029]/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  switch (code) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;

    default:
      return false;
  }
}

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var skipWhiteSpaceInLine = new RegExp("(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*", "y");
var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");

function isWhitespace(code) {
  switch (code) {
    case 0x0009:
    case 0x000b:
    case 0x000c:
    case 32:
    case 160:
    case 5760:
    case 0x2000:
    case 0x2001:
    case 0x2002:
    case 0x2003:
    case 0x2004:
    case 0x2005:
    case 0x2006:
    case 0x2007:
    case 0x2008:
    case 0x2009:
    case 0x200a:
    case 0x202f:
    case 0x205f:
    case 0x3000:
    case 0xfeff:
      return true;

    default:
      return false;
  }
}

var State =
/*#__PURE__*/
function () {
  function State() {
    _classCallCheck(this, State);

    this.strict = void 0;
    this.curLine = void 0;
    this.lineStart = void 0;
    this.startLoc = void 0;
    this.endLoc = void 0;
    this.errors = [];
    this.potentialArrowAt = -1;
    this.noArrowAt = [];
    this.noArrowParamsConversionAt = [];
    this.maybeInArrowParameters = false;
    this.inType = false;
    this.noAnonFunctionType = false;
    this.hasFlowComment = false;
    this.isAmbientContext = false;
    this.inAbstractClass = false;
    this.inDisallowConditionalTypesContext = false;
    this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    };
    this.soloAwait = false;
    this.inFSharpPipelineDirectBody = false;
    this.labels = [];
    this.decoratorStack = [[]];
    this.comments = [];
    this.commentStack = [];
    this.pos = 0;
    this.type = 135;
    this.value = null;
    this.start = 0;
    this.end = 0;
    this.lastTokEndLoc = null;
    this.lastTokStartLoc = null;
    this.lastTokStart = 0;
    this.context = [types.brace];
    this.canStartJSXElement = true;
    this.containsEsc = false;
    this.strictErrors = new Map();
    this.tokensLength = 0;
  }

  _createClass(State, [{
    key: "init",
    value: function init(_ref44) {
      var strictMode = _ref44.strictMode,
          sourceType = _ref44.sourceType,
          startLine = _ref44.startLine,
          startColumn = _ref44.startColumn;
      this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
      this.curLine = startLine;
      this.lineStart = -startColumn;
      this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
    }
  }, {
    key: "curPosition",
    value: function curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart, this.pos);
    }
  }, {
    key: "clone",
    value: function clone(skipArrays) {
      var state = new State();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var val = this[key];

        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }

        state[key] = val;
      }

      return state;
    }
  }]);

  return State;
}();

var _isDigit = function isDigit(code) {
  return code >= 48 && code <= 57;
};

var forbiddenNumericSeparatorSiblings = {
  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: new Set([46, 88, 95, 120])
};
var isAllowedNumericSeparatorSibling = {
  bin: function bin(ch) {
    return ch === 48 || ch === 49;
  },
  oct: function oct(ch) {
    return ch >= 48 && ch <= 55;
  },
  dec: function dec(ch) {
    return ch >= 48 && ch <= 57;
  },
  hex: function hex(ch) {
    return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
  }
};

function readStringContents(type, input, pos, lineStart, curLine, errors) {
  var initialPos = pos;
  var initialLineStart = lineStart;
  var initialCurLine = curLine;
  var out = "";
  var containsInvalid = false;
  var chunkStart = pos;
  var length = input.length;

  for (;;) {
    if (pos >= length) {
      errors.unterminated(initialPos, initialLineStart, initialCurLine);
      out += input.slice(chunkStart, pos);
      break;
    }

    var ch = input.charCodeAt(pos);

    if (isStringEnd(type, ch, input, pos)) {
      out += input.slice(chunkStart, pos);
      break;
    }

    if (ch === 92) {
      out += input.slice(chunkStart, pos);
      var escaped = void 0;

      var _readEscapedChar = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);

      escaped = _readEscapedChar.ch;
      pos = _readEscapedChar.pos;
      lineStart = _readEscapedChar.lineStart;
      curLine = _readEscapedChar.curLine;

      if (escaped === null) {
        containsInvalid = true;
      } else {
        out += escaped;
      }

      chunkStart = pos;
    } else if (ch === 8232 || ch === 8233) {
      ++pos;
      ++curLine;
      lineStart = pos;
    } else if (ch === 10 || ch === 13) {
      if (type === "template") {
        out += input.slice(chunkStart, pos) + "\n";
        ++pos;

        if (ch === 13 && input.charCodeAt(pos) === 10) {
          ++pos;
        }

        ++curLine;
        chunkStart = lineStart = pos;
      } else {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
      }
    } else {
      ++pos;
    }
  }

  return {
    pos: pos,
    str: out,
    containsInvalid: containsInvalid,
    lineStart: lineStart,
    curLine: curLine
  };
}

function isStringEnd(type, ch, input, pos) {
  if (type === "template") {
    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
  }

  return ch === (type === "double" ? 34 : 39);
}

function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
  var throwOnInvalid = !inTemplate;
  pos++;

  var res = function res(ch) {
    return {
      pos: pos,
      ch: ch,
      lineStart: lineStart,
      curLine: curLine
    };
  };

  var ch = input.charCodeAt(pos++);

  switch (ch) {
    case 110:
      return res("\n");

    case 114:
      return res("\r");

    case 120:
      {
        var code;

        var _readHexChar = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors);

        code = _readHexChar.code;
        pos = _readHexChar.pos;
        return res(code === null ? null : String.fromCharCode(code));
      }

    case 117:
      {
        var _code;

        var _readCodePoint = _readCodePoint2(input, pos, lineStart, curLine, throwOnInvalid, errors);

        _code = _readCodePoint.code;
        pos = _readCodePoint.pos;
        return res(_code === null ? null : String.fromCodePoint(_code));
      }

    case 116:
      return res("\t");

    case 98:
      return res("\b");

    case 118:
      return res("\x0B");

    case 102:
      return res("\f");

    case 13:
      if (input.charCodeAt(pos) === 10) {
        ++pos;
      }

    case 10:
      lineStart = pos;
      ++curLine;

    case 8232:
    case 8233:
      return res("");

    case 56:
    case 57:
      if (inTemplate) {
        return res(null);
      } else {
        errors.strictNumericEscape(pos - 1, lineStart, curLine);
      }

    default:
      if (ch >= 48 && ch <= 55) {
        var startPos = pos - 1;
        var match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
        var octalStr = match[0];
        var octal = parseInt(octalStr, 8);

        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }

        pos += octalStr.length - 1;
        var next = input.charCodeAt(pos);

        if (octalStr !== "0" || next === 56 || next === 57) {
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(startPos, lineStart, curLine);
          }
        }

        return res(String.fromCharCode(octal));
      }

      return res(String.fromCharCode(ch));
  }
}

function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
  var initialPos = pos;
  var n;

  var _readInt = _readInt2(input, pos, lineStart, curLine, 16, len, forceLen, false, errors);

  n = _readInt.n;
  pos = _readInt.pos;

  if (n === null) {
    if (throwOnInvalid) {
      errors.invalidEscapeSequence(initialPos, lineStart, curLine);
    } else {
      pos = initialPos - 1;
    }
  }

  return {
    code: n,
    pos: pos
  };
}

function _readInt2(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors) {
  var start = pos;
  var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
  var isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
  var invalid = false;
  var total = 0;

  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = input.charCodeAt(pos);
    var val = void 0;

    if (code === 95 && allowNumSeparator !== "bail") {
      var prev = input.charCodeAt(pos - 1);
      var next = input.charCodeAt(pos + 1);

      if (!allowNumSeparator) {
        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
        errors.unexpectedNumericSeparator(pos, lineStart, curLine);
      }

      ++pos;
      continue;
    }

    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (_isDigit(code)) {
      val = code - 48;
    } else {
      val = Infinity;
    }

    if (val >= radix) {
      if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
        val = 0;
      } else if (forceLen) {
        val = 0;
        invalid = true;
      } else {
        break;
      }
    }

    ++pos;
    total = total * radix + val;
  }

  if (pos === start || len != null && pos - start !== len || invalid) {
    return {
      n: null,
      pos: pos
    };
  }

  return {
    n: total,
    pos: pos
  };
}

function _readCodePoint2(input, pos, lineStart, curLine, throwOnInvalid, errors) {
  var ch = input.charCodeAt(pos);
  var code;

  if (ch === 123) {
    ++pos;

    var _readHexChar2 = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors);

    code = _readHexChar2.code;
    pos = _readHexChar2.pos;
    ++pos;

    if (code !== null && code > 0x10ffff) {
      if (throwOnInvalid) {
        errors.invalidCodePoint(pos, lineStart, curLine);
      } else {
        return {
          code: null,
          pos: pos
        };
      }
    }
  } else {
    var _readHexChar3 = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors);

    code = _readHexChar3.code;
    pos = _readHexChar3.pos;
  }

  return {
    code: code,
    pos: pos
  };
}

var _excluded = ["at"],
    _excluded2 = ["at"];

function buildPosition(pos, lineStart, curLine) {
  return new Position(curLine, pos - lineStart, pos);
}

var VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);

var Token = function Token(state) {
  _classCallCheck(this, Token);

  this.type = state.type;
  this.value = state.value;
  this.start = state.start;
  this.end = state.end;
  this.loc = new SourceLocation(state.startLoc, state.endLoc);
};

var Tokenizer =
/*#__PURE__*/
function (_CommentsParser) {
  _inherits(Tokenizer, _CommentsParser);

  function Tokenizer(options, input) {
    var _this4;

    _classCallCheck(this, Tokenizer);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Tokenizer).call(this));
    _this4.isLookahead = void 0;
    _this4.tokens = [];
    _this4.errorHandlers_readInt = {
      invalidDigit: function invalidDigit(pos, lineStart, curLine, radix) {
        if (!_this4.options.errorRecovery) return false;

        _this4.raise(Errors.InvalidDigit, {
          at: buildPosition(pos, lineStart, curLine),
          radix: radix
        });

        return true;
      },
      numericSeparatorInEscapeSequence: _this4.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
      unexpectedNumericSeparator: _this4.errorBuilder(Errors.UnexpectedNumericSeparator)
    };
    _this4.errorHandlers_readCodePoint = Object.assign({}, _this4.errorHandlers_readInt, {
      invalidEscapeSequence: _this4.errorBuilder(Errors.InvalidEscapeSequence),
      invalidCodePoint: _this4.errorBuilder(Errors.InvalidCodePoint)
    });
    _this4.errorHandlers_readStringContents_string = Object.assign({}, _this4.errorHandlers_readCodePoint, {
      strictNumericEscape: function strictNumericEscape(pos, lineStart, curLine) {
        _this4.recordStrictModeErrors(Errors.StrictNumericEscape, {
          at: buildPosition(pos, lineStart, curLine)
        });
      },
      unterminated: function unterminated(pos, lineStart, curLine) {
        throw _this4.raise(Errors.UnterminatedString, {
          at: buildPosition(pos - 1, lineStart, curLine)
        });
      }
    });
    _this4.errorHandlers_readStringContents_template = Object.assign({}, _this4.errorHandlers_readCodePoint, {
      strictNumericEscape: _this4.errorBuilder(Errors.StrictNumericEscape),
      unterminated: function unterminated(pos, lineStart, curLine) {
        throw _this4.raise(Errors.UnterminatedTemplate, {
          at: buildPosition(pos, lineStart, curLine)
        });
      }
    });
    _this4.state = new State();

    _this4.state.init(options);

    _this4.input = input;
    _this4.length = input.length;
    _this4.isLookahead = false;
    return _this4;
  }

  _createClass(Tokenizer, [{
    key: "pushToken",
    value: function pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    }
  }, {
    key: "next",
    value: function next() {
      this.checkKeywordEscapes();

      if (this.options.tokens) {
        this.pushToken(new Token(this.state));
      }

      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }
  }, {
    key: "eat",
    value: function eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "match",
    value: function match(type) {
      return this.state.type === type;
    }
  }, {
    key: "createLookaheadState",
    value: function createLookaheadState(state) {
      return {
        pos: state.pos,
        value: null,
        type: state.type,
        start: state.start,
        end: state.end,
        context: [this.curContext()],
        inType: state.inType,
        startLoc: state.startLoc,
        lastTokEndLoc: state.lastTokEndLoc,
        curLine: state.curLine,
        lineStart: state.lineStart,
        curPosition: state.curPosition
      };
    }
  }, {
    key: "lookahead",
    value: function lookahead() {
      var old = this.state;
      this.state = this.createLookaheadState(old);
      this.isLookahead = true;
      this.nextToken();
      this.isLookahead = false;
      var curr = this.state;
      this.state = old;
      return curr;
    }
  }, {
    key: "nextTokenStart",
    value: function nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
  }, {
    key: "nextTokenStartSince",
    value: function nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    }
  }, {
    key: "lookaheadCharCode",
    value: function lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
  }, {
    key: "codePointAtPos",
    value: function codePointAtPos(pos) {
      var cp = this.input.charCodeAt(pos);

      if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {
        var trail = this.input.charCodeAt(pos);

        if ((trail & 0xfc00) === 0xdc00) {
          cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
      }

      return cp;
    }
  }, {
    key: "setStrict",
    value: function setStrict(strict) {
      var _this5 = this;

      this.state.strict = strict;

      if (strict) {
        this.state.strictErrors.forEach(function (_ref45) {
          var _ref46 = _slicedToArray(_ref45, 2),
              toParseError = _ref46[0],
              at = _ref46[1];

          return _this5.raise(toParseError, {
            at: at
          });
        });
        this.state.strictErrors.clear();
      }
    }
  }, {
    key: "curContext",
    value: function curContext() {
      return this.state.context[this.state.context.length - 1];
    }
  }, {
    key: "nextToken",
    value: function nextToken() {
      this.skipSpace();
      this.state.start = this.state.pos;
      if (!this.isLookahead) this.state.startLoc = this.state.curPosition();

      if (this.state.pos >= this.length) {
        this.finishToken(135);
        return;
      }

      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
  }, {
    key: "skipBlockComment",
    value: function skipBlockComment() {
      var startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      var start = this.state.pos;
      var end = this.input.indexOf("*/", start + 2);

      if (end === -1) {
        throw this.raise(Errors.UnterminatedComment, {
          at: this.state.curPosition()
        });
      }

      this.state.pos = end + 2;
      lineBreakG.lastIndex = start + 2;

      while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
        ++this.state.curLine;
        this.state.lineStart = lineBreakG.lastIndex;
      }

      if (this.isLookahead) return;
      var comment = {
        type: "CommentBlock",
        value: this.input.slice(start + 2, end),
        start: start,
        end: end + 2,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.options.tokens) this.pushToken(comment);
      return comment;
    }
  }, {
    key: "skipLineComment",
    value: function skipLineComment(startSkip) {
      var start = this.state.pos;
      var startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      var ch = this.input.charCodeAt(this.state.pos += startSkip);

      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }

      if (this.isLookahead) return;
      var end = this.state.pos;
      var value = this.input.slice(start + startSkip, end);
      var comment = {
        type: "CommentLine",
        value: value,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.options.tokens) this.pushToken(comment);
      return comment;
    }
  }, {
    key: "skipSpace",
    value: function skipSpace() {
      var spaceStart = this.state.pos;
      var comments = [];

      loop: while (this.state.pos < this.length) {
        var ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;

          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }

          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;

          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                {
                  var comment = this.skipBlockComment();

                  if (comment !== undefined) {
                    this.addComment(comment);
                    if (this.options.attachComment) comments.push(comment);
                  }

                  break;
                }

              case 47:
                {
                  var _comment = this.skipLineComment(2);

                  if (_comment !== undefined) {
                    this.addComment(_comment);
                    if (this.options.attachComment) comments.push(_comment);
                  }

                  break;
                }

              default:
                break loop;
            }

            break;

          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else if (ch === 45 && !this.inModule) {
              var pos = this.state.pos;

              if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                var _comment2 = this.skipLineComment(3);

                if (_comment2 !== undefined) {
                  this.addComment(_comment2);
                  if (this.options.attachComment) comments.push(_comment2);
                }
              } else {
                break loop;
              }
            } else if (ch === 60 && !this.inModule) {
              var _pos = this.state.pos;

              if (this.input.charCodeAt(_pos + 1) === 33 && this.input.charCodeAt(_pos + 2) === 45 && this.input.charCodeAt(_pos + 3) === 45) {
                var _comment3 = this.skipLineComment(4);

                if (_comment3 !== undefined) {
                  this.addComment(_comment3);
                  if (this.options.attachComment) comments.push(_comment3);
                }
              } else {
                break loop;
              }
            } else {
              break loop;
            }

        }
      }

      if (comments.length > 0) {
        var end = this.state.pos;
        var commentWhitespace = {
          start: spaceStart,
          end: end,
          comments: comments,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(commentWhitespace);
      }
    }
  }, {
    key: "finishToken",
    value: function finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      var prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;

      if (!this.isLookahead) {
        this.updateContext(prevType);
      }
    }
  }, {
    key: "replaceToken",
    value: function replaceToken(type) {
      this.state.type = type;
      this.updateContext();
    }
  }, {
    key: "readToken_numberSign",
    value: function readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }

      var nextPos = this.state.pos + 1;
      var next = this.codePointAtPos(nextPos);

      if (next >= 48 && next <= 57) {
        throw this.raise(Errors.UnexpectedDigitAfterHash, {
          at: this.state.curPosition()
        });
      }

      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");

        if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
          throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
            at: this.state.curPosition()
          });
        }

        this.state.pos += 2;

        if (next === 123) {
          this.finishToken(7);
        } else {
          this.finishToken(1);
        }
      } else if (isIdentifierStart(next)) {
        ++this.state.pos;
        this.finishToken(134, this.readWord1(next));
      } else if (next === 92) {
        ++this.state.pos;
        this.finishToken(134, this.readWord1());
      } else {
        this.finishOp(27, 1);
      }
    }
  }, {
    key: "readToken_dot",
    value: function readToken_dot() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }

      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(21);
      } else {
        ++this.state.pos;
        this.finishToken(16);
      }
    }
  }, {
    key: "readToken_slash",
    value: function readToken_slash() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(31, 2);
      } else {
        this.finishOp(56, 1);
      }
    }
  }, {
    key: "readToken_interpreter",
    value: function readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      var ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return false;
      var start = this.state.pos;
      this.state.pos += 1;

      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }

      var value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(28, value);
      return true;
    }
  }, {
    key: "readToken_mult_modulo",
    value: function readToken_mult_modulo(code) {
      var type = code === 42 ? 55 : 54;
      var width = 1;
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = 57;
      }

      if (next === 61 && !this.state.inType) {
        width++;
        type = code === 37 ? 33 : 30;
      }

      this.finishOp(type, width);
    }
  }, {
    key: "readToken_pipe_amp",
    value: function readToken_pipe_amp(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(30, 3);
        } else {
          this.finishOp(code === 124 ? 41 : 42, 2);
        }

        return;
      }

      if (code === 124) {
        if (next === 62) {
          this.finishOp(39, 2);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
              at: this.state.curPosition()
            });
          }

          this.state.pos += 2;
          this.finishToken(9);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
              at: this.state.curPosition()
            });
          }

          this.state.pos += 2;
          this.finishToken(4);
          return;
        }
      }

      if (next === 61) {
        this.finishOp(30, 2);
        return;
      }

      this.finishOp(code === 124 ? 43 : 45, 1);
    }
  }, {
    key: "readToken_caret",
    value: function readToken_caret() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61 && !this.state.inType) {
        this.finishOp(32, 2);
      } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }])) {
        this.finishOp(37, 2);
        var lookaheadCh = this.input.codePointAt(this.state.pos);

        if (lookaheadCh === 94) {
          throw this.unexpected();
        }
      } else {
        this.finishOp(44, 1);
      }
    }
  }, {
    key: "readToken_atSign",
    value: function readToken_atSign() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }])) {
        this.finishOp(38, 2);
      } else {
        this.finishOp(26, 1);
      }
    }
  }, {
    key: "readToken_plus_min",
    value: function readToken_plus_min(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        this.finishOp(34, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(30, 2);
      } else {
        this.finishOp(53, 1);
      }
    }
  }, {
    key: "readToken_lt",
    value: function readToken_lt() {
      var pos = this.state.pos;
      var next = this.input.charCodeAt(pos + 1);

      if (next === 60) {
        if (this.input.charCodeAt(pos + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }

        this.finishOp(51, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }

      this.finishOp(47, 1);
    }
  }, {
    key: "readToken_gt",
    value: function readToken_gt() {
      var pos = this.state.pos;
      var next = this.input.charCodeAt(pos + 1);

      if (next === 62) {
        var size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;

        if (this.input.charCodeAt(pos + size) === 61) {
          this.finishOp(30, size + 1);
          return;
        }

        this.finishOp(52, size);
        return;
      }

      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }

      this.finishOp(48, 1);
    }
  }, {
    key: "readToken_eq_excl",
    value: function readToken_eq_excl(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }

      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(19);
        return;
      }

      this.finishOp(code === 61 ? 29 : 35, 1);
    }
  }, {
    key: "readToken_question",
    value: function readToken_question() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var next2 = this.input.charCodeAt(this.state.pos + 2);

      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(30, 3);
        } else {
          this.finishOp(40, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(18);
      } else {
        ++this.state.pos;
        this.finishToken(17);
      }
    }
  }, {
    key: "getTokenFromCode",
    value: function getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;

        case 40:
          ++this.state.pos;
          this.finishToken(10);
          return;

        case 41:
          ++this.state.pos;
          this.finishToken(11);
          return;

        case 59:
          ++this.state.pos;
          this.finishToken(13);
          return;

        case 44:
          ++this.state.pos;
          this.finishToken(12);
          return;

        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            }

            this.state.pos += 2;
            this.finishToken(2);
          } else {
            ++this.state.pos;
            this.finishToken(0);
          }

          return;

        case 93:
          ++this.state.pos;
          this.finishToken(3);
          return;

        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            }

            this.state.pos += 2;
            this.finishToken(6);
          } else {
            ++this.state.pos;
            this.finishToken(5);
          }

          return;

        case 125:
          ++this.state.pos;
          this.finishToken(8);
          return;

        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(15, 2);
          } else {
            ++this.state.pos;
            this.finishToken(14);
          }

          return;

        case 63:
          this.readToken_question();
          return;

        case 96:
          this.readTemplateToken();
          return;

        case 48:
          {
            var next = this.input.charCodeAt(this.state.pos + 1);

            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }

            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }

            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }

        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;

        case 34:
        case 39:
          this.readString(code);
          return;

        case 47:
          this.readToken_slash();
          return;

        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;

        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;

        case 94:
          this.readToken_caret();
          return;

        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;

        case 60:
          this.readToken_lt();
          return;

        case 62:
          this.readToken_gt();
          return;

        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;

        case 126:
          this.finishOp(36, 1);
          return;

        case 64:
          this.readToken_atSign();
          return;

        case 35:
          this.readToken_numberSign();
          return;

        case 92:
          this.readWord();
          return;

        default:
          if (isIdentifierStart(code)) {
            this.readWord(code);
            return;
          }

      }

      throw this.raise(Errors.InvalidOrUnexpectedToken, {
        at: this.state.curPosition(),
        unexpected: String.fromCodePoint(code)
      });
    }
  }, {
    key: "finishOp",
    value: function finishOp(type, size) {
      var str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    }
  }, {
    key: "readRegexp",
    value: function readRegexp() {
      var startLoc = this.state.startLoc;
      var start = this.state.start + 1;
      var escaped, inClass;
      var pos = this.state.pos;

      for (;; ++pos) {
        if (pos >= this.length) {
          throw this.raise(Errors.UnterminatedRegExp, {
            at: createPositionWithColumnOffset(startLoc, 1)
          });
        }

        var ch = this.input.charCodeAt(pos);

        if (isNewLine(ch)) {
          throw this.raise(Errors.UnterminatedRegExp, {
            at: createPositionWithColumnOffset(startLoc, 1)
          });
        }

        if (escaped) {
          escaped = false;
        } else {
          if (ch === 91) {
            inClass = true;
          } else if (ch === 93 && inClass) {
            inClass = false;
          } else if (ch === 47 && !inClass) {
            break;
          }

          escaped = ch === 92;
        }
      }

      var content = this.input.slice(start, pos);
      ++pos;
      var mods = "";

      var nextPos = function nextPos() {
        return createPositionWithColumnOffset(startLoc, pos + 2 - start);
      };

      while (pos < this.length) {
        var cp = this.codePointAtPos(pos);

        var _char = String.fromCharCode(cp);

        if (VALID_REGEX_FLAGS.has(cp)) {
          if (cp === 118) {
            this.expectPlugin("regexpUnicodeSets", nextPos());

            if (mods.includes("u")) {
              this.raise(Errors.IncompatibleRegExpUVFlags, {
                at: nextPos()
              });
            }
          } else if (cp === 117) {
            if (mods.includes("v")) {
              this.raise(Errors.IncompatibleRegExpUVFlags, {
                at: nextPos()
              });
            }
          }

          if (mods.includes(_char)) {
            this.raise(Errors.DuplicateRegExpFlags, {
              at: nextPos()
            });
          }
        } else if (isIdentifierChar(cp) || cp === 92) {
          this.raise(Errors.MalformedRegExpFlags, {
            at: nextPos()
          });
        } else {
          break;
        }

        ++pos;
        mods += _char;
      }

      this.state.pos = pos;
      this.finishToken(133, {
        pattern: content,
        flags: mods
      });
    }
  }, {
    key: "readInt",
    value: function readInt(radix, len) {
      var forceLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var allowNumSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      var _readInt3 = _readInt2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt),
          n = _readInt3.n,
          pos = _readInt3.pos;

      this.state.pos = pos;
      return n;
    }
  }, {
    key: "readRadixNumber",
    value: function readRadixNumber(radix) {
      var startLoc = this.state.curPosition();
      var isBigInt = false;
      this.state.pos += 2;
      var val = this.readInt(radix);

      if (val == null) {
        this.raise(Errors.InvalidDigit, {
          at: createPositionWithColumnOffset(startLoc, 2),
          radix: radix
        });
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(Errors.InvalidDecimal, {
          at: startLoc
        });
      }

      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(Errors.NumberIdentifier, {
          at: this.state.curPosition()
        });
      }

      if (isBigInt) {
        var str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(131, str);
        return;
      }

      this.finishToken(130, val);
    }
  }, {
    key: "readNumber",
    value: function readNumber(startsWithDot) {
      var start = this.state.pos;
      var startLoc = this.state.curPosition();
      var isFloat = false;
      var isBigInt = false;
      var isDecimal = false;
      var hasExponent = false;
      var isOctal = false;

      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(Errors.InvalidNumber, {
          at: this.state.curPosition()
        });
      }

      var hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

      if (hasLeadingZero) {
        var integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
          at: startLoc
        });

        if (!this.state.strict) {
          var underscorePos = integer.indexOf("_");

          if (underscorePos > 0) {
            this.raise(Errors.ZeroDigitNumericSeparator, {
              at: createPositionWithColumnOffset(startLoc, underscorePos)
            });
          }
        }

        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);

        if (next === 43 || next === 45) {
          ++this.state.pos;
        }

        if (this.readInt(10) === null) {
          this.raise(Errors.InvalidOrMissingExponent, {
            at: startLoc
          });
        }

        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(Errors.InvalidBigIntLiteral, {
            at: startLoc
          });
        }

        ++this.state.pos;
        isBigInt = true;
      }

      if (next === 109) {
        this.expectPlugin("decimal", this.state.curPosition());

        if (hasExponent || hasLeadingZero) {
          this.raise(Errors.InvalidDecimal, {
            at: startLoc
          });
        }

        ++this.state.pos;
        isDecimal = true;
      }

      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(Errors.NumberIdentifier, {
          at: this.state.curPosition()
        });
      }

      var str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");

      if (isBigInt) {
        this.finishToken(131, str);
        return;
      }

      if (isDecimal) {
        this.finishToken(132, str);
        return;
      }

      var val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(130, val);
    }
  }, {
    key: "readCodePoint",
    value: function readCodePoint(throwOnInvalid) {
      var _readCodePoint3 = _readCodePoint2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint),
          code = _readCodePoint3.code,
          pos = _readCodePoint3.pos;

      this.state.pos = pos;
      return code;
    }
  }, {
    key: "readString",
    value: function readString(quote) {
      var _readStringContents = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string),
          str = _readStringContents.str,
          pos = _readStringContents.pos,
          curLine = _readStringContents.curLine,
          lineStart = _readStringContents.lineStart;

      this.state.pos = pos + 1;
      this.state.lineStart = lineStart;
      this.state.curLine = curLine;
      this.finishToken(129, str);
    }
  }, {
    key: "readTemplateContinuation",
    value: function readTemplateContinuation() {
      if (!this.match(8)) {
        this.unexpected(null, 8);
      }

      this.state.pos--;
      this.readTemplateToken();
    }
  }, {
    key: "readTemplateToken",
    value: function readTemplateToken() {
      var opening = this.input[this.state.pos];

      var _readStringContents2 = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template),
          str = _readStringContents2.str,
          containsInvalid = _readStringContents2.containsInvalid,
          pos = _readStringContents2.pos,
          curLine = _readStringContents2.curLine,
          lineStart = _readStringContents2.lineStart;

      this.state.pos = pos + 1;
      this.state.lineStart = lineStart;
      this.state.curLine = curLine;

      if (this.input.codePointAt(pos) === 96) {
        this.finishToken(24, containsInvalid ? null : opening + str + "`");
      } else {
        this.state.pos++;
        this.finishToken(25, containsInvalid ? null : opening + str + "${");
      }
    }
  }, {
    key: "recordStrictModeErrors",
    value: function recordStrictModeErrors(toParseError, _ref47) {
      var at = _ref47.at;
      var index = at.index;

      if (this.state.strict && !this.state.strictErrors.has(index)) {
        this.raise(toParseError, {
          at: at
        });
      } else {
        this.state.strictErrors.set(index, [toParseError, at]);
      }
    }
  }, {
    key: "readWord1",
    value: function readWord1(firstCode) {
      this.state.containsEsc = false;
      var word = "";
      var start = this.state.pos;
      var chunkStart = this.state.pos;

      if (firstCode !== undefined) {
        this.state.pos += firstCode <= 0xffff ? 1 : 2;
      }

      while (this.state.pos < this.length) {
        var ch = this.codePointAtPos(this.state.pos);

        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          var escStart = this.state.curPosition();
          var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(Errors.MissingUnicodeEscape, {
              at: this.state.curPosition()
            });
            chunkStart = this.state.pos - 1;
            continue;
          }

          ++this.state.pos;
          var esc = this.readCodePoint(true);

          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(Errors.EscapedCharNotAnIdentifier, {
                at: escStart
              });
            }

            word += String.fromCodePoint(esc);
          }

          chunkStart = this.state.pos;
        } else {
          break;
        }
      }

      return word + this.input.slice(chunkStart, this.state.pos);
    }
  }, {
    key: "readWord",
    value: function readWord(firstCode) {
      var word = this.readWord1(firstCode);
      var type = keywords$1.get(word);

      if (type !== undefined) {
        this.finishToken(type, tokenLabelName(type));
      } else {
        this.finishToken(128, word);
      }
    }
  }, {
    key: "checkKeywordEscapes",
    value: function checkKeywordEscapes() {
      var type = this.state.type;

      if (tokenIsKeyword(type) && this.state.containsEsc) {
        this.raise(Errors.InvalidEscapedReservedWord, {
          at: this.state.startLoc,
          reservedWord: tokenLabelName(type)
        });
      }
    }
  }, {
    key: "raise",
    value: function raise(toParseError, raiseProperties) {
      var at = raiseProperties.at,
          details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);

      var loc = at instanceof Position ? at : at.loc.start;
      var error = toParseError({
        loc: loc,
        details: details
      });
      if (!this.options.errorRecovery) throw error;
      if (!this.isLookahead) this.state.errors.push(error);
      return error;
    }
  }, {
    key: "raiseOverwrite",
    value: function raiseOverwrite(toParseError, raiseProperties) {
      var at = raiseProperties.at,
          details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);

      var loc = at instanceof Position ? at : at.loc.start;
      var pos = loc.index;
      var errors = this.state.errors;

      for (var i = errors.length - 1; i >= 0; i--) {
        var error = errors[i];

        if (error.loc.index === pos) {
          return errors[i] = toParseError({
            loc: loc,
            details: details
          });
        }

        if (error.loc.index < pos) break;
      }

      return this.raise(toParseError, raiseProperties);
    }
  }, {
    key: "updateContext",
    value: function updateContext(prevType) {}
  }, {
    key: "unexpected",
    value: function unexpected(loc, type) {
      throw this.raise(Errors.UnexpectedToken, {
        expected: type ? tokenLabelName(type) : null,
        at: loc != null ? loc : this.state.startLoc
      });
    }
  }, {
    key: "expectPlugin",
    value: function expectPlugin(pluginName, loc) {
      if (this.hasPlugin(pluginName)) {
        return true;
      }

      throw this.raise(Errors.MissingPlugin, {
        at: loc != null ? loc : this.state.startLoc,
        missingPlugin: [pluginName]
      });
    }
  }, {
    key: "expectOnePlugin",
    value: function expectOnePlugin(pluginNames) {
      var _this6 = this;

      if (!pluginNames.some(function (name) {
        return _this6.hasPlugin(name);
      })) {
        throw this.raise(Errors.MissingOneOfPlugins, {
          at: this.state.startLoc,
          missingPlugin: pluginNames
        });
      }
    }
  }, {
    key: "errorBuilder",
    value: function errorBuilder(error) {
      var _this7 = this;

      return function (pos, lineStart, curLine) {
        _this7.raise(error, {
          at: buildPosition(pos, lineStart, curLine)
        });
      };
    }
  }]);

  return Tokenizer;
}(CommentsParser);

var ClassScope = function ClassScope() {
  _classCallCheck(this, ClassScope);

  this.privateNames = new Set();
  this.loneAccessors = new Map();
  this.undefinedPrivateNames = new Map();
};

var ClassScopeHandler =
/*#__PURE__*/
function () {
  function ClassScopeHandler(parser) {
    _classCallCheck(this, ClassScopeHandler);

    this.parser = void 0;
    this.stack = [];
    this.undefinedPrivateNames = new Map();
    this.parser = parser;
  }

  _createClass(ClassScopeHandler, [{
    key: "current",
    value: function current() {
      return this.stack[this.stack.length - 1];
    }
  }, {
    key: "enter",
    value: function enter() {
      this.stack.push(new ClassScope());
    }
  }, {
    key: "exit",
    value: function exit() {
      var oldClassScope = this.stack.pop();
      var current = this.current();

      for (var _i4 = 0, _Array$from = Array.from(oldClassScope.undefinedPrivateNames); _i4 < _Array$from.length; _i4++) {
        var _Array$from$_i = _slicedToArray(_Array$from[_i4], 2),
            name = _Array$from$_i[0],
            loc = _Array$from$_i[1];

        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, loc);
          }
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, {
            at: loc,
            identifierName: name
          });
        }
      }
    }
  }, {
    key: "declarePrivateName",
    value: function declarePrivateName(name, elementType, loc) {
      var _this$current = this.current(),
          privateNames = _this$current.privateNames,
          loneAccessors = _this$current.loneAccessors,
          undefinedPrivateNames = _this$current.undefinedPrivateNames;

      var redefined = privateNames.has(name);

      if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
        var accessor = redefined && loneAccessors.get(name);

        if (accessor) {
          var oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
          var newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
          var oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
          var newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined) loneAccessors["delete"](name);
        } else if (!redefined) {
          loneAccessors.set(name, elementType);
        }
      }

      if (redefined) {
        this.parser.raise(Errors.PrivateNameRedeclaration, {
          at: loc,
          identifierName: name
        });
      }

      privateNames.add(name);
      undefinedPrivateNames["delete"](name);
    }
  }, {
    key: "usePrivateName",
    value: function usePrivateName(name, loc) {
      var classScope;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.stack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          classScope = _step.value;
          if (classScope.privateNames.has(name)) return;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (classScope) {
        classScope.undefinedPrivateNames.set(name, loc);
      } else {
        this.parser.raise(Errors.InvalidPrivateFieldResolution, {
          at: loc,
          identifierName: name
        });
      }
    }
  }]);

  return ClassScopeHandler;
}();

var kExpression = 0,
    kMaybeArrowParameterDeclaration = 1,
    kMaybeAsyncArrowParameterDeclaration = 2,
    kParameterDeclaration = 3;

var ExpressionScope =
/*#__PURE__*/
function () {
  function ExpressionScope() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : kExpression;

    _classCallCheck(this, ExpressionScope);

    this.type = void 0;
    this.type = type;
  }

  _createClass(ExpressionScope, [{
    key: "canBeArrowParameterDeclaration",
    value: function canBeArrowParameterDeclaration() {
      return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
    }
  }, {
    key: "isCertainlyParameterDeclaration",
    value: function isCertainlyParameterDeclaration() {
      return this.type === kParameterDeclaration;
    }
  }]);

  return ExpressionScope;
}();

var ArrowHeadParsingScope =
/*#__PURE__*/
function (_ExpressionScope) {
  _inherits(ArrowHeadParsingScope, _ExpressionScope);

  function ArrowHeadParsingScope(type) {
    var _this8;

    _classCallCheck(this, ArrowHeadParsingScope);

    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(ArrowHeadParsingScope).call(this, type));
    _this8.declarationErrors = new Map();
    return _this8;
  }

  _createClass(ArrowHeadParsingScope, [{
    key: "recordDeclarationError",
    value: function recordDeclarationError(ParsingErrorClass, _ref48) {
      var at = _ref48.at;
      var index = at.index;
      this.declarationErrors.set(index, [ParsingErrorClass, at]);
    }
  }, {
    key: "clearDeclarationError",
    value: function clearDeclarationError(index) {
      this.declarationErrors["delete"](index);
    }
  }, {
    key: "iterateErrors",
    value: function iterateErrors(iterator) {
      this.declarationErrors.forEach(iterator);
    }
  }]);

  return ArrowHeadParsingScope;
}(ExpressionScope);

var ExpressionScopeHandler =
/*#__PURE__*/
function () {
  function ExpressionScopeHandler(parser) {
    _classCallCheck(this, ExpressionScopeHandler);

    this.parser = void 0;
    this.stack = [new ExpressionScope()];
    this.parser = parser;
  }

  _createClass(ExpressionScopeHandler, [{
    key: "enter",
    value: function enter(scope) {
      this.stack.push(scope);
    }
  }, {
    key: "exit",
    value: function exit() {
      this.stack.pop();
    }
  }, {
    key: "recordParameterInitializerError",
    value: function recordParameterInitializerError(toParseError, _ref49) {
      var node = _ref49.at;
      var origin = {
        at: node.loc.start
      };
      var stack = this.stack;
      var i = stack.length - 1;
      var scope = stack[i];

      while (!scope.isCertainlyParameterDeclaration()) {
        if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(toParseError, origin);
        } else {
          return;
        }

        scope = stack[--i];
      }

      this.parser.raise(toParseError, origin);
    }
  }, {
    key: "recordArrowParemeterBindingError",
    value: function recordArrowParemeterBindingError(error, _ref50) {
      var node = _ref50.at;
      var stack = this.stack;
      var scope = stack[stack.length - 1];
      var origin = {
        at: node.loc.start
      };

      if (scope.isCertainlyParameterDeclaration()) {
        this.parser.raise(error, origin);
      } else if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(error, origin);
      } else {
        return;
      }
    }
  }, {
    key: "recordAsyncArrowParametersError",
    value: function recordAsyncArrowParametersError(_ref51) {
      var at = _ref51.at;
      var stack = this.stack;
      var i = stack.length - 1;
      var scope = stack[i];

      while (scope.canBeArrowParameterDeclaration()) {
        if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
          scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
            at: at
          });
        }

        scope = stack[--i];
      }
    }
  }, {
    key: "validateAsPattern",
    value: function validateAsPattern() {
      var _this9 = this;

      var stack = this.stack;
      var currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration()) return;
      currentScope.iterateErrors(function (_ref52) {
        var _ref53 = _slicedToArray(_ref52, 2),
            toParseError = _ref53[0],
            loc = _ref53[1];

        _this9.parser.raise(toParseError, {
          at: loc
        });

        var i = stack.length - 2;
        var scope = stack[i];

        while (scope.canBeArrowParameterDeclaration()) {
          scope.clearDeclarationError(loc.index);
          scope = stack[--i];
        }
      });
    }
  }]);

  return ExpressionScopeHandler;
}();

function newParameterDeclarationScope() {
  return new ExpressionScope(kParameterDeclaration);
}

function newArrowHeadScope() {
  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
}

function newAsyncArrowScope() {
  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
}

function newExpressionScope() {
  return new ExpressionScope();
}

var PARAM = 0,
    PARAM_YIELD = 1,
    PARAM_AWAIT = 2,
    PARAM_RETURN = 4,
    PARAM_IN = 8;

var ProductionParameterHandler =
/*#__PURE__*/
function () {
  function ProductionParameterHandler() {
    _classCallCheck(this, ProductionParameterHandler);

    this.stacks = [];
  }

  _createClass(ProductionParameterHandler, [{
    key: "enter",
    value: function enter(flags) {
      this.stacks.push(flags);
    }
  }, {
    key: "exit",
    value: function exit() {
      this.stacks.pop();
    }
  }, {
    key: "currentFlags",
    value: function currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
  }, {
    key: "hasAwait",
    get: function get() {
      return (this.currentFlags() & PARAM_AWAIT) > 0;
    }
  }, {
    key: "hasYield",
    get: function get() {
      return (this.currentFlags() & PARAM_YIELD) > 0;
    }
  }, {
    key: "hasReturn",
    get: function get() {
      return (this.currentFlags() & PARAM_RETURN) > 0;
    }
  }, {
    key: "hasIn",
    get: function get() {
      return (this.currentFlags() & PARAM_IN) > 0;
    }
  }]);

  return ProductionParameterHandler;
}();

function functionFlags(isAsync, isGenerator) {
  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
}

var UtilParser =
/*#__PURE__*/
function (_Tokenizer) {
  _inherits(UtilParser, _Tokenizer);

  function UtilParser() {
    _classCallCheck(this, UtilParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(UtilParser).apply(this, arguments));
  }

  _createClass(UtilParser, [{
    key: "addExtra",
    value: function addExtra(node, key, value) {
      var enumerable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      if (!node) return;
      var extra = node.extra = node.extra || {};

      if (enumerable) {
        extra[key] = value;
      } else {
        Object.defineProperty(extra, key, {
          enumerable: enumerable,
          value: value
        });
      }
    }
  }, {
    key: "isContextual",
    value: function isContextual(token) {
      return this.state.type === token && !this.state.containsEsc;
    }
  }, {
    key: "isUnparsedContextual",
    value: function isUnparsedContextual(nameStart, name) {
      var nameEnd = nameStart + name.length;

      if (this.input.slice(nameStart, nameEnd) === name) {
        var nextCh = this.input.charCodeAt(nameEnd);
        return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);
      }

      return false;
    }
  }, {
    key: "isLookaheadContextual",
    value: function isLookaheadContextual(name) {
      var next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
  }, {
    key: "eatContextual",
    value: function eatContextual(token) {
      if (this.isContextual(token)) {
        this.next();
        return true;
      }

      return false;
    }
  }, {
    key: "expectContextual",
    value: function expectContextual(token, toParseError) {
      if (!this.eatContextual(token)) {
        if (toParseError != null) {
          throw this.raise(toParseError, {
            at: this.state.startLoc
          });
        }

        throw this.unexpected(null, token);
      }
    }
  }, {
    key: "canInsertSemicolon",
    value: function canInsertSemicolon() {
      return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
    }
  }, {
    key: "hasPrecedingLineBreak",
    value: function hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
  }, {
    key: "hasFollowingLineBreak",
    value: function hasFollowingLineBreak() {
      skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
      return skipWhiteSpaceToLineBreak.test(this.input);
    }
  }, {
    key: "isLineTerminator",
    value: function isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
  }, {
    key: "semicolon",
    value: function semicolon() {
      var allowAsi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
      this.raise(Errors.MissingSemicolon, {
        at: this.state.lastTokEndLoc
      });
    }
  }, {
    key: "expect",
    value: function expect(type, loc) {
      this.eat(type) || this.unexpected(loc, type);
    }
  }, {
    key: "tryParse",
    value: function tryParse(fn) {
      var oldState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.clone();
      var abortSignal = {
        node: null
      };

      try {
        var node = fn(function () {
          var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          var failState = this.state;
          this.state = oldState;
          this.state.tokensLength = failState.tokensLength;
          return {
            node: node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState: failState
          };
        }

        return {
          node: node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        var _failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error: error,
            thrown: true,
            aborted: false,
            failState: _failState
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: _failState
          };
        }

        throw error;
      }
    }
  }, {
    key: "checkExpressionErrors",
    value: function checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      var shorthandAssignLoc = refExpressionErrors.shorthandAssignLoc,
          doubleProtoLoc = refExpressionErrors.doubleProtoLoc,
          privateKeyLoc = refExpressionErrors.privateKeyLoc,
          optionalParametersLoc = refExpressionErrors.optionalParametersLoc;
      var hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;

      if (!andThrow) {
        return hasErrors;
      }

      if (shorthandAssignLoc != null) {
        this.raise(Errors.InvalidCoverInitializedName, {
          at: shorthandAssignLoc
        });
      }

      if (doubleProtoLoc != null) {
        this.raise(Errors.DuplicateProto, {
          at: doubleProtoLoc
        });
      }

      if (privateKeyLoc != null) {
        this.raise(Errors.UnexpectedPrivateField, {
          at: privateKeyLoc
        });
      }

      if (optionalParametersLoc != null) {
        this.unexpected(optionalParametersLoc);
      }
    }
  }, {
    key: "isLiteralPropertyName",
    value: function isLiteralPropertyName() {
      return tokenIsLiteralPropertyName(this.state.type);
    }
  }, {
    key: "isPrivateName",
    value: function isPrivateName(node) {
      return node.type === "PrivateName";
    }
  }, {
    key: "getPrivateNameSV",
    value: function getPrivateNameSV(node) {
      return node.id.name;
    }
  }, {
    key: "hasPropertyAsPrivateName",
    value: function hasPropertyAsPrivateName(node) {
      return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    }
  }, {
    key: "isOptionalChain",
    value: function isOptionalChain(node) {
      return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
    }
  }, {
    key: "isObjectProperty",
    value: function isObjectProperty(node) {
      return node.type === "ObjectProperty";
    }
  }, {
    key: "isObjectMethod",
    value: function isObjectMethod(node) {
      return node.type === "ObjectMethod";
    }
  }, {
    key: "initializeScopes",
    value: function initializeScopes() {
      var _this10 = this;

      var inModule = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.sourceType === "module";
      var oldLabels = this.state.labels;
      this.state.labels = [];
      var oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set();
      var oldInModule = this.inModule;
      this.inModule = inModule;
      var oldScope = this.scope;
      var ScopeHandler = this.getScopeHandler();
      this.scope = new ScopeHandler(this, inModule);
      var oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler();
      var oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this);
      var oldExpressionScope = this.expressionScope;
      this.expressionScope = new ExpressionScopeHandler(this);
      return function () {
        _this10.state.labels = oldLabels;
        _this10.exportedIdentifiers = oldExportedIdentifiers;
        _this10.inModule = oldInModule;
        _this10.scope = oldScope;
        _this10.prodParam = oldProdParam;
        _this10.classScope = oldClassScope;
        _this10.expressionScope = oldExpressionScope;
      };
    }
  }, {
    key: "enterInitialScopes",
    value: function enterInitialScopes() {
      var paramFlags = PARAM;

      if (this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
    }
  }, {
    key: "checkDestructuringPrivate",
    value: function checkDestructuringPrivate(refExpressionErrors) {
      var privateKeyLoc = refExpressionErrors.privateKeyLoc;

      if (privateKeyLoc !== null) {
        this.expectPlugin("destructuringPrivate", privateKeyLoc);
      }
    }
  }]);

  return UtilParser;
}(Tokenizer);

var ExpressionErrors = function ExpressionErrors() {
  _classCallCheck(this, ExpressionErrors);

  this.shorthandAssignLoc = null;
  this.doubleProtoLoc = null;
  this.privateKeyLoc = null;
  this.optionalParametersLoc = null;
};

var Node = function Node(parser, pos, loc) {
  _classCallCheck(this, Node);

  this.type = "";
  this.start = pos;
  this.end = 0;
  this.loc = new SourceLocation(loc);
  if (parser != null && parser.options.ranges) this.range = [pos, 0];
  if (parser != null && parser.filename) this.loc.filename = parser.filename;
};

var NodePrototype = Node.prototype;
{
  NodePrototype.__clone = function () {
    var newNode = new Node(undefined, this.start, this.loc.start);
    var keys = Object.keys(this);

    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];

      if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
        newNode[key] = this[key];
      }
    }

    return newNode;
  };
}

function clonePlaceholder(node) {
  return cloneIdentifier(node);
}

function cloneIdentifier(node) {
  var type = node.type,
      start = node.start,
      end = node.end,
      loc = node.loc,
      range = node.range,
      extra = node.extra,
      name = node.name;
  var cloned = Object.create(NodePrototype);
  cloned.type = type;
  cloned.start = start;
  cloned.end = end;
  cloned.loc = loc;
  cloned.range = range;
  cloned.extra = extra;
  cloned.name = name;

  if (type === "Placeholder") {
    cloned.expectedNode = node.expectedNode;
  }

  return cloned;
}

function cloneStringLiteral(node) {
  var type = node.type,
      start = node.start,
      end = node.end,
      loc = node.loc,
      range = node.range,
      extra = node.extra;

  if (type === "Placeholder") {
    return clonePlaceholder(node);
  }

  var cloned = Object.create(NodePrototype);
  cloned.type = type;
  cloned.start = start;
  cloned.end = end;
  cloned.loc = loc;
  cloned.range = range;

  if (node.raw !== undefined) {
    cloned.raw = node.raw;
  } else {
    cloned.extra = extra;
  }

  cloned.value = node.value;
  return cloned;
}

var NodeUtils =
/*#__PURE__*/
function (_UtilParser) {
  _inherits(NodeUtils, _UtilParser);

  function NodeUtils() {
    _classCallCheck(this, NodeUtils);

    return _possibleConstructorReturn(this, _getPrototypeOf(NodeUtils).apply(this, arguments));
  }

  _createClass(NodeUtils, [{
    key: "startNode",
    value: function startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    }
  }, {
    key: "startNodeAt",
    value: function startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    }
  }, {
    key: "startNodeAtNode",
    value: function startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    }
  }, {
    key: "finishNode",
    value: function finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
    }
  }, {
    key: "finishNodeAt",
    value: function finishNodeAt(node, type, endLoc) {
      node.type = type;
      node.end = endLoc.index;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = endLoc.index;
      if (this.options.attachComment) this.processComment(node);
      return node;
    }
  }, {
    key: "resetStartLocation",
    value: function resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges) node.range[0] = start;
    }
  }, {
    key: "resetEndLocation",
    value: function resetEndLocation(node) {
      var endLoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastTokEndLoc;
      node.end = endLoc.index;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = endLoc.index;
    }
  }, {
    key: "resetStartLocationFromNode",
    value: function resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    }
  }]);

  return NodeUtils;
}(UtilParser);

var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
var FlowErrors = ParseErrorEnum(_templateObject2())({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
  AssignReservedType: function AssignReservedType(_ref54) {
    var reservedType = _ref54.reservedType;
    return "Cannot overwrite reserved type ".concat(reservedType, ".");
  },
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
  EnumBooleanMemberNotInitialized: function EnumBooleanMemberNotInitialized(_ref55) {
    var memberName = _ref55.memberName,
        enumName = _ref55.enumName;
    return "Boolean enum members need to be initialized. Use either `".concat(memberName, " = true,` or `").concat(memberName, " = false,` in enum `").concat(enumName, "`.");
  },
  EnumDuplicateMemberName: function EnumDuplicateMemberName(_ref56) {
    var memberName = _ref56.memberName,
        enumName = _ref56.enumName;
    return "Enum member names need to be unique, but the name `".concat(memberName, "` has already been used before in enum `").concat(enumName, "`.");
  },
  EnumInconsistentMemberValues: function EnumInconsistentMemberValues(_ref57) {
    var enumName = _ref57.enumName;
    return "Enum `".concat(enumName, "` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.");
  },
  EnumInvalidExplicitType: function EnumInvalidExplicitType(_ref58) {
    var invalidEnumType = _ref58.invalidEnumType,
        enumName = _ref58.enumName;
    return "Enum type `".concat(invalidEnumType, "` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `").concat(enumName, "`.");
  },
  EnumInvalidExplicitTypeUnknownSupplied: function EnumInvalidExplicitTypeUnknownSupplied(_ref59) {
    var enumName = _ref59.enumName;
    return "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `".concat(enumName, "`.");
  },
  EnumInvalidMemberInitializerPrimaryType: function EnumInvalidMemberInitializerPrimaryType(_ref60) {
    var enumName = _ref60.enumName,
        memberName = _ref60.memberName,
        explicitType = _ref60.explicitType;
    return "Enum `".concat(enumName, "` has type `").concat(explicitType, "`, so the initializer of `").concat(memberName, "` needs to be a ").concat(explicitType, " literal.");
  },
  EnumInvalidMemberInitializerSymbolType: function EnumInvalidMemberInitializerSymbolType(_ref61) {
    var enumName = _ref61.enumName,
        memberName = _ref61.memberName;
    return "Symbol enum members cannot be initialized. Use `".concat(memberName, ",` in enum `").concat(enumName, "`.");
  },
  EnumInvalidMemberInitializerUnknownType: function EnumInvalidMemberInitializerUnknownType(_ref62) {
    var enumName = _ref62.enumName,
        memberName = _ref62.memberName;
    return "The enum member initializer for `".concat(memberName, "` needs to be a literal (either a boolean, number, or string) in enum `").concat(enumName, "`.");
  },
  EnumInvalidMemberName: function EnumInvalidMemberName(_ref63) {
    var enumName = _ref63.enumName,
        memberName = _ref63.memberName,
        suggestion = _ref63.suggestion;
    return "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `".concat(memberName, "`, consider using `").concat(suggestion, "`, in enum `").concat(enumName, "`.");
  },
  EnumNumberMemberNotInitialized: function EnumNumberMemberNotInitialized(_ref64) {
    var enumName = _ref64.enumName,
        memberName = _ref64.memberName;
    return "Number enum members need to be initialized, e.g. `".concat(memberName, " = 1` in enum `").concat(enumName, "`.");
  },
  EnumStringMemberInconsistentlyInitailized: function EnumStringMemberInconsistentlyInitailized(_ref65) {
    var enumName = _ref65.enumName;
    return "String enum members need to consistently either all use initializers, or use no initializers, in enum `".concat(enumName, "`.");
  },
  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
  InexactVariance: "Explicit inexact syntax cannot have variance.",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
  PatternIsOptional: Object.assign({
    message: "A binding pattern parameter cannot be optional in an implementation signature."
  }, {
    reasonCode: "OptionalBindingPattern"
  }),
  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
  SpreadVariance: "Spread properties cannot have variance.",
  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
  ThisParamNoDefault: "The `this` parameter may not have a default value.",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
  UnexpectedReservedType: function UnexpectedReservedType(_ref66) {
    var reservedType = _ref66.reservedType;
    return "Unexpected reserved type ".concat(reservedType, ".");
  },
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
  UnsupportedDeclareExportKind: function UnsupportedDeclareExportKind(_ref67) {
    var unsupportedExportKind = _ref67.unsupportedExportKind,
        suggestion = _ref67.suggestion;
    return "`declare export ".concat(unsupportedExportKind, "` is not supported. Use `").concat(suggestion, "` instead.");
  },
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
  UnterminatedFlowComment: "Unterminated flow-comment."
});

function isEsModuleType(bodyElement) {
  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
}

function hasTypeImportKind(node) {
  return node.importKind === "type" || node.importKind === "typeof";
}

function isMaybeDefaultImport(type) {
  return tokenIsKeywordOrIdentifier(type) && type !== 97;
}

var exportSuggestions = {
  "const": "declare export var",
  "let": "declare export var",
  type: "export type",
  "interface": "export interface"
};

function partition(list, test) {
  var list1 = [];
  var list2 = [];

  for (var i = 0; i < list.length; i++) {
    (test(list[i], i, list) ? list1 : list2).push(list[i]);
  }

  return [list1, list2];
}

var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;

var flow = function flow(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass2) {
      _inherits(FlowParserMixin, _superClass2);

      function FlowParserMixin() {
        var _getPrototypeOf3;

        var _this11;

        _classCallCheck(this, FlowParserMixin);

        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        _this11 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(FlowParserMixin)).call.apply(_getPrototypeOf3, [this].concat(args)));
        _this11.flowPragma = undefined;
        return _this11;
      }

      _createClass(FlowParserMixin, [{
        key: "getScopeHandler",
        value: function getScopeHandler() {
          return FlowScopeHandler;
        }
      }, {
        key: "shouldParseTypes",
        value: function shouldParseTypes() {
          return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
      }, {
        key: "shouldParseEnums",
        value: function shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
        }
      }, {
        key: "finishToken",
        value: function finishToken(type, val) {
          if (type !== 129 && type !== 13 && type !== 28) {
            if (this.flowPragma === undefined) {
              this.flowPragma = null;
            }
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "finishToken", this).call(this, type, val);
        }
      }, {
        key: "addComment",
        value: function addComment(comment) {
          if (this.flowPragma === undefined) {
            var matches = FLOW_PRAGMA_REGEX.exec(comment.value);
            if (!matches) ;else if (matches[1] === "flow") {
              this.flowPragma = "flow";
            } else if (matches[1] === "noflow") {
              this.flowPragma = "noflow";
            } else {
              throw new Error("Unexpected flow pragma");
            }
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "addComment", this).call(this, comment);
        }
      }, {
        key: "flowParseTypeInitialiser",
        value: function flowParseTypeInitialiser(tok) {
          var oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(tok || 14);
          var type = this.flowParseType();
          this.state.inType = oldInType;
          return type;
        }
      }, {
        key: "flowParsePredicate",
        value: function flowParsePredicate() {
          var node = this.startNode();
          var moduloLoc = this.state.startLoc;
          this.next();
          this.expectContextual(107);

          if (this.state.lastTokStart > moduloLoc.index + 1) {
            this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
              at: moduloLoc
            });
          }

          if (this.eat(10)) {
            node.value = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseExpression", this).call(this);
            this.expect(11);
            return this.finishNode(node, "DeclaredPredicate");
          } else {
            return this.finishNode(node, "InferredPredicate");
          }
        }
      }, {
        key: "flowParseTypeAndPredicateInitialiser",
        value: function flowParseTypeAndPredicateInitialiser() {
          var oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(14);
          var type = null;
          var predicate = null;

          if (this.match(54)) {
            this.state.inType = oldInType;
            predicate = this.flowParsePredicate();
          } else {
            type = this.flowParseType();
            this.state.inType = oldInType;

            if (this.match(54)) {
              predicate = this.flowParsePredicate();
            }
          }

          return [type, predicate];
        }
      }, {
        key: "flowParseDeclareClass",
        value: function flowParseDeclareClass(node) {
          this.next();
          this.flowParseInterfaceish(node, true);
          return this.finishNode(node, "DeclareClass");
        }
      }, {
        key: "flowParseDeclareFunction",
        value: function flowParseDeclareFunction(node) {
          this.next();
          var id = node.id = this.parseIdentifier();
          var typeNode = this.startNode();
          var typeContainer = this.startNode();

          if (this.match(47)) {
            typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            typeNode.typeParameters = null;
          }

          this.expect(10);
          var tmp = this.flowParseFunctionTypeParams();
          typeNode.params = tmp.params;
          typeNode.rest = tmp.rest;
          typeNode["this"] = tmp._this;
          this.expect(11);

          var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();

          var _this$flowParseTypeAn2 = _slicedToArray(_this$flowParseTypeAn, 2);

          typeNode.returnType = _this$flowParseTypeAn2[0];
          node.predicate = _this$flowParseTypeAn2[1];
          typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
          id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
          this.resetEndLocation(id);
          this.semicolon();
          this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);
          return this.finishNode(node, "DeclareFunction");
        }
      }, {
        key: "flowParseDeclare",
        value: function flowParseDeclare(node, insideModule) {
          if (this.match(80)) {
            return this.flowParseDeclareClass(node);
          } else if (this.match(68)) {
            return this.flowParseDeclareFunction(node);
          } else if (this.match(74)) {
            return this.flowParseDeclareVariable(node);
          } else if (this.eatContextual(123)) {
            if (this.match(16)) {
              return this.flowParseDeclareModuleExports(node);
            } else {
              if (insideModule) {
                this.raise(FlowErrors.NestedDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }

              return this.flowParseDeclareModule(node);
            }
          } else if (this.isContextual(126)) {
            return this.flowParseDeclareTypeAlias(node);
          } else if (this.isContextual(127)) {
            return this.flowParseDeclareOpaqueType(node);
          } else if (this.isContextual(125)) {
            return this.flowParseDeclareInterface(node);
          } else if (this.match(82)) {
            return this.flowParseDeclareExportDeclaration(node, insideModule);
          } else {
            throw this.unexpected();
          }
        }
      }, {
        key: "flowParseDeclareVariable",
        value: function flowParseDeclareVariable(node) {
          this.next();
          node.id = this.flowParseTypeAnnotatableIdentifier(true);
          this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
          this.semicolon();
          return this.finishNode(node, "DeclareVariable");
        }
      }, {
        key: "flowParseDeclareModule",
        value: function flowParseDeclareModule(node) {
          var _this12 = this;

          this.scope.enter(SCOPE_OTHER);

          if (this.match(129)) {
            node.id = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseExprAtom", this).call(this);
          } else {
            node.id = this.parseIdentifier();
          }

          var bodyNode = node.body = this.startNode();
          var body = bodyNode.body = [];
          this.expect(5);

          while (!this.match(8)) {
            var _bodyNode = this.startNode();

            if (this.match(83)) {
              this.next();

              if (!this.isContextual(126) && !this.match(87)) {
                this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }

              _get(_getPrototypeOf(FlowParserMixin.prototype), "parseImport", this).call(this, _bodyNode);
            } else {
              this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule);
              _bodyNode = this.flowParseDeclare(_bodyNode, true);
            }

            body.push(_bodyNode);
          }

          this.scope.exit();
          this.expect(8);
          this.finishNode(bodyNode, "BlockStatement");
          var kind = null;
          var hasModuleExport = false;
          body.forEach(function (bodyElement) {
            if (isEsModuleType(bodyElement)) {
              if (kind === "CommonJS") {
                _this12.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }

              kind = "ES";
            } else if (bodyElement.type === "DeclareModuleExports") {
              if (hasModuleExport) {
                _this12.raise(FlowErrors.DuplicateDeclareModuleExports, {
                  at: bodyElement
                });
              }

              if (kind === "ES") {
                _this12.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }

              kind = "CommonJS";
              hasModuleExport = true;
            }
          });
          node.kind = kind || "CommonJS";
          return this.finishNode(node, "DeclareModule");
        }
      }, {
        key: "flowParseDeclareExportDeclaration",
        value: function flowParseDeclareExportDeclaration(node, insideModule) {
          this.expect(82);

          if (this.eat(65)) {
            if (this.match(68) || this.match(80)) {
              node.declaration = this.flowParseDeclare(this.startNode());
            } else {
              node.declaration = this.flowParseType();
              this.semicolon();
            }

            node["default"] = true;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else {
            if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !insideModule) {
              var label = this.state.value;
              throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: label,
                suggestion: exportSuggestions[label]
              });
            }

            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node["default"] = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127)) {
              node = this.parseExport(node);

              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node["default"] = false;
                delete node.exportKind;
              }

              node.type = "Declare" + node.type;
              return node;
            }
          }

          throw this.unexpected();
        }
      }, {
        key: "flowParseDeclareModuleExports",
        value: function flowParseDeclareModuleExports(node) {
          this.next();
          this.expectContextual(108);
          node.typeAnnotation = this.flowParseTypeAnnotation();
          this.semicolon();
          return this.finishNode(node, "DeclareModuleExports");
        }
      }, {
        key: "flowParseDeclareTypeAlias",
        value: function flowParseDeclareTypeAlias(node) {
          this.next();
          var finished = this.flowParseTypeAlias(node);
          finished.type = "DeclareTypeAlias";
          return finished;
        }
      }, {
        key: "flowParseDeclareOpaqueType",
        value: function flowParseDeclareOpaqueType(node) {
          this.next();
          var finished = this.flowParseOpaqueType(node, true);
          finished.type = "DeclareOpaqueType";
          return finished;
        }
      }, {
        key: "flowParseDeclareInterface",
        value: function flowParseDeclareInterface(node) {
          this.next();
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "DeclareInterface");
        }
      }, {
        key: "flowParseInterfaceish",
        value: function flowParseInterfaceish(node) {
          var isClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          node.id = this.flowParseRestrictedIdentifier(!isClass, true);
          this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);

          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node["extends"] = [];
          node["implements"] = [];
          node.mixins = [];

          if (this.eat(81)) {
            do {
              node["extends"].push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(12));
          }

          if (this.isContextual(114)) {
            this.next();

            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }

          if (this.isContextual(110)) {
            this.next();

            do {
              node["implements"].push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }

          node.body = this.flowParseObjectType({
            allowStatic: isClass,
            allowExact: false,
            allowSpread: false,
            allowProto: isClass,
            allowInexact: false
          });
        }
      }, {
        key: "flowParseInterfaceExtends",
        value: function flowParseInterfaceExtends() {
          var node = this.startNode();
          node.id = this.flowParseQualifiedTypeIdentifier();

          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }

          return this.finishNode(node, "InterfaceExtends");
        }
      }, {
        key: "flowParseInterface",
        value: function flowParseInterface(node) {
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "InterfaceDeclaration");
        }
      }, {
        key: "checkNotUnderscore",
        value: function checkNotUnderscore(word) {
          if (word === "_") {
            this.raise(FlowErrors.UnexpectedReservedUnderscore, {
              at: this.state.startLoc
            });
          }
        }
      }, {
        key: "checkReservedType",
        value: function checkReservedType(word, startLoc, declaration) {
          if (!reservedTypes.has(word)) return;
          this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
            at: startLoc,
            reservedType: word
          });
        }
      }, {
        key: "flowParseRestrictedIdentifier",
        value: function flowParseRestrictedIdentifier(liberal, declaration) {
          this.checkReservedType(this.state.value, this.state.startLoc, declaration);
          return this.parseIdentifier(liberal);
        }
      }, {
        key: "flowParseTypeAlias",
        value: function flowParseTypeAlias(node) {
          node.id = this.flowParseRestrictedIdentifier(false, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);

          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node.right = this.flowParseTypeInitialiser(29);
          this.semicolon();
          return this.finishNode(node, "TypeAlias");
        }
      }, {
        key: "flowParseOpaqueType",
        value: function flowParseOpaqueType(node, declare) {
          this.expectContextual(126);
          node.id = this.flowParseRestrictedIdentifier(true, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);

          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node.supertype = null;

          if (this.match(14)) {
            node.supertype = this.flowParseTypeInitialiser(14);
          }

          node.impltype = null;

          if (!declare) {
            node.impltype = this.flowParseTypeInitialiser(29);
          }

          this.semicolon();
          return this.finishNode(node, "OpaqueType");
        }
      }, {
        key: "flowParseTypeParameter",
        value: function flowParseTypeParameter() {
          var requireDefault = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var nodeStartLoc = this.state.startLoc;
          var node = this.startNode();
          var variance = this.flowParseVariance();
          var ident = this.flowParseTypeAnnotatableIdentifier();
          node.name = ident.name;
          node.variance = variance;
          node.bound = ident.typeAnnotation;

          if (this.match(29)) {
            this.eat(29);
            node["default"] = this.flowParseType();
          } else {
            if (requireDefault) {
              this.raise(FlowErrors.MissingTypeParamDefault, {
                at: nodeStartLoc
              });
            }
          }

          return this.finishNode(node, "TypeParameter");
        }
      }, {
        key: "flowParseTypeParameterDeclaration",
        value: function flowParseTypeParameterDeclaration() {
          var oldInType = this.state.inType;
          var node = this.startNode();
          node.params = [];
          this.state.inType = true;

          if (this.match(47) || this.match(138)) {
            this.next();
          } else {
            this.unexpected();
          }

          var defaultRequired = false;

          do {
            var typeParameter = this.flowParseTypeParameter(defaultRequired);
            node.params.push(typeParameter);

            if (typeParameter["default"]) {
              defaultRequired = true;
            }

            if (!this.match(48)) {
              this.expect(12);
            }
          } while (!this.match(48));

          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterDeclaration");
        }
      }, {
        key: "flowParseTypeParameterInstantiation",
        value: function flowParseTypeParameterInstantiation() {
          var node = this.startNode();
          var oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;

          while (!this.match(48)) {
            node.params.push(this.flowParseType());

            if (!this.match(48)) {
              this.expect(12);
            }
          }

          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
      }, {
        key: "flowParseTypeParameterInstantiationCallOrNew",
        value: function flowParseTypeParameterInstantiationCallOrNew() {
          var node = this.startNode();
          var oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);

          while (!this.match(48)) {
            node.params.push(this.flowParseTypeOrImplicitInstantiation());

            if (!this.match(48)) {
              this.expect(12);
            }
          }

          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
      }, {
        key: "flowParseInterfaceType",
        value: function flowParseInterfaceType() {
          var node = this.startNode();
          this.expectContextual(125);
          node["extends"] = [];

          if (this.eat(81)) {
            do {
              node["extends"].push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }

          node.body = this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: false,
            allowProto: false,
            allowInexact: false
          });
          return this.finishNode(node, "InterfaceTypeAnnotation");
        }
      }, {
        key: "flowParseObjectPropertyKey",
        value: function flowParseObjectPropertyKey() {
          return this.match(130) || this.match(129) ? _get(_getPrototypeOf(FlowParserMixin.prototype), "parseExprAtom", this).call(this) : this.parseIdentifier(true);
        }
      }, {
        key: "flowParseObjectTypeIndexer",
        value: function flowParseObjectTypeIndexer(node, isStatic, variance) {
          node["static"] = isStatic;

          if (this.lookahead().type === 14) {
            node.id = this.flowParseObjectPropertyKey();
            node.key = this.flowParseTypeInitialiser();
          } else {
            node.id = null;
            node.key = this.flowParseType();
          }

          this.expect(3);
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
          return this.finishNode(node, "ObjectTypeIndexer");
        }
      }, {
        key: "flowParseObjectTypeInternalSlot",
        value: function flowParseObjectTypeInternalSlot(node, isStatic) {
          node["static"] = isStatic;
          node.id = this.flowParseObjectPropertyKey();
          this.expect(3);
          this.expect(3);

          if (this.match(47) || this.match(10)) {
            node.method = true;
            node.optional = false;
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
          } else {
            node.method = false;

            if (this.eat(17)) {
              node.optional = true;
            }

            node.value = this.flowParseTypeInitialiser();
          }

          return this.finishNode(node, "ObjectTypeInternalSlot");
        }
      }, {
        key: "flowParseObjectTypeMethodish",
        value: function flowParseObjectTypeMethodish(node) {
          node.params = [];
          node.rest = null;
          node.typeParameters = null;
          node["this"] = null;

          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          this.expect(10);

          if (this.match(78)) {
            node["this"] = this.flowParseFunctionTypeParam(true);
            node["this"].name = null;

            if (!this.match(11)) {
              this.expect(12);
            }
          }

          while (!this.match(11) && !this.match(21)) {
            node.params.push(this.flowParseFunctionTypeParam(false));

            if (!this.match(11)) {
              this.expect(12);
            }
          }

          if (this.eat(21)) {
            node.rest = this.flowParseFunctionTypeParam(false);
          }

          this.expect(11);
          node.returnType = this.flowParseTypeInitialiser();
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
      }, {
        key: "flowParseObjectTypeCallProperty",
        value: function flowParseObjectTypeCallProperty(node, isStatic) {
          var valueNode = this.startNode();
          node["static"] = isStatic;
          node.value = this.flowParseObjectTypeMethodish(valueNode);
          return this.finishNode(node, "ObjectTypeCallProperty");
        }
      }, {
        key: "flowParseObjectType",
        value: function flowParseObjectType(_ref68) {
          var allowStatic = _ref68.allowStatic,
              allowExact = _ref68.allowExact,
              allowSpread = _ref68.allowSpread,
              allowProto = _ref68.allowProto,
              allowInexact = _ref68.allowInexact;
          var oldInType = this.state.inType;
          this.state.inType = true;
          var nodeStart = this.startNode();
          nodeStart.callProperties = [];
          nodeStart.properties = [];
          nodeStart.indexers = [];
          nodeStart.internalSlots = [];
          var endDelim;
          var exact;
          var inexact = false;

          if (allowExact && this.match(6)) {
            this.expect(6);
            endDelim = 9;
            exact = true;
          } else {
            this.expect(5);
            endDelim = 8;
            exact = false;
          }

          nodeStart.exact = exact;

          while (!this.match(endDelim)) {
            var isStatic = false;
            var protoStartLoc = null;
            var inexactStartLoc = null;
            var node = this.startNode();

            if (allowProto && this.isContextual(115)) {
              var lookahead = this.lookahead();

              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                protoStartLoc = this.state.startLoc;
                allowStatic = false;
              }
            }

            if (allowStatic && this.isContextual(104)) {
              var _lookahead = this.lookahead();

              if (_lookahead.type !== 14 && _lookahead.type !== 17) {
                this.next();
                isStatic = true;
              }
            }

            var variance = this.flowParseVariance();

            if (this.eat(0)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }

              if (this.eat(0)) {
                if (variance) {
                  this.unexpected(variance.loc.start);
                }

                nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
              } else {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              }
            } else if (this.match(10) || this.match(47)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }

              if (variance) {
                this.unexpected(variance.loc.start);
              }

              nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
            } else {
              var kind = "init";

              if (this.isContextual(98) || this.isContextual(103)) {
                var _lookahead2 = this.lookahead();

                if (tokenIsLiteralPropertyName(_lookahead2.type)) {
                  kind = this.state.value;
                  this.next();
                }
              }

              var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);

              if (propOrInexact === null) {
                inexact = true;
                inexactStartLoc = this.state.lastTokStartLoc;
              } else {
                nodeStart.properties.push(propOrInexact);
              }
            }

            this.flowObjectTypeSemicolon();

            if (inexactStartLoc && !this.match(8) && !this.match(9)) {
              this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
                at: inexactStartLoc
              });
            }
          }

          this.expect(endDelim);

          if (allowSpread) {
            nodeStart.inexact = inexact;
          }

          var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
          this.state.inType = oldInType;
          return out;
        }
      }, {
        key: "flowParseObjectTypeProperty",
        value: function flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
          if (this.eat(21)) {
            var isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);

            if (isInexactToken) {
              if (!allowSpread) {
                this.raise(FlowErrors.InexactInsideNonObject, {
                  at: this.state.lastTokStartLoc
                });
              } else if (!allowInexact) {
                this.raise(FlowErrors.InexactInsideExact, {
                  at: this.state.lastTokStartLoc
                });
              }

              if (variance) {
                this.raise(FlowErrors.InexactVariance, {
                  at: variance
                });
              }

              return null;
            }

            if (!allowSpread) {
              this.raise(FlowErrors.UnexpectedSpreadType, {
                at: this.state.lastTokStartLoc
              });
            }

            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }

            if (variance) {
              this.raise(FlowErrors.SpreadVariance, {
                at: variance
              });
            }

            node.argument = this.flowParseType();
            return this.finishNode(node, "ObjectTypeSpreadProperty");
          } else {
            node.key = this.flowParseObjectPropertyKey();
            node["static"] = isStatic;
            node.proto = protoStartLoc != null;
            node.kind = kind;
            var optional = false;

            if (this.match(47) || this.match(10)) {
              node.method = true;

              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }

              if (variance) {
                this.unexpected(variance.loc.start);
              }

              node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

              if (kind === "get" || kind === "set") {
                this.flowCheckGetterSetterParams(node);
              }

              if (!allowSpread && node.key.name === "constructor" && node.value["this"]) {
                this.raise(FlowErrors.ThisParamBannedInConstructor, {
                  at: node.value["this"]
                });
              }
            } else {
              if (kind !== "init") this.unexpected();
              node.method = false;

              if (this.eat(17)) {
                optional = true;
              }

              node.value = this.flowParseTypeInitialiser();
              node.variance = variance;
            }

            node.optional = optional;
            return this.finishNode(node, "ObjectTypeProperty");
          }
        }
      }, {
        key: "flowCheckGetterSetterParams",
        value: function flowCheckGetterSetterParams(property) {
          var paramCount = property.kind === "get" ? 0 : 1;
          var length = property.value.params.length + (property.value.rest ? 1 : 0);

          if (property.value["this"]) {
            this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
              at: property.value["this"]
            });
          }

          if (length !== paramCount) {
            this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: property
            });
          }

          if (property.kind === "set" && property.value.rest) {
            this.raise(Errors.BadSetterRestParameter, {
              at: property
            });
          }
        }
      }, {
        key: "flowObjectTypeSemicolon",
        value: function flowObjectTypeSemicolon() {
          if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
            this.unexpected();
          }
        }
      }, {
        key: "flowParseQualifiedTypeIdentifier",
        value: function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
          startPos = startPos || this.state.start;
          startLoc = startLoc || this.state.startLoc;
          var node = id || this.flowParseRestrictedIdentifier(true);

          while (this.eat(16)) {
            var node2 = this.startNodeAt(startPos, startLoc);
            node2.qualification = node;
            node2.id = this.flowParseRestrictedIdentifier(true);
            node = this.finishNode(node2, "QualifiedTypeIdentifier");
          }

          return node;
        }
      }, {
        key: "flowParseGenericType",
        value: function flowParseGenericType(startPos, startLoc, id) {
          var node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = null;
          node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          }

          return this.finishNode(node, "GenericTypeAnnotation");
        }
      }, {
        key: "flowParseTypeofType",
        value: function flowParseTypeofType() {
          var node = this.startNode();
          this.expect(87);
          node.argument = this.flowParsePrimaryType();
          return this.finishNode(node, "TypeofTypeAnnotation");
        }
      }, {
        key: "flowParseTupleType",
        value: function flowParseTupleType() {
          var node = this.startNode();
          node.types = [];
          this.expect(0);

          while (this.state.pos < this.length && !this.match(3)) {
            node.types.push(this.flowParseType());
            if (this.match(3)) break;
            this.expect(12);
          }

          this.expect(3);
          return this.finishNode(node, "TupleTypeAnnotation");
        }
      }, {
        key: "flowParseFunctionTypeParam",
        value: function flowParseFunctionTypeParam(first) {
          var name = null;
          var optional = false;
          var typeAnnotation = null;
          var node = this.startNode();
          var lh = this.lookahead();
          var isThis = this.state.type === 78;

          if (lh.type === 14 || lh.type === 17) {
            if (isThis && !first) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node
              });
            }

            name = this.parseIdentifier(isThis);

            if (this.eat(17)) {
              optional = true;

              if (isThis) {
                this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                  at: node
                });
              }
            }

            typeAnnotation = this.flowParseTypeInitialiser();
          } else {
            typeAnnotation = this.flowParseType();
          }

          node.name = name;
          node.optional = optional;
          node.typeAnnotation = typeAnnotation;
          return this.finishNode(node, "FunctionTypeParam");
        }
      }, {
        key: "reinterpretTypeAsFunctionTypeParam",
        value: function reinterpretTypeAsFunctionTypeParam(type) {
          var node = this.startNodeAt(type.start, type.loc.start);
          node.name = null;
          node.optional = false;
          node.typeAnnotation = type;
          return this.finishNode(node, "FunctionTypeParam");
        }
      }, {
        key: "flowParseFunctionTypeParams",
        value: function flowParseFunctionTypeParams() {
          var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var rest = null;
          var _this = null;

          if (this.match(78)) {
            _this = this.flowParseFunctionTypeParam(true);
            _this.name = null;

            if (!this.match(11)) {
              this.expect(12);
            }
          }

          while (!this.match(11) && !this.match(21)) {
            params.push(this.flowParseFunctionTypeParam(false));

            if (!this.match(11)) {
              this.expect(12);
            }
          }

          if (this.eat(21)) {
            rest = this.flowParseFunctionTypeParam(false);
          }

          return {
            params: params,
            rest: rest,
            _this: _this
          };
        }
      }, {
        key: "flowIdentToTypeAnnotation",
        value: function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
          switch (id.name) {
            case "any":
              return this.finishNode(node, "AnyTypeAnnotation");

            case "bool":
            case "boolean":
              return this.finishNode(node, "BooleanTypeAnnotation");

            case "mixed":
              return this.finishNode(node, "MixedTypeAnnotation");

            case "empty":
              return this.finishNode(node, "EmptyTypeAnnotation");

            case "number":
              return this.finishNode(node, "NumberTypeAnnotation");

            case "string":
              return this.finishNode(node, "StringTypeAnnotation");

            case "symbol":
              return this.finishNode(node, "SymbolTypeAnnotation");

            default:
              this.checkNotUnderscore(id.name);
              return this.flowParseGenericType(startPos, startLoc, id);
          }
        }
      }, {
        key: "flowParsePrimaryType",
        value: function flowParsePrimaryType() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.startNode();
          var tmp;
          var type;
          var isGroupedType = false;
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;

          switch (this.state.type) {
            case 5:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: true,
                allowProto: false,
                allowInexact: true
              });

            case 6:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: true,
                allowSpread: true,
                allowProto: false,
                allowInexact: false
              });

            case 0:
              this.state.noAnonFunctionType = false;
              type = this.flowParseTupleType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              return type;

            case 47:
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(10);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              node["this"] = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");

            case 10:
              this.next();

              if (!this.match(11) && !this.match(21)) {
                if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                  var token = this.lookahead().type;
                  isGroupedType = token !== 17 && token !== 14;
                } else {
                  isGroupedType = true;
                }
              }

              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;

                if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                  this.expect(11);
                  return type;
                } else {
                  this.eat(12);
                }
              }

              if (type) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }

              node.params = tmp.params;
              node.rest = tmp.rest;
              node["this"] = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              node.typeParameters = null;
              return this.finishNode(node, "FunctionTypeAnnotation");

            case 129:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

            case 85:
            case 86:
              node.value = this.match(85);
              this.next();
              return this.finishNode(node, "BooleanLiteralTypeAnnotation");

            case 53:
              if (this.state.value === "-") {
                this.next();

                if (this.match(130)) {
                  return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                }

                if (this.match(131)) {
                  return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                }

                throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                  at: this.state.startLoc
                });
              }

              throw this.unexpected();

            case 130:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

            case 131:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

            case 88:
              this.next();
              return this.finishNode(node, "VoidTypeAnnotation");

            case 84:
              this.next();
              return this.finishNode(node, "NullLiteralTypeAnnotation");

            case 78:
              this.next();
              return this.finishNode(node, "ThisTypeAnnotation");

            case 55:
              this.next();
              return this.finishNode(node, "ExistsTypeAnnotation");

            case 87:
              return this.flowParseTypeofType();

            default:
              if (tokenIsKeyword(this.state.type)) {
                var label = tokenLabelName(this.state.type);
                this.next();
                return _get(_getPrototypeOf(FlowParserMixin.prototype), "createIdentifier", this).call(this, node, label);
              } else if (tokenIsIdentifier(this.state.type)) {
                if (this.isContextual(125)) {
                  return this.flowParseInterfaceType();
                }

                return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
              }

          }

          throw this.unexpected();
        }
      }, {
        key: "flowParsePostfixType",
        value: function flowParsePostfixType() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var type = this.flowParsePrimaryType();
          var seenOptionalIndexedAccess = false;

          while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
            var node = this.startNodeAt(startPos, startLoc);
            var optional = this.eat(18);
            seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
            this.expect(0);

            if (!optional && this.match(3)) {
              node.elementType = type;
              this.next();
              type = this.finishNode(node, "ArrayTypeAnnotation");
            } else {
              node.objectType = type;
              node.indexType = this.flowParseType();
              this.expect(3);

              if (seenOptionalIndexedAccess) {
                node.optional = optional;
                type = this.finishNode(node, "OptionalIndexedAccessType");
              } else {
                type = this.finishNode(node, "IndexedAccessType");
              }
            }
          }

          return type;
        }
      }, {
        key: "flowParsePrefixType",
        value: function flowParsePrefixType() {
          var node = this.startNode();

          if (this.eat(17)) {
            node.typeAnnotation = this.flowParsePrefixType();
            return this.finishNode(node, "NullableTypeAnnotation");
          } else {
            return this.flowParsePostfixType();
          }
        }
      }, {
        key: "flowParseAnonFunctionWithoutParens",
        value: function flowParseAnonFunctionWithoutParens() {
          var param = this.flowParsePrefixType();

          if (!this.state.noAnonFunctionType && this.eat(19)) {
            var node = this.startNodeAt(param.start, param.loc.start);
            node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
            node.rest = null;
            node["this"] = null;
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          }

          return param;
        }
      }, {
        key: "flowParseIntersectionType",
        value: function flowParseIntersectionType() {
          var node = this.startNode();
          this.eat(45);
          var type = this.flowParseAnonFunctionWithoutParens();
          node.types = [type];

          while (this.eat(45)) {
            node.types.push(this.flowParseAnonFunctionWithoutParens());
          }

          return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        }
      }, {
        key: "flowParseUnionType",
        value: function flowParseUnionType() {
          var node = this.startNode();
          this.eat(43);
          var type = this.flowParseIntersectionType();
          node.types = [type];

          while (this.eat(43)) {
            node.types.push(this.flowParseIntersectionType());
          }

          return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        }
      }, {
        key: "flowParseType",
        value: function flowParseType() {
          var oldInType = this.state.inType;
          this.state.inType = true;
          var type = this.flowParseUnionType();
          this.state.inType = oldInType;
          return type;
        }
      }, {
        key: "flowParseTypeOrImplicitInstantiation",
        value: function flowParseTypeOrImplicitInstantiation() {
          if (this.state.type === 128 && this.state.value === "_") {
            var startPos = this.state.start;
            var startLoc = this.state.startLoc;
            var node = this.parseIdentifier();
            return this.flowParseGenericType(startPos, startLoc, node);
          } else {
            return this.flowParseType();
          }
        }
      }, {
        key: "flowParseTypeAnnotation",
        value: function flowParseTypeAnnotation() {
          var node = this.startNode();
          node.typeAnnotation = this.flowParseTypeInitialiser();
          return this.finishNode(node, "TypeAnnotation");
        }
      }, {
        key: "flowParseTypeAnnotatableIdentifier",
        value: function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
          var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

          if (this.match(14)) {
            ident.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(ident);
          }

          return ident;
        }
      }, {
        key: "typeCastToParameter",
        value: function typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
      }, {
        key: "flowParseVariance",
        value: function flowParseVariance() {
          var variance = null;

          if (this.match(53)) {
            variance = this.startNode();

            if (this.state.value === "+") {
              variance.kind = "plus";
            } else {
              variance.kind = "minus";
            }

            this.next();
            return this.finishNode(variance, "Variance");
          }

          return variance;
        }
      }, {
        key: "parseFunctionBody",
        value: function parseFunctionBody(node, allowExpressionBody) {
          var _this13 = this;

          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (allowExpressionBody) {
            return this.forwardNoArrowParamsConversionAt(node, function () {
              return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseFunctionBody", _this13).call(_this13, node, true, isMethod);
            });
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseFunctionBody", this).call(this, node, false, isMethod);
        }
      }, {
        key: "parseFunctionBodyAndFinish",
        value: function parseFunctionBodyAndFinish(node, type) {
          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (this.match(14)) {
            var typeNode = this.startNode();

            var _this$flowParseTypeAn3 = this.flowParseTypeAndPredicateInitialiser();

            var _this$flowParseTypeAn4 = _slicedToArray(_this$flowParseTypeAn3, 2);

            typeNode.typeAnnotation = _this$flowParseTypeAn4[0];
            node.predicate = _this$flowParseTypeAn4[1];
            node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseFunctionBodyAndFinish", this).call(this, node, type, isMethod);
        }
      }, {
        key: "parseStatement",
        value: function parseStatement(context, topLevel) {
          if (this.state.strict && this.isContextual(125)) {
            var lookahead = this.lookahead();

            if (tokenIsKeywordOrIdentifier(lookahead.type)) {
              var node = this.startNode();
              this.next();
              return this.flowParseInterface(node);
            }
          } else if (this.shouldParseEnums() && this.isContextual(122)) {
            var _node = this.startNode();

            this.next();
            return this.flowParseEnumDeclaration(_node);
          }

          var stmt = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseStatement", this).call(this, context, topLevel);

          if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
            this.flowPragma = null;
          }

          return stmt;
        }
      }, {
        key: "parseExpressionStatement",
        value: function parseExpressionStatement(node, expr) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                return this.flowParseDeclare(node);
              }
            } else if (tokenIsIdentifier(this.state.type)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node, false);
              }
            }
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseExpressionStatement", this).call(this, node, expr);
        }
      }, {
        key: "shouldParseExportDeclaration",
        value: function shouldParseExportDeclaration() {
          var type = this.state.type;

          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {
            return !this.state.containsEsc;
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "shouldParseExportDeclaration", this).call(this);
        }
      }, {
        key: "isExportDefaultSpecifier",
        value: function isExportDefaultSpecifier() {
          var type = this.state.type;

          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {
            return this.state.containsEsc;
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "isExportDefaultSpecifier", this).call(this);
        }
      }, {
        key: "parseExportDefaultExpression",
        value: function parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual(122)) {
            var node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseExportDefaultExpression", this).call(this);
        }
      }, {
        key: "parseConditional",
        value: function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          var _this14 = this;

          if (!this.match(17)) return expr;

          if (this.state.maybeInArrowParameters) {
            var nextCh = this.lookaheadCharCode();

            if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
              this.setOptionalParametersError(refExpressionErrors);
              return expr;
            }
          }

          this.expect(17);
          var state = this.state.clone();
          var originalNoArrowAt = this.state.noArrowAt;
          var node = this.startNodeAt(startPos, startLoc);

          var _this$tryParseConditi = this.tryParseConditionalConsequent(),
              consequent = _this$tryParseConditi.consequent,
              failed = _this$tryParseConditi.failed;

          var _this$getArrowLikeExp = this.getArrowLikeExpressions(consequent),
              _this$getArrowLikeExp2 = _slicedToArray(_this$getArrowLikeExp, 2),
              valid = _this$getArrowLikeExp2[0],
              invalid = _this$getArrowLikeExp2[1];

          if (failed || invalid.length > 0) {
            var noArrowAt = _toConsumableArray(originalNoArrowAt);

            if (invalid.length > 0) {
              this.state = state;
              this.state.noArrowAt = noArrowAt;

              for (var i = 0; i < invalid.length; i++) {
                noArrowAt.push(invalid[i].start);
              }

              var _this$tryParseConditi2 = this.tryParseConditionalConsequent();

              consequent = _this$tryParseConditi2.consequent;
              failed = _this$tryParseConditi2.failed;

              var _this$getArrowLikeExp3 = this.getArrowLikeExpressions(consequent);

              var _this$getArrowLikeExp4 = _slicedToArray(_this$getArrowLikeExp3, 2);

              valid = _this$getArrowLikeExp4[0];
              invalid = _this$getArrowLikeExp4[1];
            }

            if (failed && valid.length > 1) {
              this.raise(FlowErrors.AmbiguousConditionalArrow, {
                at: state.startLoc
              });
            }

            if (failed && valid.length === 1) {
              this.state = state;
              noArrowAt.push(valid[0].start);
              this.state.noArrowAt = noArrowAt;

              var _this$tryParseConditi3 = this.tryParseConditionalConsequent();

              consequent = _this$tryParseConditi3.consequent;
              failed = _this$tryParseConditi3.failed;
            }
          }

          this.getArrowLikeExpressions(consequent, true);
          this.state.noArrowAt = originalNoArrowAt;
          this.expect(14);
          node.test = expr;
          node.consequent = consequent;
          node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
            return _this14.parseMaybeAssign(undefined, undefined);
          });
          return this.finishNode(node, "ConditionalExpression");
        }
      }, {
        key: "tryParseConditionalConsequent",
        value: function tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          var consequent = this.parseMaybeAssignAllowIn();
          var failed = !this.match(14);
          this.state.noArrowParamsConversionAt.pop();
          return {
            consequent: consequent,
            failed: failed
          };
        }
      }, {
        key: "getArrowLikeExpressions",
        value: function getArrowLikeExpressions(node, disallowInvalid) {
          var _this15 = this;

          var stack = [node];
          var arrows = [];

          while (stack.length !== 0) {
            var _node2 = stack.pop();

            if (_node2.type === "ArrowFunctionExpression") {
              if (_node2.typeParameters || !_node2.returnType) {
                this.finishArrowValidation(_node2);
              } else {
                arrows.push(_node2);
              }

              stack.push(_node2.body);
            } else if (_node2.type === "ConditionalExpression") {
              stack.push(_node2.consequent);
              stack.push(_node2.alternate);
            }
          }

          if (disallowInvalid) {
            arrows.forEach(function (node) {
              return _this15.finishArrowValidation(node);
            });
            return [arrows, []];
          }

          return partition(arrows, function (node) {
            return node.params.every(function (param) {
              return _this15.isAssignable(param, true);
            });
          });
        }
      }, {
        key: "finishArrowValidation",
        value: function finishArrowValidation(node) {
          var _node$extra;

          this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);

          _get(_getPrototypeOf(FlowParserMixin.prototype), "checkParams", this).call(this, node, false, true);

          this.scope.exit();
        }
      }, {
        key: "forwardNoArrowParamsConversionAt",
        value: function forwardNoArrowParamsConversionAt(node, parse) {
          var result;

          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            result = parse();
            this.state.noArrowParamsConversionAt.pop();
          } else {
            result = parse();
          }

          return result;
        }
      }, {
        key: "parseParenItem",
        value: function parseParenItem(node, startPos, startLoc) {
          node = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseParenItem", this).call(this, node, startPos, startLoc);

          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }

          if (this.match(14)) {
            var typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }

          return node;
        }
      }, {
        key: "assertModuleNodeAllowed",
        value: function assertModuleNodeAllowed(node) {
          if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
            return;
          }

          _get(_getPrototypeOf(FlowParserMixin.prototype), "assertModuleNodeAllowed", this).call(this, node);
        }
      }, {
        key: "parseExport",
        value: function parseExport(node) {
          var decl = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseExport", this).call(this, node);

          if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
            decl.exportKind = decl.exportKind || "value";
          }

          return decl;
        }
      }, {
        key: "parseExportDeclaration",
        value: function parseExportDeclaration(node) {
          if (this.isContextual(126)) {
            node.exportKind = "type";
            var declarationNode = this.startNode();
            this.next();

            if (this.match(5)) {
              node.specifiers = this.parseExportSpecifiers(true);

              _get(_getPrototypeOf(FlowParserMixin.prototype), "parseExportFrom", this).call(this, node);

              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual(127)) {
            node.exportKind = "type";

            var _declarationNode = this.startNode();

            this.next();
            return this.flowParseOpaqueType(_declarationNode, false);
          } else if (this.isContextual(125)) {
            node.exportKind = "type";

            var _declarationNode2 = this.startNode();

            this.next();
            return this.flowParseInterface(_declarationNode2);
          } else if (this.shouldParseEnums() && this.isContextual(122)) {
            node.exportKind = "value";

            var _declarationNode3 = this.startNode();

            this.next();
            return this.flowParseEnumDeclaration(_declarationNode3);
          } else {
            return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseExportDeclaration", this).call(this, node);
          }
        }
      }, {
        key: "eatExportStar",
        value: function eatExportStar(node) {
          if (_get(_getPrototypeOf(FlowParserMixin.prototype), "eatExportStar", this).call(this, node)) return true;

          if (this.isContextual(126) && this.lookahead().type === 55) {
            node.exportKind = "type";
            this.next();
            this.next();
            return true;
          }

          return false;
        }
      }, {
        key: "maybeParseExportNamespaceSpecifier",
        value: function maybeParseExportNamespaceSpecifier(node) {
          var startLoc = this.state.startLoc;

          var hasNamespace = _get(_getPrototypeOf(FlowParserMixin.prototype), "maybeParseExportNamespaceSpecifier", this).call(this, node);

          if (hasNamespace && node.exportKind === "type") {
            this.unexpected(startLoc);
          }

          return hasNamespace;
        }
      }, {
        key: "parseClassId",
        value: function parseClassId(node, isStatement, optionalId) {
          _get(_getPrototypeOf(FlowParserMixin.prototype), "parseClassId", this).call(this, node, isStatement, optionalId);

          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        }
      }, {
        key: "parseClassMember",
        value: function parseClassMember(classBody, member, state) {
          var startLoc = this.state.startLoc;

          if (this.isContextual(121)) {
            if (_get(_getPrototypeOf(FlowParserMixin.prototype), "parseClassMemberFromModifier", this).call(this, classBody, member)) {
              return;
            }

            member.declare = true;
          }

          _get(_getPrototypeOf(FlowParserMixin.prototype), "parseClassMember", this).call(this, classBody, member, state);

          if (member.declare) {
            if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
              this.raise(FlowErrors.DeclareClassElement, {
                at: startLoc
              });
            } else if (member.value) {
              this.raise(FlowErrors.DeclareClassFieldInitializer, {
                at: member.value
              });
            }
          }
        }
      }, {
        key: "isIterator",
        value: function isIterator(word) {
          return word === "iterator" || word === "asyncIterator";
        }
      }, {
        key: "readIterator",
        value: function readIterator() {
          var word = _get(_getPrototypeOf(FlowParserMixin.prototype), "readWord1", this).call(this);

          var fullWord = "@@" + word;

          if (!this.isIterator(word) || !this.state.inType) {
            this.raise(Errors.InvalidIdentifier, {
              at: this.state.curPosition(),
              identifierName: fullWord
            });
          }

          this.finishToken(128, fullWord);
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 123 && next === 124) {
            return this.finishOp(6, 2);
          } else if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(code === 62 ? 48 : 47, 1);
          } else if (this.state.inType && code === 63) {
            if (next === 46) {
              return this.finishOp(18, 2);
            }

            return this.finishOp(17, 1);
          } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
            this.state.pos += 2;
            return this.readIterator();
          } else {
            return _get(_getPrototypeOf(FlowParserMixin.prototype), "getTokenFromCode", this).call(this, code);
          }
        }
      }, {
        key: "isAssignable",
        value: function isAssignable(node, isBinding) {
          if (node.type === "TypeCastExpression") {
            return this.isAssignable(node.expression, isBinding);
          } else {
            return _get(_getPrototypeOf(FlowParserMixin.prototype), "isAssignable", this).call(this, node, isBinding);
          }
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node) {
          var isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
            node.left = this.typeCastToParameter(node.left);
          }

          _get(_getPrototypeOf(FlowParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
        }
      }, {
        key: "toAssignableList",
        value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];

            if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }

          _get(_getPrototypeOf(FlowParserMixin.prototype), "toAssignableList", this).call(this, exprList, trailingCommaLoc, isLHS);
        }
      }, {
        key: "toReferencedList",
        value: function toReferencedList(exprList, isParenthesizedExpr) {
          for (var i = 0; i < exprList.length; i++) {
            var _expr$extra;

            var expr = exprList[i];

            if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
              this.raise(FlowErrors.TypeCastInPattern, {
                at: expr.typeAnnotation
              });
            }
          }

          return exprList;
        }
      }, {
        key: "parseArrayLike",
        value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          var node = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseArrayLike", this).call(this, close, canBePattern, isTuple, refExpressionErrors);

          if (canBePattern && !this.state.maybeInArrowParameters) {
            this.toReferencedList(node.elements);
          }

          return node;
        }
      }, {
        key: "isValidLVal",
        value: function isValidLVal(type, isParenthesized, binding) {
          return type === "TypeCastExpression" || _get(_getPrototypeOf(FlowParserMixin.prototype), "isValidLVal", this).call(this, type, isParenthesized, binding);
        }
      }, {
        key: "parseClassProperty",
        value: function parseClassProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseClassProperty", this).call(this, node);
        }
      }, {
        key: "parseClassPrivateProperty",
        value: function parseClassPrivateProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseClassPrivateProperty", this).call(this, node);
        }
      }, {
        key: "isClassMethod",
        value: function isClassMethod() {
          return this.match(47) || _get(_getPrototypeOf(FlowParserMixin.prototype), "isClassMethod", this).call(this);
        }
      }, {
        key: "isClassProperty",
        value: function isClassProperty() {
          return this.match(14) || _get(_getPrototypeOf(FlowParserMixin.prototype), "isClassProperty", this).call(this);
        }
      }, {
        key: "isNonstaticConstructor",
        value: function isNonstaticConstructor(method) {
          return !this.match(14) && _get(_getPrototypeOf(FlowParserMixin.prototype), "isNonstaticConstructor", this).call(this, method);
        }
      }, {
        key: "pushClassMethod",
        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }

          delete method.variance;

          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _get(_getPrototypeOf(FlowParserMixin.prototype), "pushClassMethod", this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);

          if (method.params && isConstructor) {
            var params = method.params;

            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
            var _params2 = method.value.params;

            if (_params2.length > 0 && this.isThisParam(_params2[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          }
        }
      }, {
        key: "pushClassPrivateMethod",
        value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }

          delete method.variance;

          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _get(_getPrototypeOf(FlowParserMixin.prototype), "pushClassPrivateMethod", this).call(this, classBody, method, isGenerator, isAsync);
        }
      }, {
        key: "parseClassSuper",
        value: function parseClassSuper(node) {
          _get(_getPrototypeOf(FlowParserMixin.prototype), "parseClassSuper", this).call(this, node);

          if (node.superClass && this.match(47)) {
            node.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }

          if (this.isContextual(110)) {
            this.next();
            var implemented = node["implements"] = [];

            do {
              var _node3 = this.startNode();

              _node3.id = this.flowParseRestrictedIdentifier(true);

              if (this.match(47)) {
                _node3.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                _node3.typeParameters = null;
              }

              implemented.push(this.finishNode(_node3, "ClassImplements"));
            } while (this.eat(12));
          }
        }
      }, {
        key: "checkGetterSetterParams",
        value: function checkGetterSetterParams(method) {
          _get(_getPrototypeOf(FlowParserMixin.prototype), "checkGetterSetterParams", this).call(this, method);

          var params = this.getObjectOrClassMethodParams(method);

          if (params.length > 0) {
            var param = params[0];

            if (this.isThisParam(param) && method.kind === "get") {
              this.raise(FlowErrors.GetterMayNotHaveThisParam, {
                at: param
              });
            } else if (this.isThisParam(param)) {
              this.raise(FlowErrors.SetterMayNotHaveThisParam, {
                at: param
              });
            }
          }
        }
      }, {
        key: "parsePropertyNamePrefixOperator",
        value: function parsePropertyNamePrefixOperator(node) {
          node.variance = this.flowParseVariance();
        }
      }, {
        key: "parseObjPropValue",
        value: function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          if (prop.variance) {
            this.unexpected(prop.variance.loc.start);
          }

          delete prop.variance;
          var typeParameters;

          if (this.match(47) && !isAccessor) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(10)) this.unexpected();
          }

          var result = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseObjPropValue", this).call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);

          if (typeParameters) {
            (result.value || result).typeParameters = typeParameters;
          }

          return result;
        }
      }, {
        key: "parseAssignableListItemTypes",
        value: function parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier") {
              this.raise(FlowErrors.PatternIsOptional, {
                at: param
              });
            }

            if (this.isThisParam(param)) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                at: param
              });
            }

            param.optional = true;
          }

          if (this.match(14)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamAnnotationRequired, {
              at: param
            });
          }

          if (this.match(29) && this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamNoDefault, {
              at: param
            });
          }

          this.resetEndLocation(param);
          return param;
        }
      }, {
        key: "parseMaybeDefault",
        value: function parseMaybeDefault(startPos, startLoc, left) {
          var node = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseMaybeDefault", this).call(this, startPos, startLoc, left);

          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(FlowErrors.TypeBeforeInitializer, {
              at: node.typeAnnotation
            });
          }

          return node;
        }
      }, {
        key: "shouldParseDefaultImport",
        value: function shouldParseDefaultImport(node) {
          if (!hasTypeImportKind(node)) {
            return _get(_getPrototypeOf(FlowParserMixin.prototype), "shouldParseDefaultImport", this).call(this, node);
          }

          return isMaybeDefaultImport(this.state.type);
        }
      }, {
        key: "parseImportSpecifierLocal",
        value: function parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
      }, {
        key: "maybeParseDefaultImportSpecifier",
        value: function maybeParseDefaultImportSpecifier(node) {
          node.importKind = "value";
          var kind = null;

          if (this.match(87)) {
            kind = "typeof";
          } else if (this.isContextual(126)) {
            kind = "type";
          }

          if (kind) {
            var lh = this.lookahead();
            var type = lh.type;

            if (kind === "type" && type === 55) {
              this.unexpected(null, lh.type);
            }

            if (isMaybeDefaultImport(type) || type === 5 || type === 55) {
              this.next();
              node.importKind = kind;
            }
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "maybeParseDefaultImportSpecifier", this).call(this, node);
        }
      }, {
        key: "parseImportSpecifier",
        value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
          var firstIdent = specifier.imported;
          var specifierTypeKind = null;

          if (firstIdent.type === "Identifier") {
            if (firstIdent.name === "type") {
              specifierTypeKind = "type";
            } else if (firstIdent.name === "typeof") {
              specifierTypeKind = "typeof";
            }
          }

          var isBinding = false;

          if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
            var as_ident = this.parseIdentifier(true);

            if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = cloneIdentifier(as_ident);
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else {
            if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = this.parseIdentifier(true);
              specifier.importKind = specifierTypeKind;
            } else {
              if (importedIsString) {
                throw this.raise(Errors.ImportBindingIsString, {
                  at: specifier,
                  importName: firstIdent.value
                });
              }

              specifier.imported = firstIdent;
              specifier.importKind = null;
            }

            if (this.eatContextual(93)) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = cloneIdentifier(specifier.imported);
            }
          }

          var specifierIsTypeImport = hasTypeImportKind(specifier);

          if (isInTypeOnlyImport && specifierIsTypeImport) {
            this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
              at: specifier
            });
          }

          if (isInTypeOnlyImport || specifierIsTypeImport) {
            this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
          }

          if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
            this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
          }

          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
      }, {
        key: "parseBindingAtom",
        value: function parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);

            default:
              return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseBindingAtom", this).call(this);
          }
        }
      }, {
        key: "parseFunctionParams",
        value: function parseFunctionParams(node, allowModifiers) {
          var kind = node.kind;

          if (kind !== "get" && kind !== "set" && this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _get(_getPrototypeOf(FlowParserMixin.prototype), "parseFunctionParams", this).call(this, node, allowModifiers);
        }
      }, {
        key: "parseVarId",
        value: function parseVarId(decl, kind) {
          _get(_getPrototypeOf(FlowParserMixin.prototype), "parseVarId", this).call(this, decl, kind);

          if (this.match(14)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(decl.id);
          }
        }
      }, {
        key: "parseAsyncArrowFromCallExpression",
        value: function parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            var oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node, call);
        }
      }, {
        key: "shouldParseAsyncArrow",
        value: function shouldParseAsyncArrow() {
          return this.match(14) || _get(_getPrototypeOf(FlowParserMixin.prototype), "shouldParseAsyncArrow", this).call(this);
        }
      }, {
        key: "parseMaybeAssign",
        value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _this16 = this;

          var _jsx;

          var state = null;
          var jsx;

          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            state = this.state.clone();
            jsx = this.tryParse(function () {
              return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseMaybeAssign", _this16).call(_this16, refExpressionErrors, afterLeftParse);
            }, state);
            if (!jsx.error) return jsx.node;
            var context = this.state.context;
            var currentContext = context[context.length - 1];

            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context.pop();
            }
          }

          if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {
            var _jsx2, _jsx3;

            state = state || this.state.clone();
            var typeParameters;
            var arrow = this.tryParse(function (abort) {
              var _arrowExpression$extr;

              typeParameters = _this16.flowParseTypeParameterDeclaration();

              var arrowExpression = _this16.forwardNoArrowParamsConversionAt(typeParameters, function () {
                var result = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseMaybeAssign", _this16).call(_this16, refExpressionErrors, afterLeftParse);

                _this16.resetStartLocationFromNode(result, typeParameters);

                return result;
              });

              if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();

              var expr = _this16.maybeUnwrapTypeCastExpression(arrowExpression);

              if (expr.type !== "ArrowFunctionExpression") abort();
              expr.typeParameters = typeParameters;

              _this16.resetStartLocationFromNode(expr, typeParameters);

              return arrowExpression;
            }, state);
            var arrowExpression = null;

            if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
              if (!arrow.error && !arrow.aborted) {
                if (arrow.node.async) {
                  this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                    at: typeParameters
                  });
                }

                return arrow.node;
              }

              arrowExpression = arrow.node;
            }

            if ((_jsx2 = jsx) != null && _jsx2.node) {
              this.state = jsx.failState;
              return jsx.node;
            }

            if (arrowExpression) {
              this.state = arrow.failState;
              return arrowExpression;
            }

            if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
            if (arrow.thrown) throw arrow.error;
            throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
              at: typeParameters
            });
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseMaybeAssign", this).call(this, refExpressionErrors, afterLeftParse);
        }
      }, {
        key: "parseArrow",
        value: function parseArrow(node) {
          var _this17 = this;

          if (this.match(14)) {
            var result = this.tryParse(function () {
              var oldNoAnonFunctionType = _this17.state.noAnonFunctionType;
              _this17.state.noAnonFunctionType = true;

              var typeNode = _this17.startNode();

              var _this17$flowParseType = _this17.flowParseTypeAndPredicateInitialiser();

              var _this17$flowParseType2 = _slicedToArray(_this17$flowParseType, 2);

              typeNode.typeAnnotation = _this17$flowParseType2[0];
              node.predicate = _this17$flowParseType2[1];
              _this17.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (_this17.canInsertSemicolon()) _this17.unexpected();
              if (!_this17.match(19)) _this17.unexpected();
              return typeNode;
            });
            if (result.thrown) return null;
            if (result.error) this.state = result.failState;
            node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseArrow", this).call(this, node);
        }
      }, {
        key: "shouldParseArrow",
        value: function shouldParseArrow(params) {
          return this.match(14) || _get(_getPrototypeOf(FlowParserMixin.prototype), "shouldParseArrow", this).call(this, params);
        }
      }, {
        key: "setArrowFunctionParameters",
        value: function setArrowFunctionParameters(node, params) {
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            node.params = params;
          } else {
            _get(_getPrototypeOf(FlowParserMixin.prototype), "setArrowFunctionParameters", this).call(this, node, params);
          }
        }
      }, {
        key: "checkParams",
        value: function checkParams(node, allowDuplicates, isArrowFunction) {
          var strictModeChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

          if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            return;
          }

          for (var i = 0; i < node.params.length; i++) {
            if (this.isThisParam(node.params[i]) && i > 0) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node.params[i]
              });
            }
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "checkParams", this).call(this, node, allowDuplicates, isArrowFunction, strictModeChanged);
        }
      }, {
        key: "parseParenAndDistinguishExpression",
        value: function parseParenAndDistinguishExpression(canBeArrow) {
          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseParenAndDistinguishExpression", this).call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
      }, {
        key: "parseSubscripts",
        value: function parseSubscripts(base, startPos, startLoc, noCalls) {
          var _this18 = this;

          if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
            this.next();
            var node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseCallExpressionArguments", this).call(this, 11, false);
            base = this.finishNode(node, "CallExpression");
          } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
            var state = this.state.clone();
            var arrow = this.tryParse(function (abort) {
              return _this18.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort();
            }, state);
            if (!arrow.error && !arrow.aborted) return arrow.node;
            var result = this.tryParse(function () {
              return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseSubscripts", _this18).call(_this18, base, startPos, startLoc, noCalls);
            }, state);
            if (result.node && !result.error) return result.node;

            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }

            if (result.node) {
              this.state = result.failState;
              return result.node;
            }

            throw arrow.error || result.error;
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseSubscripts", this).call(this, base, startPos, startLoc, noCalls);
        }
      }, {
        key: "parseSubscript",
        value: function parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
          var _this19 = this;

          if (this.match(18) && this.isLookaheadToken_lt()) {
            subscriptState.optionalChainMember = true;

            if (noCalls) {
              subscriptState.stop = true;
              return base;
            }

            this.next();
            var node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.typeArguments = this.flowParseTypeParameterInstantiation();
            this.expect(10);
            node.arguments = this.parseCallExpressionArguments(11, false);
            node.optional = true;
            return this.finishCallExpression(node, true);
          } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
            var _node4 = this.startNodeAt(startPos, startLoc);

            _node4.callee = base;
            var result = this.tryParse(function () {
              _node4.typeArguments = _this19.flowParseTypeParameterInstantiationCallOrNew();

              _this19.expect(10);

              _node4.arguments = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseCallExpressionArguments", _this19).call(_this19, 11, false);

              if (subscriptState.optionalChainMember) {
                _node4.optional = false;
              }

              return _this19.finishCallExpression(_node4, subscriptState.optionalChainMember);
            });

            if (result.node) {
              if (result.error) this.state = result.failState;
              return result.node;
            }
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseSubscript", this).call(this, base, startPos, startLoc, noCalls, subscriptState);
        }
      }, {
        key: "parseNewCallee",
        value: function parseNewCallee(node) {
          var _this20 = this;

          _get(_getPrototypeOf(FlowParserMixin.prototype), "parseNewCallee", this).call(this, node);

          var targs = null;

          if (this.shouldParseTypes() && this.match(47)) {
            targs = this.tryParse(function () {
              return _this20.flowParseTypeParameterInstantiationCallOrNew();
            }).node;
          }

          node.typeArguments = targs;
        }
      }, {
        key: "parseAsyncArrowWithTypeParameters",
        value: function parseAsyncArrowWithTypeParameters(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          this.parseFunctionParams(node);
          if (!this.parseArrow(node)) return;
          return _get(_getPrototypeOf(FlowParserMixin.prototype), "parseArrowExpression", this).call(this, node, undefined, true);
        }
      }, {
        key: "readToken_mult_modulo",
        value: function readToken_mult_modulo(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 42 && next === 47 && this.state.hasFlowComment) {
            this.state.hasFlowComment = false;
            this.state.pos += 2;
            this.nextToken();
            return;
          }

          _get(_getPrototypeOf(FlowParserMixin.prototype), "readToken_mult_modulo", this).call(this, code);
        }
      }, {
        key: "readToken_pipe_amp",
        value: function readToken_pipe_amp(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 124 && next === 125) {
            this.finishOp(9, 2);
            return;
          }

          _get(_getPrototypeOf(FlowParserMixin.prototype), "readToken_pipe_amp", this).call(this, code);
        }
      }, {
        key: "parseTopLevel",
        value: function parseTopLevel(file, program) {
          var fileNode = _get(_getPrototypeOf(FlowParserMixin.prototype), "parseTopLevel", this).call(this, file, program);

          if (this.state.hasFlowComment) {
            this.raise(FlowErrors.UnterminatedFlowComment, {
              at: this.state.curPosition()
            });
          }

          return fileNode;
        }
      }, {
        key: "skipBlockComment",
        value: function skipBlockComment() {
          if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
            if (this.state.hasFlowComment) {
              throw this.raise(FlowErrors.NestedFlowComment, {
                at: this.state.startLoc
              });
            }

            this.hasFlowCommentCompletion();
            var commentSkip = this.skipFlowComment();

            if (commentSkip) {
              this.state.pos += commentSkip;
              this.state.hasFlowComment = true;
            }

            return;
          }

          if (this.state.hasFlowComment) {
            var end = this.input.indexOf("*-/", this.state.pos + 2);

            if (end === -1) {
              throw this.raise(Errors.UnterminatedComment, {
                at: this.state.curPosition()
              });
            }

            this.state.pos = end + 2 + 3;
            return;
          }

          return _get(_getPrototypeOf(FlowParserMixin.prototype), "skipBlockComment", this).call(this);
        }
      }, {
        key: "skipFlowComment",
        value: function skipFlowComment() {
          var pos = this.state.pos;
          var shiftToFirstNonWhiteSpace = 2;

          while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
            shiftToFirstNonWhiteSpace++;
          }

          var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
          var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

          if (ch2 === 58 && ch3 === 58) {
            return shiftToFirstNonWhiteSpace + 2;
          }

          if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
            return shiftToFirstNonWhiteSpace + 12;
          }

          if (ch2 === 58 && ch3 !== 58) {
            return shiftToFirstNonWhiteSpace;
          }

          return false;
        }
      }, {
        key: "hasFlowCommentCompletion",
        value: function hasFlowCommentCompletion() {
          var end = this.input.indexOf("*/", this.state.pos);

          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
        }
      }, {
        key: "flowEnumErrorBooleanMemberNotInitialized",
        value: function flowEnumErrorBooleanMemberNotInitialized(loc, _ref69) {
          var enumName = _ref69.enumName,
              memberName = _ref69.memberName;
          this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
            at: loc,
            memberName: memberName,
            enumName: enumName
          });
        }
      }, {
        key: "flowEnumErrorInvalidMemberInitializer",
        value: function flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
          return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
            at: loc
          }, enumContext));
        }
      }, {
        key: "flowEnumErrorNumberMemberNotInitialized",
        value: function flowEnumErrorNumberMemberNotInitialized(loc, _ref70) {
          var enumName = _ref70.enumName,
              memberName = _ref70.memberName;
          this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
            at: loc,
            enumName: enumName,
            memberName: memberName
          });
        }
      }, {
        key: "flowEnumErrorStringMemberInconsistentlyInitailized",
        value: function flowEnumErrorStringMemberInconsistentlyInitailized(node, _ref71) {
          var enumName = _ref71.enumName;
          this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
            at: node,
            enumName: enumName
          });
        }
      }, {
        key: "flowEnumMemberInit",
        value: function flowEnumMemberInit() {
          var _this21 = this;

          var startLoc = this.state.startLoc;

          var endOfInit = function endOfInit() {
            return _this21.match(12) || _this21.match(8);
          };

          switch (this.state.type) {
            case 130:
              {
                var literal = this.parseNumericLiteral(this.state.value);

                if (endOfInit()) {
                  return {
                    type: "number",
                    loc: literal.loc.start,
                    value: literal
                  };
                }

                return {
                  type: "invalid",
                  loc: startLoc
                };
              }

            case 129:
              {
                var _literal = this.parseStringLiteral(this.state.value);

                if (endOfInit()) {
                  return {
                    type: "string",
                    loc: _literal.loc.start,
                    value: _literal
                  };
                }

                return {
                  type: "invalid",
                  loc: startLoc
                };
              }

            case 85:
            case 86:
              {
                var _literal2 = this.parseBooleanLiteral(this.match(85));

                if (endOfInit()) {
                  return {
                    type: "boolean",
                    loc: _literal2.loc.start,
                    value: _literal2
                  };
                }

                return {
                  type: "invalid",
                  loc: startLoc
                };
              }

            default:
              return {
                type: "invalid",
                loc: startLoc
              };
          }
        }
      }, {
        key: "flowEnumMemberRaw",
        value: function flowEnumMemberRaw() {
          var loc = this.state.startLoc;
          var id = this.parseIdentifier(true);
          var init = this.eat(29) ? this.flowEnumMemberInit() : {
            type: "none",
            loc: loc
          };
          return {
            id: id,
            init: init
          };
        }
      }, {
        key: "flowEnumCheckExplicitTypeMismatch",
        value: function flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
          var explicitType = context.explicitType;

          if (explicitType === null) {
            return;
          }

          if (explicitType !== expectedType) {
            this.flowEnumErrorInvalidMemberInitializer(loc, context);
          }
        }
      }, {
        key: "flowEnumMembers",
        value: function flowEnumMembers(_ref72) {
          var enumName = _ref72.enumName,
              explicitType = _ref72.explicitType;
          var seenNames = new Set();
          var members = {
            booleanMembers: [],
            numberMembers: [],
            stringMembers: [],
            defaultedMembers: []
          };
          var hasUnknownMembers = false;

          while (!this.match(8)) {
            if (this.eat(21)) {
              hasUnknownMembers = true;
              break;
            }

            var memberNode = this.startNode();

            var _this$flowEnumMemberR = this.flowEnumMemberRaw(),
                id = _this$flowEnumMemberR.id,
                init = _this$flowEnumMemberR.init;

            var memberName = id.name;

            if (memberName === "") {
              continue;
            }

            if (/^[a-z]/.test(memberName)) {
              this.raise(FlowErrors.EnumInvalidMemberName, {
                at: id,
                memberName: memberName,
                suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                enumName: enumName
              });
            }

            if (seenNames.has(memberName)) {
              this.raise(FlowErrors.EnumDuplicateMemberName, {
                at: id,
                memberName: memberName,
                enumName: enumName
              });
            }

            seenNames.add(memberName);
            var context = {
              enumName: enumName,
              explicitType: explicitType,
              memberName: memberName
            };
            memberNode.id = id;

            switch (init.type) {
              case "boolean":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
                  memberNode.init = init.value;
                  members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                  break;
                }

              case "number":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
                  memberNode.init = init.value;
                  members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                  break;
                }

              case "string":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
                  memberNode.init = init.value;
                  members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                  break;
                }

              case "invalid":
                {
                  throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
                }

              case "none":
                {
                  switch (explicitType) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                      break;

                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                      break;

                    default:
                      members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                  }
                }
            }

            if (!this.match(8)) {
              this.expect(12);
            }
          }

          return {
            members: members,
            hasUnknownMembers: hasUnknownMembers
          };
        }
      }, {
        key: "flowEnumStringMembers",
        value: function flowEnumStringMembers(initializedMembers, defaultedMembers, _ref73) {
          var enumName = _ref73.enumName;

          if (initializedMembers.length === 0) {
            return defaultedMembers;
          } else if (defaultedMembers.length === 0) {
            return initializedMembers;
          } else if (defaultedMembers.length > initializedMembers.length) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = initializedMembers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var member = _step2.value;
                this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                  enumName: enumName
                });
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            return defaultedMembers;
          } else {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = defaultedMembers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _member = _step3.value;
                this.flowEnumErrorStringMemberInconsistentlyInitailized(_member, {
                  enumName: enumName
                });
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            return initializedMembers;
          }
        }
      }, {
        key: "flowEnumParseExplicitType",
        value: function flowEnumParseExplicitType(_ref74) {
          var enumName = _ref74.enumName;
          if (!this.eatContextual(101)) return null;

          if (!tokenIsIdentifier(this.state.type)) {
            throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
              at: this.state.startLoc,
              enumName: enumName
            });
          }

          var value = this.state.value;
          this.next();

          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.raise(FlowErrors.EnumInvalidExplicitType, {
              at: this.state.startLoc,
              enumName: enumName,
              invalidEnumType: value
            });
          }

          return value;
        }
      }, {
        key: "flowEnumBody",
        value: function flowEnumBody(node, id) {
          var _this22 = this;

          var enumName = id.name;
          var nameLoc = id.loc.start;
          var explicitType = this.flowEnumParseExplicitType({
            enumName: enumName
          });
          this.expect(5);

          var _this$flowEnumMembers = this.flowEnumMembers({
            enumName: enumName,
            explicitType: explicitType
          }),
              members = _this$flowEnumMembers.members,
              hasUnknownMembers = _this$flowEnumMembers.hasUnknownMembers;

          node.hasUnknownMembers = hasUnknownMembers;

          switch (explicitType) {
            case "boolean":
              node.explicitType = true;
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");

            case "number":
              node.explicitType = true;
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");

            case "string":
              node.explicitType = true;
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName: enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");

            case "symbol":
              node.members = members.defaultedMembers;
              this.expect(8);
              return this.finishNode(node, "EnumSymbolBody");

            default:
              {
                var empty = function empty() {
                  node.members = [];

                  _this22.expect(8);

                  return _this22.finishNode(node, "EnumStringBody");
                };

                node.explicitType = false;
                var boolsLen = members.booleanMembers.length;
                var numsLen = members.numberMembers.length;
                var strsLen = members.stringMembers.length;
                var defaultedLen = members.defaultedMembers.length;

                if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                  return empty();
                } else if (!boolsLen && !numsLen) {
                  node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                    enumName: enumName
                  });
                  this.expect(8);
                  return this.finishNode(node, "EnumStringBody");
                } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                  var _iteratorNormalCompletion4 = true;
                  var _didIteratorError4 = false;
                  var _iteratorError4 = undefined;

                  try {
                    for (var _iterator4 = members.defaultedMembers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var member = _step4.value;
                      this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                        enumName: enumName,
                        memberName: member.id.name
                      });
                    }
                  } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                        _iterator4["return"]();
                      }
                    } finally {
                      if (_didIteratorError4) {
                        throw _iteratorError4;
                      }
                    }
                  }

                  node.members = members.booleanMembers;
                  this.expect(8);
                  return this.finishNode(node, "EnumBooleanBody");
                } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                  var _iteratorNormalCompletion5 = true;
                  var _didIteratorError5 = false;
                  var _iteratorError5 = undefined;

                  try {
                    for (var _iterator5 = members.defaultedMembers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                      var _member2 = _step5.value;
                      this.flowEnumErrorNumberMemberNotInitialized(_member2.loc.start, {
                        enumName: enumName,
                        memberName: _member2.id.name
                      });
                    }
                  } catch (err) {
                    _didIteratorError5 = true;
                    _iteratorError5 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                        _iterator5["return"]();
                      }
                    } finally {
                      if (_didIteratorError5) {
                        throw _iteratorError5;
                      }
                    }
                  }

                  node.members = members.numberMembers;
                  this.expect(8);
                  return this.finishNode(node, "EnumNumberBody");
                } else {
                  this.raise(FlowErrors.EnumInconsistentMemberValues, {
                    at: nameLoc,
                    enumName: enumName
                  });
                  return empty();
                }
              }
          }
        }
      }, {
        key: "flowParseEnumDeclaration",
        value: function flowParseEnumDeclaration(node) {
          var id = this.parseIdentifier();
          node.id = id;
          node.body = this.flowEnumBody(this.startNode(), id);
          return this.finishNode(node, "EnumDeclaration");
        }
      }, {
        key: "isLookaheadToken_lt",
        value: function isLookaheadToken_lt() {
          var next = this.nextTokenStart();

          if (this.input.charCodeAt(next) === 60) {
            var afterNext = this.input.charCodeAt(next + 1);
            return afterNext !== 60 && afterNext !== 61;
          }

          return false;
        }
      }, {
        key: "maybeUnwrapTypeCastExpression",
        value: function maybeUnwrapTypeCastExpression(node) {
          return node.type === "TypeCastExpression" ? node.expression : node;
        }
      }]);

      return FlowParserMixin;
    }(superClass)
  );
};

var entities = {
  __proto__: null,
  quot: "\"",
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  "int": "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};
var JsxErrors = ParseErrorEnum(_templateObject3())({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
  MissingClosingTagElement: function MissingClosingTagElement(_ref75) {
    var openingTagName = _ref75.openingTagName;
    return "Expected corresponding JSX closing tag for <".concat(openingTagName, ">.");
  },
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
  UnexpectedToken: function UnexpectedToken(_ref76) {
    var unexpected = _ref76.unexpected,
        HTMLEntity = _ref76.HTMLEntity;
    return "Unexpected token `".concat(unexpected, "`. Did you mean `").concat(HTMLEntity, "` or `{'").concat(unexpected, "'}`?");
  },
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
  UnterminatedJsxContent: "Unterminated JSX contents.",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
});

function isFragment(object) {
  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
}

function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }

  throw new Error("Node had unexpected type: " + object.type);
}

var jsx = function jsx(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass3) {
      _inherits(JSXParserMixin, _superClass3);

      function JSXParserMixin() {
        _classCallCheck(this, JSXParserMixin);

        return _possibleConstructorReturn(this, _getPrototypeOf(JSXParserMixin).apply(this, arguments));
      }

      _createClass(JSXParserMixin, [{
        key: "jsxReadToken",
        value: function jsxReadToken() {
          var out = "";
          var chunkStart = this.state.pos;

          for (;;) {
            if (this.state.pos >= this.length) {
              throw this.raise(JsxErrors.UnterminatedJsxContent, {
                at: this.state.startLoc
              });
            }

            var ch = this.input.charCodeAt(this.state.pos);

            switch (ch) {
              case 60:
              case 123:
                if (this.state.pos === this.state.start) {
                  if (ch === 60 && this.state.canStartJSXElement) {
                    ++this.state.pos;
                    return this.finishToken(138);
                  }

                  return _get(_getPrototypeOf(JSXParserMixin.prototype), "getTokenFromCode", this).call(this, ch);
                }

                out += this.input.slice(chunkStart, this.state.pos);
                return this.finishToken(137, out);

              case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;

              case 62:
              case 125:
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(true);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }

            }
          }
        }
      }, {
        key: "jsxReadNewLine",
        value: function jsxReadNewLine(normalizeCRLF) {
          var ch = this.input.charCodeAt(this.state.pos);
          var out;
          ++this.state.pos;

          if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          return out;
        }
      }, {
        key: "jsxReadString",
        value: function jsxReadString(quote) {
          var out = "";
          var chunkStart = ++this.state.pos;

          for (;;) {
            if (this.state.pos >= this.length) {
              throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
            }

            var ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote) break;

            if (ch === 38) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(false);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos++);
          return this.finishToken(129, out);
        }
      }, {
        key: "jsxReadEntity",
        value: function jsxReadEntity() {
          var startPos = ++this.state.pos;

          if (this.codePointAtPos(this.state.pos) === 35) {
            ++this.state.pos;
            var radix = 10;

            if (this.codePointAtPos(this.state.pos) === 120) {
              radix = 16;
              ++this.state.pos;
            }

            var codePoint = this.readInt(radix, undefined, false, "bail");

            if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
              ++this.state.pos;
              return String.fromCodePoint(codePoint);
            }
          } else {
            var count = 0;
            var semi = false;

            while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
              ++this.state.pos;
            }

            if (semi) {
              var desc = this.input.slice(startPos, this.state.pos);
              var entity = entities[desc];
              ++this.state.pos;

              if (entity) {
                return entity;
              }
            }
          }

          this.state.pos = startPos;
          return "&";
        }
      }, {
        key: "jsxReadWord",
        value: function jsxReadWord() {
          var ch;
          var start = this.state.pos;

          do {
            ch = this.input.charCodeAt(++this.state.pos);
          } while (isIdentifierChar(ch) || ch === 45);

          return this.finishToken(136, this.input.slice(start, this.state.pos));
        }
      }, {
        key: "jsxParseIdentifier",
        value: function jsxParseIdentifier() {
          var node = this.startNode();

          if (this.match(136)) {
            node.name = this.state.value;
          } else if (tokenIsKeyword(this.state.type)) {
            node.name = tokenLabelName(this.state.type);
          } else {
            this.unexpected();
          }

          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
      }, {
        key: "jsxParseNamespacedName",
        value: function jsxParseNamespacedName() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var name = this.jsxParseIdentifier();
          if (!this.eat(14)) return name;
          var node = this.startNodeAt(startPos, startLoc);
          node.namespace = name;
          node.name = this.jsxParseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
      }, {
        key: "jsxParseElementName",
        value: function jsxParseElementName() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.jsxParseNamespacedName();

          if (node.type === "JSXNamespacedName") {
            return node;
          }

          while (this.eat(16)) {
            var newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }

          return node;
        }
      }, {
        key: "jsxParseAttributeValue",
        value: function jsxParseAttributeValue() {
          var node;

          switch (this.state.type) {
            case 5:
              node = this.startNode();
              this.setContext(types.brace);
              this.next();
              node = this.jsxParseExpressionContainer(node, types.j_oTag);

              if (node.expression.type === "JSXEmptyExpression") {
                this.raise(JsxErrors.AttributeIsEmpty, {
                  at: node
                });
              }

              return node;

            case 138:
            case 129:
              return this.parseExprAtom();

            default:
              throw this.raise(JsxErrors.UnsupportedJsxValue, {
                at: this.state.startLoc
              });
          }
        }
      }, {
        key: "jsxParseEmptyExpression",
        value: function jsxParseEmptyExpression() {
          var node = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
        }
      }, {
        key: "jsxParseSpreadChild",
        value: function jsxParseSpreadChild(node) {
          this.next();
          node.expression = this.parseExpression();
          this.setContext(types.j_expr);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadChild");
        }
      }, {
        key: "jsxParseExpressionContainer",
        value: function jsxParseExpressionContainer(node, previousContext) {
          if (this.match(8)) {
            node.expression = this.jsxParseEmptyExpression();
          } else {
            var expression = this.parseExpression();
            node.expression = expression;
          }

          this.setContext(previousContext);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXExpressionContainer");
        }
      }, {
        key: "jsxParseAttribute",
        value: function jsxParseAttribute() {
          var node = this.startNode();

          if (this.match(5)) {
            this.setContext(types.brace);
            this.next();
            this.expect(21);
            node.argument = this.parseMaybeAssignAllowIn();
            this.setContext(types.j_oTag);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(node, "JSXSpreadAttribute");
          }

          node.name = this.jsxParseNamespacedName();
          node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
      }, {
        key: "jsxParseOpeningElementAt",
        value: function jsxParseOpeningElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);

          if (this.eat(139)) {
            return this.finishNode(node, "JSXOpeningFragment");
          }

          node.name = this.jsxParseElementName();
          return this.jsxParseOpeningElementAfterName(node);
        }
      }, {
        key: "jsxParseOpeningElementAfterName",
        value: function jsxParseOpeningElementAfterName(node) {
          var attributes = [];

          while (!this.match(56) && !this.match(139)) {
            attributes.push(this.jsxParseAttribute());
          }

          node.attributes = attributes;
          node.selfClosing = this.eat(56);
          this.expect(139);
          return this.finishNode(node, "JSXOpeningElement");
        }
      }, {
        key: "jsxParseClosingElementAt",
        value: function jsxParseClosingElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);

          if (this.eat(139)) {
            return this.finishNode(node, "JSXClosingFragment");
          }

          node.name = this.jsxParseElementName();
          this.expect(139);
          return this.finishNode(node, "JSXClosingElement");
        }
      }, {
        key: "jsxParseElementAt",
        value: function jsxParseElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          var children = [];
          var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
          var closingElement = null;

          if (!openingElement.selfClosing) {
            contents: for (;;) {
              switch (this.state.type) {
                case 138:
                  startPos = this.state.start;
                  startLoc = this.state.startLoc;
                  this.next();

                  if (this.eat(56)) {
                    closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                    break contents;
                  }

                  children.push(this.jsxParseElementAt(startPos, startLoc));
                  break;

                case 137:
                  children.push(this.parseExprAtom());
                  break;

                case 5:
                  {
                    var _node5 = this.startNode();

                    this.setContext(types.brace);
                    this.next();

                    if (this.match(21)) {
                      children.push(this.jsxParseSpreadChild(_node5));
                    } else {
                      children.push(this.jsxParseExpressionContainer(_node5, types.j_expr));
                    }

                    break;
                  }

                default:
                  throw this.unexpected();
              }
            }

            if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
              this.raise(JsxErrors.MissingClosingTagFragment, {
                at: closingElement
              });
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
              this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(JsxErrors.MissingClosingTagElement, {
                  at: closingElement,
                  openingTagName: getQualifiedJSXName(openingElement.name)
                });
              }
            }
          }

          if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
          } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
          }

          node.children = children;

          if (this.match(47)) {
            throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
              at: this.state.startLoc
            });
          }

          return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        }
      }, {
        key: "jsxParseElement",
        value: function jsxParseElement() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          this.next();
          return this.jsxParseElementAt(startPos, startLoc);
        }
      }, {
        key: "setContext",
        value: function setContext(newContext) {
          var context = this.state.context;
          context[context.length - 1] = newContext;
        }
      }, {
        key: "parseExprAtom",
        value: function parseExprAtom(refExpressionErrors) {
          if (this.match(137)) {
            return this.parseLiteral(this.state.value, "JSXText");
          } else if (this.match(138)) {
            return this.jsxParseElement();
          } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
            this.replaceToken(138);
            return this.jsxParseElement();
          } else {
            return _get(_getPrototypeOf(JSXParserMixin.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
          }
        }
      }, {
        key: "skipSpace",
        value: function skipSpace() {
          var curContext = this.curContext();
          if (!curContext.preserveSpace) _get(_getPrototypeOf(JSXParserMixin.prototype), "skipSpace", this).call(this);
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          var context = this.curContext();

          if (context === types.j_expr) {
            return this.jsxReadToken();
          }

          if (context === types.j_oTag || context === types.j_cTag) {
            if (isIdentifierStart(code)) {
              return this.jsxReadWord();
            }

            if (code === 62) {
              ++this.state.pos;
              return this.finishToken(139);
            }

            if ((code === 34 || code === 39) && context === types.j_oTag) {
              return this.jsxReadString(code);
            }
          }

          if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            return this.finishToken(138);
          }

          return _get(_getPrototypeOf(JSXParserMixin.prototype), "getTokenFromCode", this).call(this, code);
        }
      }, {
        key: "updateContext",
        value: function updateContext(prevType) {
          var _this$state = this.state,
              context = _this$state.context,
              type = _this$state.type;

          if (type === 56 && prevType === 138) {
            context.splice(-2, 2, types.j_cTag);
            this.state.canStartJSXElement = false;
          } else if (type === 138) {
            context.push(types.j_oTag);
          } else if (type === 139) {
            var out = context[context.length - 1];

            if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
              context.pop();
              this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
            } else {
              this.setContext(types.j_expr);
              this.state.canStartJSXElement = true;
            }
          } else {
            this.state.canStartJSXElement = tokenComesBeforeExpression(type);
          }
        }
      }]);

      return JSXParserMixin;
    }(superClass)
  );
};

var TypeScriptScope =
/*#__PURE__*/
function (_Scope2) {
  _inherits(TypeScriptScope, _Scope2);

  function TypeScriptScope() {
    var _getPrototypeOf4;

    var _this23;

    _classCallCheck(this, TypeScriptScope);

    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    _this23 = _possibleConstructorReturn(this, (_getPrototypeOf4 = _getPrototypeOf(TypeScriptScope)).call.apply(_getPrototypeOf4, [this].concat(args)));
    _this23.types = new Set();
    _this23.enums = new Set();
    _this23.constEnums = new Set();
    _this23.classes = new Set();
    _this23.exportOnlyBindings = new Set();
    return _this23;
  }

  return TypeScriptScope;
}(Scope);

var TypeScriptScopeHandler =
/*#__PURE__*/
function (_ScopeHandler2) {
  _inherits(TypeScriptScopeHandler, _ScopeHandler2);

  function TypeScriptScopeHandler() {
    var _getPrototypeOf5;

    var _this24;

    _classCallCheck(this, TypeScriptScopeHandler);

    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    _this24 = _possibleConstructorReturn(this, (_getPrototypeOf5 = _getPrototypeOf(TypeScriptScopeHandler)).call.apply(_getPrototypeOf5, [this].concat(args)));
    _this24.importsStack = [];
    return _this24;
  }

  _createClass(TypeScriptScopeHandler, [{
    key: "createScope",
    value: function createScope(flags) {
      this.importsStack.push(new Set());
      return new TypeScriptScope(flags);
    }
  }, {
    key: "enter",
    value: function enter(flags) {
      if (flags == SCOPE_TS_MODULE) {
        this.importsStack.push(new Set());
      }

      _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "enter", this).call(this, flags);
    }
  }, {
    key: "exit",
    value: function exit() {
      var flags = _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "exit", this).call(this);

      if (flags == SCOPE_TS_MODULE) {
        this.importsStack.pop();
      }

      return flags;
    }
  }, {
    key: "hasImport",
    value: function hasImport(name, allowShadow) {
      var len = this.importsStack.length;

      if (this.importsStack[len - 1].has(name)) {
        return true;
      }

      if (!allowShadow && len > 1) {
        for (var i = 0; i < len - 1; i++) {
          if (this.importsStack[i].has(name)) return true;
        }
      }

      return false;
    }
  }, {
    key: "declareName",
    value: function declareName(name, bindingType, loc) {
      if (bindingType & BIND_FLAGS_TS_IMPORT) {
        if (this.hasImport(name, true)) {
          this.parser.raise(Errors.VarRedeclaration, {
            at: loc,
            identifierName: name
          });
        }

        this.importsStack[this.importsStack.length - 1].add(name);
        return;
      }

      var scope = this.currentScope();

      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.add(name);
        return;
      }

      _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "declareName", this).call(this, name, bindingType, loc);

      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          this.maybeExportDefined(scope, name);
        }

        scope.types.add(name);
      }

      if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);
      if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);
    }
  }, {
    key: "isRedeclaredInScope",
    value: function isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.has(name)) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          var isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          var wasConst = scope.constEnums.has(name);
          return isConst !== wasConst;
        }

        return true;
      }

      if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
        if (scope.lexical.has(name)) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }

      if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
        return true;
      }

      return _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "isRedeclaredInScope", this).call(this, scope, name, bindingType);
    }
  }, {
    key: "checkLocalExport",
    value: function checkLocalExport(id) {
      var name = id.name;
      if (this.hasImport(name)) return;
      var len = this.scopeStack.length;

      for (var i = len - 1; i >= 0; i--) {
        var scope = this.scopeStack[i];
        if (scope.types.has(name) || scope.exportOnlyBindings.has(name)) return;
      }

      _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "checkLocalExport", this).call(this, id);
    }
  }]);

  return TypeScriptScopeHandler;
}(ScopeHandler);

var getOwn$1 = function getOwn$1(object, key) {
  return Object.hasOwnProperty.call(object, key) && object[key];
};

function nonNull(x) {
  if (x == null) {
    throw new Error("Unexpected ".concat(x, " value."));
  }

  return x;
}

function assert(x) {
  if (!x) {
    throw new Error("Assert fail");
  }
}

var TSErrors = ParseErrorEnum(_templateObject4())({
  AbstractMethodHasImplementation: function AbstractMethodHasImplementation(_ref77) {
    var methodName = _ref77.methodName;
    return "Method '".concat(methodName, "' cannot have an implementation because it is marked abstract.");
  },
  AbstractPropertyHasInitializer: function AbstractPropertyHasInitializer(_ref78) {
    var propertyName = _ref78.propertyName;
    return "Property '".concat(propertyName, "' cannot have an initializer because it is marked abstract.");
  },
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  CannotFindName: function CannotFindName(_ref79) {
    var name = _ref79.name;
    return "Cannot find name '".concat(name, "'.");
  },
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: function DeclareAccessor(_ref80) {
    var kind = _ref80.kind;
    return "'declare' is not allowed in ".concat(kind, "ters.");
  },
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: function DuplicateAccessibilityModifier(_ref81) {
    var modifier = _ref81.modifier;
    return "Accessibility modifier already seen.";
  },
  DuplicateModifier: function DuplicateModifier(_ref82) {
    var modifier = _ref82.modifier;
    return "Duplicate modifier: '".concat(modifier, "'.");
  },
  EmptyHeritageClauseType: function EmptyHeritageClauseType(_ref83) {
    var token = _ref83.token;
    return "'".concat(token, "' list cannot be empty.");
  },
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  IncompatibleModifiers: function IncompatibleModifiers(_ref84) {
    var modifiers = _ref84.modifiers;
    return "'".concat(modifiers[0], "' modifier cannot be used with '").concat(modifiers[1], "' modifier.");
  },
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: function IndexSignatureHasAccessibility(_ref85) {
    var modifier = _ref85.modifier;
    return "Index signatures cannot have an accessibility modifier ('".concat(modifier, "').");
  },
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: function InvalidModifierOnTypeMember(_ref86) {
    var modifier = _ref86.modifier;
    return "'".concat(modifier, "' modifier cannot appear on a type member.");
  },
  InvalidModifierOnTypeParameter: function InvalidModifierOnTypeParameter(_ref87) {
    var modifier = _ref87.modifier;
    return "'".concat(modifier, "' modifier cannot appear on a type parameter.");
  },
  InvalidModifierOnTypeParameterPositions: function InvalidModifierOnTypeParameterPositions(_ref88) {
    var modifier = _ref88.modifier;
    return "'".concat(modifier, "' modifier can only appear on a type parameter of a class, interface or type alias.");
  },
  InvalidModifiersOrder: function InvalidModifiersOrder(_ref89) {
    var orderedModifiers = _ref89.orderedModifiers;
    return "'".concat(orderedModifiers[0], "' modifier must precede '").concat(orderedModifiers[1], "' modifier.");
  },
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. " + "You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: function PrivateElementHasAccessibility(_ref90) {
    var modifier = _ref90.modifier;
    return "Private elements cannot have an accessibility modifier ('".concat(modifier, "').");
  },
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: function SingleTypeParameterWithoutTrailingComma(_ref91) {
    var typeParameterName = _ref91.typeParameterName;
    return "Single type parameter ".concat(typeParameterName, " should have a trailing comma. Example usage: <").concat(typeParameterName, ",>.");
  },
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: function UnsupportedSignatureParameterKind(_ref92) {
    var type = _ref92.type;
    return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ".concat(type, ".");
  }
});

function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";

    case "boolean":
      return "TSBooleanKeyword";

    case "bigint":
      return "TSBigIntKeyword";

    case "never":
      return "TSNeverKeyword";

    case "number":
      return "TSNumberKeyword";

    case "object":
      return "TSObjectKeyword";

    case "string":
      return "TSStringKeyword";

    case "symbol":
      return "TSSymbolKeyword";

    case "undefined":
      return "TSUndefinedKeyword";

    case "unknown":
      return "TSUnknownKeyword";

    default:
      return undefined;
  }
}

function tsIsAccessModifier(modifier) {
  return modifier === "private" || modifier === "public" || modifier === "protected";
}

function tsIsVarianceAnnotations(modifier) {
  return modifier === "in" || modifier === "out";
}

var typescript = function typescript(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass4) {
      _inherits(TypeScriptParserMixin, _superClass4);

      function TypeScriptParserMixin() {
        _classCallCheck(this, TypeScriptParserMixin);

        return _possibleConstructorReturn(this, _getPrototypeOf(TypeScriptParserMixin).apply(this, arguments));
      }

      _createClass(TypeScriptParserMixin, [{
        key: "getScopeHandler",
        value: function getScopeHandler() {
          return TypeScriptScopeHandler;
        }
      }, {
        key: "tsIsIdentifier",
        value: function tsIsIdentifier() {
          return tokenIsIdentifier(this.state.type);
        }
      }, {
        key: "tsTokenCanFollowModifier",
        value: function tsTokenCanFollowModifier() {
          return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
        }
      }, {
        key: "tsNextTokenCanFollowModifier",
        value: function tsNextTokenCanFollowModifier() {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
      }, {
        key: "tsParseModifier",
        value: function tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
          if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {
            return undefined;
          }

          var modifier = this.state.value;

          if (allowedModifiers.indexOf(modifier) !== -1) {
            if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
              return undefined;
            }

            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
              return modifier;
            }
          }

          return undefined;
        }
      }, {
        key: "tsParseModifiers",
        value: function tsParseModifiers(_ref93) {
          var _this25 = this;

          var modified = _ref93.modified,
              allowedModifiers = _ref93.allowedModifiers,
              disallowedModifiers = _ref93.disallowedModifiers,
              stopOnStartOfClassStaticBlock = _ref93.stopOnStartOfClassStaticBlock,
              _ref93$errorTemplate = _ref93.errorTemplate,
              errorTemplate = _ref93$errorTemplate === void 0 ? TSErrors.InvalidModifierOnTypeMember : _ref93$errorTemplate;

          var enforceOrder = function enforceOrder(loc, modifier, before, after) {
            if (modifier === before && modified[after]) {
              _this25.raise(TSErrors.InvalidModifiersOrder, {
                at: loc,
                orderedModifiers: [before, after]
              });
            }
          };

          var incompatible = function incompatible(loc, modifier, mod1, mod2) {
            if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
              _this25.raise(TSErrors.IncompatibleModifiers, {
                at: loc,
                modifiers: [mod1, mod2]
              });
            }
          };

          for (;;) {
            var startLoc = this.state.startLoc;
            var modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
            if (!modifier) break;

            if (tsIsAccessModifier(modifier)) {
              if (modified.accessibility) {
                this.raise(TSErrors.DuplicateAccessibilityModifier, {
                  at: startLoc,
                  modifier: modifier
                });
              } else {
                enforceOrder(startLoc, modifier, modifier, "override");
                enforceOrder(startLoc, modifier, modifier, "static");
                enforceOrder(startLoc, modifier, modifier, "readonly");
                modified.accessibility = modifier;
              }
            } else if (tsIsVarianceAnnotations(modifier)) {
              if (modified[modifier]) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier: modifier
                });
              }

              modified[modifier] = true;
              enforceOrder(startLoc, modifier, "in", "out");
            } else {
              if (Object.hasOwnProperty.call(modified, modifier)) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier: modifier
                });
              } else {
                enforceOrder(startLoc, modifier, "static", "readonly");
                enforceOrder(startLoc, modifier, "static", "override");
                enforceOrder(startLoc, modifier, "override", "readonly");
                enforceOrder(startLoc, modifier, "abstract", "override");
                incompatible(startLoc, modifier, "declare", "override");
                incompatible(startLoc, modifier, "static", "abstract");
              }

              modified[modifier] = true;
            }

            if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
              this.raise(errorTemplate, {
                at: startLoc,
                modifier: modifier
              });
            }
          }
        }
      }, {
        key: "tsIsListTerminator",
        value: function tsIsListTerminator(kind) {
          switch (kind) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(8);

            case "HeritageClauseElement":
              return this.match(5);

            case "TupleElementTypes":
              return this.match(3);

            case "TypeParametersOrArguments":
              return this.match(48);
          }

          throw new Error("Unreachable");
        }
      }, {
        key: "tsParseList",
        value: function tsParseList(kind, parseElement) {
          var result = [];

          while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
          }

          return result;
        }
      }, {
        key: "tsParseDelimitedList",
        value: function tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
          return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
        }
      }, {
        key: "tsParseDelimitedListWorker",
        value: function tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
          var result = [];
          var trailingCommaPos = -1;

          for (;;) {
            if (this.tsIsListTerminator(kind)) {
              break;
            }

            trailingCommaPos = -1;
            var element = parseElement();

            if (element == null) {
              return undefined;
            }

            result.push(element);

            if (this.eat(12)) {
              trailingCommaPos = this.state.lastTokStart;
              continue;
            }

            if (this.tsIsListTerminator(kind)) {
              break;
            }

            if (expectSuccess) {
              this.expect(12);
            }

            return undefined;
          }

          if (refTrailingCommaPos) {
            refTrailingCommaPos.value = trailingCommaPos;
          }

          return result;
        }
      }, {
        key: "tsParseBracketedList",
        value: function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
          if (!skipFirstToken) {
            if (bracket) {
              this.expect(0);
            } else {
              this.expect(47);
            }
          }

          var result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);

          if (bracket) {
            this.expect(3);
          } else {
            this.expect(48);
          }

          return result;
        }
      }, {
        key: "tsParseImportType",
        value: function tsParseImportType() {
          var node = this.startNode();
          this.expect(83);
          this.expect(10);

          if (!this.match(129)) {
            this.raise(TSErrors.UnsupportedImportTypeArgument, {
              at: this.state.startLoc
            });
          }

          node.argument = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseExprAtom", this).call(this);
          this.expect(11);

          if (this.eat(16)) {
            node.qualifier = this.tsParseEntityName();
          }

          if (this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSImportType");
        }
      }, {
        key: "tsParseEntityName",
        value: function tsParseEntityName() {
          var allowReservedWords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          var entity = this.parseIdentifier(allowReservedWords);

          while (this.eat(16)) {
            var node = this.startNodeAtNode(entity);
            node.left = entity;
            node.right = this.parseIdentifier(allowReservedWords);
            entity = this.finishNode(node, "TSQualifiedName");
          }

          return entity;
        }
      }, {
        key: "tsParseTypeReference",
        value: function tsParseTypeReference() {
          var node = this.startNode();
          node.typeName = this.tsParseEntityName();

          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSTypeReference");
        }
      }, {
        key: "tsParseThisTypePredicate",
        value: function tsParseThisTypePredicate(lhs) {
          this.next();
          var node = this.startNodeAtNode(lhs);
          node.parameterName = lhs;
          node.typeAnnotation = this.tsParseTypeAnnotation(false);
          node.asserts = false;
          return this.finishNode(node, "TSTypePredicate");
        }
      }, {
        key: "tsParseThisTypeNode",
        value: function tsParseThisTypeNode() {
          var node = this.startNode();
          this.next();
          return this.finishNode(node, "TSThisType");
        }
      }, {
        key: "tsParseTypeQuery",
        value: function tsParseTypeQuery() {
          var node = this.startNode();
          this.expect(87);

          if (this.match(83)) {
            node.exprName = this.tsParseImportType();
          } else {
            node.exprName = this.tsParseEntityName();
          }

          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSTypeQuery");
        }
      }, {
        key: "tsParseInOutModifiers",
        value: function tsParseInOutModifiers(node) {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["in", "out"],
            disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
          });
        }
      }, {
        key: "tsParseNoneModifiers",
        value: function tsParseNoneModifiers(node) {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: [],
            disallowedModifiers: ["in", "out"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
        }
      }, {
        key: "tsParseTypeParameter",
        value: function tsParseTypeParameter() {
          var parseModifiers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tsParseNoneModifiers.bind(this);
          var node = this.startNode();
          parseModifiers(node);
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsEatThenParseType(81);
          node["default"] = this.tsEatThenParseType(29);
          return this.finishNode(node, "TSTypeParameter");
        }
      }, {
        key: "tsTryParseTypeParameters",
        value: function tsTryParseTypeParameters(parseModifiers) {
          if (this.match(47)) {
            return this.tsParseTypeParameters(parseModifiers);
          }
        }
      }, {
        key: "tsParseTypeParameters",
        value: function tsParseTypeParameters(parseModifiers) {
          var node = this.startNode();

          if (this.match(47) || this.match(138)) {
            this.next();
          } else {
            this.unexpected();
          }

          var refTrailingCommaPos = {
            value: -1
          };
          node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);

          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeParameters, {
              at: node
            });
          }

          if (refTrailingCommaPos.value !== -1) {
            this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
          }

          return this.finishNode(node, "TSTypeParameterDeclaration");
        }
      }, {
        key: "tsTryNextParseConstantContext",
        value: function tsTryNextParseConstantContext() {
          if (this.lookahead().type !== 75) return null;
          this.next();
          var typeReference = this.tsParseTypeReference();

          if (typeReference.typeParameters) {
            this.raise(TSErrors.CannotFindName, {
              at: typeReference.typeName,
              name: "const"
            });
          }

          return typeReference;
        }
      }, {
        key: "tsFillSignature",
        value: function tsFillSignature(returnToken, signature) {
          var returnTokenRequired = returnToken === 19;
          var paramsKey = "parameters";
          var returnTypeKey = "typeAnnotation";
          signature.typeParameters = this.tsTryParseTypeParameters();
          this.expect(10);
          signature[paramsKey] = this.tsParseBindingListForSignature();

          if (returnTokenRequired) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          } else if (this.match(returnToken)) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          }
        }
      }, {
        key: "tsParseBindingListForSignature",
        value: function tsParseBindingListForSignature() {
          var _this26 = this;

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseBindingList", this).call(this, 11, 41).map(function (pattern) {
            if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
              _this26.raise(TSErrors.UnsupportedSignatureParameterKind, {
                at: pattern,
                type: pattern.type
              });
            }

            return pattern;
          });
        }
      }, {
        key: "tsParseTypeMemberSemicolon",
        value: function tsParseTypeMemberSemicolon() {
          if (!this.eat(12) && !this.isLineTerminator()) {
            this.expect(13);
          }
        }
      }, {
        key: "tsParseSignatureMember",
        value: function tsParseSignatureMember(kind, node) {
          this.tsFillSignature(14, node);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, kind);
        }
      }, {
        key: "tsIsUnambiguouslyIndexSignature",
        value: function tsIsUnambiguouslyIndexSignature() {
          this.next();

          if (tokenIsIdentifier(this.state.type)) {
            this.next();
            return this.match(14);
          }

          return false;
        }
      }, {
        key: "tsTryParseIndexSignature",
        value: function tsTryParseIndexSignature(node) {
          if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return undefined;
          }

          this.expect(0);
          var id = this.parseIdentifier();
          id.typeAnnotation = this.tsParseTypeAnnotation();
          this.resetEndLocation(id);
          this.expect(3);
          node.parameters = [id];
          var type = this.tsTryParseTypeAnnotation();
          if (type) node.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, "TSIndexSignature");
        }
      }, {
        key: "tsParsePropertyOrMethodSignature",
        value: function tsParsePropertyOrMethodSignature(node, readonly) {
          if (this.eat(17)) node.optional = true;
          var nodeAny = node;

          if (this.match(10) || this.match(47)) {
            if (readonly) {
              this.raise(TSErrors.ReadonlyForMethodSignature, {
                at: node
              });
            }

            var method = nodeAny;

            if (method.kind && this.match(47)) {
              this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
                at: this.state.curPosition()
              });
            }

            this.tsFillSignature(14, method);
            this.tsParseTypeMemberSemicolon();
            var paramsKey = "parameters";
            var returnTypeKey = "typeAnnotation";

            if (method.kind === "get") {
              if (method[paramsKey].length > 0) {
                this.raise(Errors.BadGetterArity, {
                  at: this.state.curPosition()
                });

                if (this.isThisParam(method[paramsKey][0])) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
            } else if (method.kind === "set") {
              if (method[paramsKey].length !== 1) {
                this.raise(Errors.BadSetterArity, {
                  at: this.state.curPosition()
                });
              } else {
                var firstParameter = method[paramsKey][0];

                if (this.isThisParam(firstParameter)) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }

                if (firstParameter.type === "Identifier" && firstParameter.optional) {
                  this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                    at: this.state.curPosition()
                  });
                }

                if (firstParameter.type === "RestElement") {
                  this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                    at: this.state.curPosition()
                  });
                }
              }

              if (method[returnTypeKey]) {
                this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                  at: method[returnTypeKey]
                });
              }
            } else {
              method.kind = "method";
            }

            return this.finishNode(method, "TSMethodSignature");
          } else {
            var property = nodeAny;
            if (readonly) property.readonly = true;
            var type = this.tsTryParseTypeAnnotation();
            if (type) property.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, "TSPropertySignature");
          }
        }
      }, {
        key: "tsParseTypeMember",
        value: function tsParseTypeMember() {
          var node = this.startNode();

          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
          }

          if (this.match(77)) {
            var id = this.startNode();
            this.next();

            if (this.match(10) || this.match(47)) {
              return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
            } else {
              node.key = this.createIdentifier(id, "new");
              return this.tsParsePropertyOrMethodSignature(node, false);
            }
          }

          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["readonly"],
            disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
          });
          var idx = this.tsTryParseIndexSignature(node);

          if (idx) {
            return idx;
          }

          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parsePropertyName", this).call(this, node);

          if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
            node.kind = node.key.name;

            _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parsePropertyName", this).call(this, node);
          }

          return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
        }
      }, {
        key: "tsParseTypeLiteral",
        value: function tsParseTypeLiteral() {
          var node = this.startNode();
          node.members = this.tsParseObjectTypeMembers();
          return this.finishNode(node, "TSTypeLiteral");
        }
      }, {
        key: "tsParseObjectTypeMembers",
        value: function tsParseObjectTypeMembers() {
          this.expect(5);
          var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          this.expect(8);
          return members;
        }
      }, {
        key: "tsIsStartOfMappedType",
        value: function tsIsStartOfMappedType() {
          this.next();

          if (this.eat(53)) {
            return this.isContextual(118);
          }

          if (this.isContextual(118)) {
            this.next();
          }

          if (!this.match(0)) {
            return false;
          }

          this.next();

          if (!this.tsIsIdentifier()) {
            return false;
          }

          this.next();
          return this.match(58);
        }
      }, {
        key: "tsParseMappedTypeParameter",
        value: function tsParseMappedTypeParameter() {
          var node = this.startNode();
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsExpectThenParseType(58);
          return this.finishNode(node, "TSTypeParameter");
        }
      }, {
        key: "tsParseMappedType",
        value: function tsParseMappedType() {
          var node = this.startNode();
          this.expect(5);

          if (this.match(53)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual(118);
          } else if (this.eatContextual(118)) {
            node.readonly = true;
          }

          this.expect(0);
          node.typeParameter = this.tsParseMappedTypeParameter();
          node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
          this.expect(3);

          if (this.match(53)) {
            node.optional = this.state.value;
            this.next();
            this.expect(17);
          } else if (this.eat(17)) {
            node.optional = true;
          }

          node.typeAnnotation = this.tsTryParseType();
          this.semicolon();
          this.expect(8);
          return this.finishNode(node, "TSMappedType");
        }
      }, {
        key: "tsParseTupleType",
        value: function tsParseTupleType() {
          var _this27 = this;

          var node = this.startNode();
          node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
          var seenOptionalElement = false;
          var labeledElements = null;
          node.elementTypes.forEach(function (elementNode) {
            var _labeledElements;

            var _elementNode = elementNode,
                type = _elementNode.type;

            if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
              _this27.raise(TSErrors.OptionalTypeBeforeRequired, {
                at: elementNode
              });
            }

            seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
            var checkType = type;

            if (type === "TSRestType") {
              elementNode = elementNode.typeAnnotation;
              checkType = elementNode.type;
            }

            var isLabeled = checkType === "TSNamedTupleMember";
            (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;

            if (labeledElements !== isLabeled) {
              _this27.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
                at: elementNode
              });
            }
          });
          return this.finishNode(node, "TSTupleType");
        }
      }, {
        key: "tsParseTupleElementType",
        value: function tsParseTupleElementType() {
          var _this$state2 = this.state,
              startPos = _this$state2.start,
              startLoc = _this$state2.startLoc;
          var rest = this.eat(21);
          var type = this.tsParseType();
          var optional = this.eat(17);
          var labeled = this.eat(14);

          if (labeled) {
            var labeledNode = this.startNodeAtNode(type);
            labeledNode.optional = optional;

            if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
              labeledNode.label = type.typeName;
            } else {
              this.raise(TSErrors.InvalidTupleMemberLabel, {
                at: type
              });
              labeledNode.label = type;
            }

            labeledNode.elementType = this.tsParseType();
            type = this.finishNode(labeledNode, "TSNamedTupleMember");
          } else if (optional) {
            var optionalTypeNode = this.startNodeAtNode(type);
            optionalTypeNode.typeAnnotation = type;
            type = this.finishNode(optionalTypeNode, "TSOptionalType");
          }

          if (rest) {
            var restNode = this.startNodeAt(startPos, startLoc);
            restNode.typeAnnotation = type;
            type = this.finishNode(restNode, "TSRestType");
          }

          return type;
        }
      }, {
        key: "tsParseParenthesizedType",
        value: function tsParseParenthesizedType() {
          var node = this.startNode();
          this.expect(10);
          node.typeAnnotation = this.tsParseType();
          this.expect(11);
          return this.finishNode(node, "TSParenthesizedType");
        }
      }, {
        key: "tsParseFunctionOrConstructorType",
        value: function tsParseFunctionOrConstructorType(type, _abstract) {
          var _this28 = this;

          var node = this.startNode();

          if (type === "TSConstructorType") {
            node["abstract"] = !!_abstract;
            if (_abstract) this.next();
            this.next();
          }

          this.tsInAllowConditionalTypesContext(function () {
            return _this28.tsFillSignature(19, node);
          });
          return this.finishNode(node, type);
        }
      }, {
        key: "tsParseLiteralTypeNode",
        value: function tsParseLiteralTypeNode() {
          var _this29 = this;

          var node = this.startNode();

          node.literal = function () {
            switch (_this29.state.type) {
              case 130:
              case 131:
              case 129:
              case 85:
              case 86:
                return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseExprAtom", _this29).call(_this29);

              default:
                throw _this29.unexpected();
            }
          }();

          return this.finishNode(node, "TSLiteralType");
        }
      }, {
        key: "tsParseTemplateLiteralType",
        value: function tsParseTemplateLiteralType() {
          var node = this.startNode();
          node.literal = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseTemplate", this).call(this, false);
          return this.finishNode(node, "TSLiteralType");
        }
      }, {
        key: "parseTemplateSubstitution",
        value: function parseTemplateSubstitution() {
          if (this.state.inType) return this.tsParseType();
          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseTemplateSubstitution", this).call(this);
        }
      }, {
        key: "tsParseThisTypeOrThisTypePredicate",
        value: function tsParseThisTypeOrThisTypePredicate() {
          var thisKeyword = this.tsParseThisTypeNode();

          if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        }
      }, {
        key: "tsParseNonArrayType",
        value: function tsParseNonArrayType() {
          switch (this.state.type) {
            case 129:
            case 130:
            case 131:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode();

            case 53:
              if (this.state.value === "-") {
                var node = this.startNode();
                var nextToken = this.lookahead();

                if (nextToken.type !== 130 && nextToken.type !== 131) {
                  throw this.unexpected();
                }

                node.literal = this.parseMaybeUnary();
                return this.finishNode(node, "TSLiteralType");
              }

              break;

            case 78:
              return this.tsParseThisTypeOrThisTypePredicate();

            case 87:
              return this.tsParseTypeQuery();

            case 83:
              return this.tsParseImportType();

            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

            case 0:
              return this.tsParseTupleType();

            case 10:
              return this.tsParseParenthesizedType();

            case 25:
            case 24:
              return this.tsParseTemplateLiteralType();

            default:
              {
                var type = this.state.type;

                if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                  var nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

                  if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {
                    var _node6 = this.startNode();

                    this.next();
                    return this.finishNode(_node6, nodeType);
                  }

                  return this.tsParseTypeReference();
                }
              }
          }

          throw this.unexpected();
        }
      }, {
        key: "tsParseArrayTypeOrHigher",
        value: function tsParseArrayTypeOrHigher() {
          var type = this.tsParseNonArrayType();

          while (!this.hasPrecedingLineBreak() && this.eat(0)) {
            if (this.match(3)) {
              var node = this.startNodeAtNode(type);
              node.elementType = type;
              this.expect(3);
              type = this.finishNode(node, "TSArrayType");
            } else {
              var _node7 = this.startNodeAtNode(type);

              _node7.objectType = type;
              _node7.indexType = this.tsParseType();
              this.expect(3);
              type = this.finishNode(_node7, "TSIndexedAccessType");
            }
          }

          return type;
        }
      }, {
        key: "tsParseTypeOperator",
        value: function tsParseTypeOperator() {
          var node = this.startNode();
          var operator = this.state.value;
          this.next();
          node.operator = operator;
          node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

          if (operator === "readonly") {
            this.tsCheckTypeAnnotationForReadOnly(node);
          }

          return this.finishNode(node, "TSTypeOperator");
        }
      }, {
        key: "tsCheckTypeAnnotationForReadOnly",
        value: function tsCheckTypeAnnotationForReadOnly(node) {
          switch (node.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;

            default:
              this.raise(TSErrors.UnexpectedReadonly, {
                at: node
              });
          }
        }
      }, {
        key: "tsParseInferType",
        value: function tsParseInferType() {
          var _this30 = this;

          var node = this.startNode();
          this.expectContextual(112);
          var typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsTryParse(function () {
            return _this30.tsParseConstraintForInferType();
          });
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
          return this.finishNode(node, "TSInferType");
        }
      }, {
        key: "tsParseConstraintForInferType",
        value: function tsParseConstraintForInferType() {
          var _this31 = this;

          if (this.eat(81)) {
            var constraint = this.tsInDisallowConditionalTypesContext(function () {
              return _this31.tsParseType();
            });

            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
              return constraint;
            }
          }
        }
      }, {
        key: "tsParseTypeOperatorOrHigher",
        value: function tsParseTypeOperatorOrHigher() {
          var _this32 = this;

          var isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
          return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(function () {
            return _this32.tsParseArrayTypeOrHigher();
          });
        }
      }, {
        key: "tsParseUnionOrIntersectionType",
        value: function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
          var node = this.startNode();
          var hasLeadingOperator = this.eat(operator);
          var types = [];

          do {
            types.push(parseConstituentType());
          } while (this.eat(operator));

          if (types.length === 1 && !hasLeadingOperator) {
            return types[0];
          }

          node.types = types;
          return this.finishNode(node, kind);
        }
      }, {
        key: "tsParseIntersectionTypeOrHigher",
        value: function tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
        }
      }, {
        key: "tsParseUnionTypeOrHigher",
        value: function tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
        }
      }, {
        key: "tsIsStartOfFunctionType",
        value: function tsIsStartOfFunctionType() {
          if (this.match(47)) {
            return true;
          }

          return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
      }, {
        key: "tsSkipParameterStart",
        value: function tsSkipParameterStart() {
          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
            this.next();
            return true;
          }

          if (this.match(5)) {
            var errors = this.state.errors;
            var previousErrorCount = errors.length;

            try {
              this.parseObjectLike(8, true);
              return errors.length === previousErrorCount;
            } catch (_unused) {
              return false;
            }
          }

          if (this.match(0)) {
            this.next();
            var _errors = this.state.errors;
            var _previousErrorCount = _errors.length;

            try {
              _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseBindingList", this).call(this, 3, 93, true);

              return _errors.length === _previousErrorCount;
            } catch (_unused2) {
              return false;
            }
          }

          return false;
        }
      }, {
        key: "tsIsUnambiguouslyStartOfFunctionType",
        value: function tsIsUnambiguouslyStartOfFunctionType() {
          this.next();

          if (this.match(11) || this.match(21)) {
            return true;
          }

          if (this.tsSkipParameterStart()) {
            if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
              return true;
            }

            if (this.match(11)) {
              this.next();

              if (this.match(19)) {
                return true;
              }
            }
          }

          return false;
        }
      }, {
        key: "tsParseTypeOrTypePredicateAnnotation",
        value: function tsParseTypeOrTypePredicateAnnotation(returnToken) {
          var _this33 = this;

          return this.tsInType(function () {
            var t = _this33.startNode();

            _this33.expect(returnToken);

            var node = _this33.startNode();

            var asserts = !!_this33.tsTryParse(_this33.tsParseTypePredicateAsserts.bind(_this33));

            if (asserts && _this33.match(78)) {
              var thisTypePredicate = _this33.tsParseThisTypeOrThisTypePredicate();

              if (thisTypePredicate.type === "TSThisType") {
                node.parameterName = thisTypePredicate;
                node.asserts = true;
                node.typeAnnotation = null;
                thisTypePredicate = _this33.finishNode(node, "TSTypePredicate");
              } else {
                _this33.resetStartLocationFromNode(thisTypePredicate, node);

                thisTypePredicate.asserts = true;
              }

              t.typeAnnotation = thisTypePredicate;
              return _this33.finishNode(t, "TSTypeAnnotation");
            }

            var typePredicateVariable = _this33.tsIsIdentifier() && _this33.tsTryParse(_this33.tsParseTypePredicatePrefix.bind(_this33));

            if (!typePredicateVariable) {
              if (!asserts) {
                return _this33.tsParseTypeAnnotation(false, t);
              }

              node.parameterName = _this33.parseIdentifier();
              node.asserts = asserts;
              node.typeAnnotation = null;
              t.typeAnnotation = _this33.finishNode(node, "TSTypePredicate");
              return _this33.finishNode(t, "TSTypeAnnotation");
            }

            var type = _this33.tsParseTypeAnnotation(false);

            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t.typeAnnotation = _this33.finishNode(node, "TSTypePredicate");
            return _this33.finishNode(t, "TSTypeAnnotation");
          });
        }
      }, {
        key: "tsTryParseTypeOrTypePredicateAnnotation",
        value: function tsTryParseTypeOrTypePredicateAnnotation() {
          return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : undefined;
        }
      }, {
        key: "tsTryParseTypeAnnotation",
        value: function tsTryParseTypeAnnotation() {
          return this.match(14) ? this.tsParseTypeAnnotation() : undefined;
        }
      }, {
        key: "tsTryParseType",
        value: function tsTryParseType() {
          return this.tsEatThenParseType(14);
        }
      }, {
        key: "tsParseTypePredicatePrefix",
        value: function tsParseTypePredicatePrefix() {
          var id = this.parseIdentifier();

          if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
          }
        }
      }, {
        key: "tsParseTypePredicateAsserts",
        value: function tsParseTypePredicateAsserts() {
          if (this.state.type !== 106) {
            return false;
          }

          var containsEsc = this.state.containsEsc;
          this.next();

          if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
            return false;
          }

          if (containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.lastTokStartLoc,
              reservedWord: "asserts"
            });
          }

          return true;
        }
      }, {
        key: "tsParseTypeAnnotation",
        value: function tsParseTypeAnnotation() {
          var _this34 = this;

          var eatColon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.startNode();
          this.tsInType(function () {
            if (eatColon) _this34.expect(14);
            t.typeAnnotation = _this34.tsParseType();
          });
          return this.finishNode(t, "TSTypeAnnotation");
        }
      }, {
        key: "tsParseType",
        value: function tsParseType() {
          var _this35 = this;

          assert(this.state.inType);
          var type = this.tsParseNonConditionalType();

          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
            return type;
          }

          var node = this.startNodeAtNode(type);
          node.checkType = type;
          node.extendsType = this.tsInDisallowConditionalTypesContext(function () {
            return _this35.tsParseNonConditionalType();
          });
          this.expect(17);
          node.trueType = this.tsInAllowConditionalTypesContext(function () {
            return _this35.tsParseType();
          });
          this.expect(14);
          node.falseType = this.tsInAllowConditionalTypesContext(function () {
            return _this35.tsParseType();
          });
          return this.finishNode(node, "TSConditionalType");
        }
      }, {
        key: "isAbstractConstructorSignature",
        value: function isAbstractConstructorSignature() {
          return this.isContextual(120) && this.lookahead().type === 77;
        }
      }, {
        key: "tsParseNonConditionalType",
        value: function tsParseNonConditionalType() {
          if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType("TSFunctionType");
          }

          if (this.match(77)) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType");
          } else if (this.isAbstractConstructorSignature()) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
          }

          return this.tsParseUnionTypeOrHigher();
        }
      }, {
        key: "tsParseTypeAssertion",
        value: function tsParseTypeAssertion() {
          if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedTypeAssertion, {
              at: this.state.startLoc
            });
          }

          var node = this.startNode();

          var _const = this.tsTryNextParseConstantContext();

          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expect(48);
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        }
      }, {
        key: "tsParseHeritageClause",
        value: function tsParseHeritageClause(token) {
          var _this36 = this;

          var originalStartLoc = this.state.startLoc;
          var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", function () {
            var node = _this36.startNode();

            node.expression = _this36.tsParseEntityName();

            if (_this36.match(47)) {
              node.typeParameters = _this36.tsParseTypeArguments();
            }

            return _this36.finishNode(node, "TSExpressionWithTypeArguments");
          });

          if (!delimitedList.length) {
            this.raise(TSErrors.EmptyHeritageClauseType, {
              at: originalStartLoc,
              token: token
            });
          }

          return delimitedList;
        }
      }, {
        key: "tsParseInterfaceDeclaration",
        value: function tsParseInterfaceDeclaration(node) {
          var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          if (this.hasFollowingLineBreak()) return null;
          this.expectContextual(125);
          if (properties.declare) node.declare = true;

          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            this.checkIdentifier(node.id, BIND_TS_INTERFACE);
          } else {
            node.id = null;
            this.raise(TSErrors.MissingInterfaceName, {
              at: this.state.startLoc
            });
          }

          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));

          if (this.eat(81)) {
            node["extends"] = this.tsParseHeritageClause("extends");
          }

          var body = this.startNode();
          body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
          node.body = this.finishNode(body, "TSInterfaceBody");
          return this.finishNode(node, "TSInterfaceDeclaration");
        }
      }, {
        key: "tsParseTypeAliasDeclaration",
        value: function tsParseTypeAliasDeclaration(node) {
          var _this37 = this;

          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_TS_TYPE);
          node.typeAnnotation = this.tsInType(function () {
            node.typeParameters = _this37.tsTryParseTypeParameters(_this37.tsParseInOutModifiers.bind(_this37));

            _this37.expect(29);

            if (_this37.isContextual(111) && _this37.lookahead().type !== 16) {
              var _node8 = _this37.startNode();

              _this37.next();

              return _this37.finishNode(_node8, "TSIntrinsicKeyword");
            }

            return _this37.tsParseType();
          });
          this.semicolon();
          return this.finishNode(node, "TSTypeAliasDeclaration");
        }
      }, {
        key: "tsInNoContext",
        value: function tsInNoContext(cb) {
          var oldContext = this.state.context;
          this.state.context = [oldContext[0]];

          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        }
      }, {
        key: "tsInType",
        value: function tsInType(cb) {
          var oldInType = this.state.inType;
          this.state.inType = true;

          try {
            return cb();
          } finally {
            this.state.inType = oldInType;
          }
        }
      }, {
        key: "tsInDisallowConditionalTypesContext",
        value: function tsInDisallowConditionalTypesContext(cb) {
          var oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = true;

          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
      }, {
        key: "tsInAllowConditionalTypesContext",
        value: function tsInAllowConditionalTypesContext(cb) {
          var oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = false;

          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
      }, {
        key: "tsEatThenParseType",
        value: function tsEatThenParseType(token) {
          return !this.match(token) ? undefined : this.tsNextThenParseType();
        }
      }, {
        key: "tsExpectThenParseType",
        value: function tsExpectThenParseType(token) {
          var _this38 = this;

          return this.tsDoThenParseType(function () {
            return _this38.expect(token);
          });
        }
      }, {
        key: "tsNextThenParseType",
        value: function tsNextThenParseType() {
          var _this39 = this;

          return this.tsDoThenParseType(function () {
            return _this39.next();
          });
        }
      }, {
        key: "tsDoThenParseType",
        value: function tsDoThenParseType(cb) {
          var _this40 = this;

          return this.tsInType(function () {
            cb();
            return _this40.tsParseType();
          });
        }
      }, {
        key: "tsParseEnumMember",
        value: function tsParseEnumMember() {
          var node = this.startNode();
          node.id = this.match(129) ? _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseStringLiteral", this).call(this, this.state.value) : this.parseIdentifier(true);

          if (this.eat(29)) {
            node.initializer = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseMaybeAssignAllowIn", this).call(this);
          }

          return this.finishNode(node, "TSEnumMember");
        }
      }, {
        key: "tsParseEnumDeclaration",
        value: function tsParseEnumDeclaration(node) {
          var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          if (properties["const"]) node["const"] = true;
          if (properties.declare) node.declare = true;
          this.expectContextual(122);
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, node["const"] ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
          this.expect(5);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
          return this.finishNode(node, "TSEnumDeclaration");
        }
      }, {
        key: "tsParseModuleBlock",
        value: function tsParseModuleBlock() {
          var node = this.startNode();
          this.scope.enter(SCOPE_OTHER);
          this.expect(5);

          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseBlockOrModuleBlockBody", this).call(this, node.body = [], undefined, true, 8);

          this.scope.exit();
          return this.finishNode(node, "TSModuleBlock");
        }
      }, {
        key: "tsParseModuleOrNamespaceDeclaration",
        value: function tsParseModuleOrNamespaceDeclaration(node) {
          var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          node.id = this.parseIdentifier();

          if (!nested) {
            this.checkIdentifier(node.id, BIND_TS_NAMESPACE);
          }

          if (this.eat(16)) {
            var inner = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(inner, true);
            node.body = inner;
          } else {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          }

          return this.finishNode(node, "TSModuleDeclaration");
        }
      }, {
        key: "tsParseAmbientExternalModuleDeclaration",
        value: function tsParseAmbientExternalModuleDeclaration(node) {
          if (this.isContextual(109)) {
            node.global = true;
            node.id = this.parseIdentifier();
          } else if (this.match(129)) {
            node.id = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseStringLiteral", this).call(this, this.state.value);
          } else {
            this.unexpected();
          }

          if (this.match(5)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          } else {
            this.semicolon();
          }

          return this.finishNode(node, "TSModuleDeclaration");
        }
      }, {
        key: "tsParseImportEqualsDeclaration",
        value: function tsParseImportEqualsDeclaration(node, isExport) {
          node.isExport = isExport || false;
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_FLAGS_TS_IMPORT);
          this.expect(29);
          var moduleReference = this.tsParseModuleReference();

          if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
            this.raise(TSErrors.ImportAliasHasImportType, {
              at: moduleReference
            });
          }

          node.moduleReference = moduleReference;
          this.semicolon();
          return this.finishNode(node, "TSImportEqualsDeclaration");
        }
      }, {
        key: "tsIsExternalModuleReference",
        value: function tsIsExternalModuleReference() {
          return this.isContextual(116) && this.lookaheadCharCode() === 40;
        }
      }, {
        key: "tsParseModuleReference",
        value: function tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
      }, {
        key: "tsParseExternalModuleReference",
        value: function tsParseExternalModuleReference() {
          var node = this.startNode();
          this.expectContextual(116);
          this.expect(10);

          if (!this.match(129)) {
            throw this.unexpected();
          }

          node.expression = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseExprAtom", this).call(this);
          this.expect(11);
          return this.finishNode(node, "TSExternalModuleReference");
        }
      }, {
        key: "tsLookAhead",
        value: function tsLookAhead(f) {
          var state = this.state.clone();
          var res = f();
          this.state = state;
          return res;
        }
      }, {
        key: "tsTryParseAndCatch",
        value: function tsTryParseAndCatch(f) {
          var result = this.tryParse(function (abort) {
            return f() || abort();
          });
          if (result.aborted || !result.node) return undefined;
          if (result.error) this.state = result.failState;
          return result.node;
        }
      }, {
        key: "tsTryParse",
        value: function tsTryParse(f) {
          var state = this.state.clone();
          var result = f();

          if (result !== undefined && result !== false) {
            return result;
          } else {
            this.state = state;
            return undefined;
          }
        }
      }, {
        key: "tsTryParseDeclare",
        value: function tsTryParseDeclare(nany) {
          var _this41 = this;

          if (this.isLineTerminator()) {
            return;
          }

          var starttype = this.state.type;
          var kind;

          if (this.isContextual(99)) {
            starttype = 74;
            kind = "let";
          }

          return this.tsInAmbientContext(function () {
            if (starttype === 68) {
              nany.declare = true;
              return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseFunctionStatement", _this41).call(_this41, nany, false, true);
            }

            if (starttype === 80) {
              nany.declare = true;
              return _this41.parseClass(nany, true, false);
            }

            if (starttype === 122) {
              return _this41.tsParseEnumDeclaration(nany, {
                declare: true
              });
            }

            if (starttype === 109) {
              return _this41.tsParseAmbientExternalModuleDeclaration(nany);
            }

            if (starttype === 75 || starttype === 74) {
              if (!_this41.match(75) || !_this41.isLookaheadContextual("enum")) {
                nany.declare = true;
                return _this41.parseVarStatement(nany, kind || _this41.state.value, true);
              }

              _this41.expect(75);

              return _this41.tsParseEnumDeclaration(nany, {
                "const": true,
                declare: true
              });
            }

            if (starttype === 125) {
              var result = _this41.tsParseInterfaceDeclaration(nany, {
                declare: true
              });

              if (result) return result;
            }

            if (tokenIsIdentifier(starttype)) {
              return _this41.tsParseDeclaration(nany, _this41.state.value, true);
            }
          });
        }
      }, {
        key: "tsTryParseExportDeclaration",
        value: function tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, true);
        }
      }, {
        key: "tsParseExpressionStatement",
        value: function tsParseExpressionStatement(node, expr) {
          switch (expr.name) {
            case "declare":
              {
                var declaration = this.tsTryParseDeclare(node);

                if (declaration) {
                  declaration.declare = true;
                  return declaration;
                }

                break;
              }

            case "global":
              if (this.match(5)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                var mod = node;
                mod.global = true;
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                this.prodParam.exit();
                return this.finishNode(mod, "TSModuleDeclaration");
              }

              break;

            default:
              return this.tsParseDeclaration(node, expr.name, false);
          }
        }
      }, {
        key: "tsParseDeclaration",
        value: function tsParseDeclaration(node, value, next) {
          switch (value) {
            case "abstract":
              if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                return this.tsParseAbstractDeclaration(node);
              }

              break;

            case "module":
              if (this.tsCheckLineTerminator(next)) {
                if (this.match(129)) {
                  return this.tsParseAmbientExternalModuleDeclaration(node);
                } else if (tokenIsIdentifier(this.state.type)) {
                  return this.tsParseModuleOrNamespaceDeclaration(node);
                }
              }

              break;

            case "namespace":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }

              break;

            case "type":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseTypeAliasDeclaration(node);
              }

              break;
          }
        }
      }, {
        key: "tsCheckLineTerminator",
        value: function tsCheckLineTerminator(next) {
          if (next) {
            if (this.hasFollowingLineBreak()) return false;
            this.next();
            return true;
          }

          return !this.isLineTerminator();
        }
      }, {
        key: "tsTryParseGenericAsyncArrowFunction",
        value: function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
          var _this42 = this;

          if (!this.match(47)) {
            return undefined;
          }

          var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = true;
          var res = this.tsTryParseAndCatch(function () {
            var node = _this42.startNodeAt(startPos, startLoc);

            node.typeParameters = _this42.tsParseTypeParameters();

            _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseFunctionParams", _this42).call(_this42, node);

            node.returnType = _this42.tsTryParseTypeOrTypePredicateAnnotation();

            _this42.expect(19);

            return node;
          });
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;

          if (!res) {
            return undefined;
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseArrowExpression", this).call(this, res, null, true);
        }
      }, {
        key: "tsParseTypeArgumentsInExpression",
        value: function tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() !== 47) {
            return undefined;
          }

          return this.tsParseTypeArguments();
        }
      }, {
        key: "tsParseTypeArguments",
        value: function tsParseTypeArguments() {
          var _this43 = this;

          var node = this.startNode();
          node.params = this.tsInType(function () {
            return _this43.tsInNoContext(function () {
              _this43.expect(47);

              return _this43.tsParseDelimitedList("TypeParametersOrArguments", _this43.tsParseType.bind(_this43));
            });
          });

          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeArguments, {
              at: node
            });
          }

          this.expect(48);
          return this.finishNode(node, "TSTypeParameterInstantiation");
        }
      }, {
        key: "tsIsDeclarationStart",
        value: function tsIsDeclarationStart() {
          return tokenIsTSDeclarationStart(this.state.type);
        }
      }, {
        key: "isExportDefaultSpecifier",
        value: function isExportDefaultSpecifier() {
          if (this.tsIsDeclarationStart()) return false;
          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "isExportDefaultSpecifier", this).call(this);
        }
      }, {
        key: "parseAssignableListItem",
        value: function parseAssignableListItem(allowModifiers, decorators) {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var accessibility;
          var readonly = false;
          var override = false;

          if (allowModifiers !== undefined) {
            var modified = {};
            this.tsParseModifiers({
              modified: modified,
              allowedModifiers: ["public", "private", "protected", "override", "readonly"]
            });
            accessibility = modified.accessibility;
            override = modified.override;
            readonly = modified.readonly;

            if (allowModifiers === false && (accessibility || readonly || override)) {
              this.raise(TSErrors.UnexpectedParameterModifier, {
                at: startLoc
              });
            }
          }

          var left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

          if (accessibility || readonly || override) {
            var pp = this.startNodeAt(startPos, startLoc);

            if (decorators.length) {
              pp.decorators = decorators;
            }

            if (accessibility) pp.accessibility = accessibility;
            if (readonly) pp.readonly = readonly;
            if (override) pp.override = override;

            if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
              this.raise(TSErrors.UnsupportedParameterPropertyKind, {
                at: pp
              });
            }

            pp.parameter = elt;
            return this.finishNode(pp, "TSParameterProperty");
          }

          if (decorators.length) {
            left.decorators = decorators;
          }

          return elt;
        }
      }, {
        key: "isSimpleParameter",
        value: function isSimpleParameter(node) {
          return node.type === "TSParameterProperty" && _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "isSimpleParameter", this).call(this, node.parameter) || _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "isSimpleParameter", this).call(this, node);
        }
      }, {
        key: "parseFunctionBodyAndFinish",
        value: function parseFunctionBodyAndFinish(node, type) {
          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (this.match(14)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          }

          var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;

          if (bodilessType && !this.match(5) && this.isLineTerminator()) {
            return this.finishNode(node, bodilessType);
          }

          if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
            this.raise(TSErrors.DeclareFunctionHasImplementation, {
              at: node
            });

            if (node.declare) {
              return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseFunctionBodyAndFinish", this).call(this, node, bodilessType, isMethod);
            }
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseFunctionBodyAndFinish", this).call(this, node, type, isMethod);
        }
      }, {
        key: "registerFunctionStatementId",
        value: function registerFunctionStatementId(node) {
          if (!node.body && node.id) {
            this.checkIdentifier(node.id, BIND_TS_AMBIENT);
          } else {
            _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "registerFunctionStatementId", this).call(this, node);
          }
        }
      }, {
        key: "tsCheckForInvalidTypeCasts",
        value: function tsCheckForInvalidTypeCasts(items) {
          var _this44 = this;

          items.forEach(function (node) {
            if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
              _this44.raise(TSErrors.UnexpectedTypeAnnotation, {
                at: node.typeAnnotation
              });
            }
          });
        }
      }, {
        key: "toReferencedList",
        value: function toReferencedList(exprList, isInParens) {
          this.tsCheckForInvalidTypeCasts(exprList);
          return exprList;
        }
      }, {
        key: "parseArrayLike",
        value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          var node = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseArrayLike", this).call(this, close, canBePattern, isTuple, refExpressionErrors);

          if (node.type === "ArrayExpression") {
            this.tsCheckForInvalidTypeCasts(node.elements);
          }

          return node;
        }
      }, {
        key: "parseSubscript",
        value: function parseSubscript(base, startPos, startLoc, noCalls, state) {
          var _this45 = this;

          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            this.state.canStartJSXElement = false;
            this.next();
            var nonNullExpression = this.startNodeAt(startPos, startLoc);
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, "TSNonNullExpression");
          }

          var isOptionalCall = false;

          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (noCalls) {
              state.stop = true;
              return base;
            }

            state.optionalChainMember = isOptionalCall = true;
            this.next();
          }

          if (this.match(47) || this.match(51)) {
            var missingParenErrorLoc;
            var result = this.tsTryParseAndCatch(function () {
              if (!noCalls && _this45.atPossibleAsyncArrow(base)) {
                var asyncArrowFn = _this45.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

                if (asyncArrowFn) {
                  return asyncArrowFn;
                }
              }

              var typeArguments = _this45.tsParseTypeArgumentsInExpression();

              if (!typeArguments) return;

              if (isOptionalCall && !_this45.match(10)) {
                missingParenErrorLoc = _this45.state.curPosition();
                return;
              }

              if (tokenIsTemplate(_this45.state.type)) {
                var _result = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseTaggedTemplateExpression", _this45).call(_this45, base, startPos, startLoc, state);

                _result.typeParameters = typeArguments;
                return _result;
              }

              if (!noCalls && _this45.eat(10)) {
                var _node9 = _this45.startNodeAt(startPos, startLoc);

                _node9.callee = base;
                _node9.arguments = _this45.parseCallExpressionArguments(11, false);

                _this45.tsCheckForInvalidTypeCasts(_node9.arguments);

                _node9.typeParameters = typeArguments;

                if (state.optionalChainMember) {
                  _node9.optional = isOptionalCall;
                }

                return _this45.finishCallExpression(_node9, state.optionalChainMember);
              }

              var tokenType = _this45.state.type;

              if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !_this45.hasPrecedingLineBreak()) {
                return;
              }

              var node = _this45.startNodeAt(startPos, startLoc);

              node.expression = base;
              node.typeParameters = typeArguments;
              return _this45.finishNode(node, "TSInstantiationExpression");
            });

            if (missingParenErrorLoc) {
              this.unexpected(missingParenErrorLoc, 10);
            }

            if (result) {
              if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                  at: this.state.startLoc
                });
              }

              return result;
            }
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseSubscript", this).call(this, base, startPos, startLoc, noCalls, state);
        }
      }, {
        key: "parseNewCallee",
        value: function parseNewCallee(node) {
          var _callee$extra;

          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseNewCallee", this).call(this, node);

          var callee = node.callee;

          if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
            node.typeParameters = callee.typeParameters;
            node.callee = callee.expression;
          }
        }
      }, {
        key: "parseExprOp",
        value: function parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
            var node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;

            var _const = this.tsTryNextParseConstantContext();

            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }

            this.finishNode(node, "TSAsExpression");
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseExprOp", this).call(this, left, leftStartPos, leftStartLoc, minPrec);
        }
      }, {
        key: "checkReservedWord",
        value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (!this.state.isAmbientContext) {
            _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "checkReservedWord", this).call(this, word, startLoc, checkKeywords, isBinding);
          }
        }
      }, {
        key: "checkDuplicateExports",
        value: function checkDuplicateExports() {}
      }, {
        key: "parseImport",
        value: function parseImport(node) {
          node.importKind = "value";

          if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
            var ahead = this.lookahead();

            if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
              node.importKind = "type";
              this.next();
              ahead = this.lookahead();
            }

            if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
              return this.tsParseImportEqualsDeclaration(node);
            }
          }

          var importNode = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseImport", this).call(this, node);

          if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
            this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
              at: importNode
            });
          }

          return importNode;
        }
      }, {
        key: "parseExport",
        value: function parseExport(node) {
          if (this.match(83)) {
            this.next();

            if (this.isContextual(126) && this.lookaheadCharCode() !== 61) {
              node.importKind = "type";
              this.next();
            } else {
              node.importKind = "value";
            }

            return this.tsParseImportEqualsDeclaration(node, true);
          } else if (this.eat(29)) {
            var assign = node;
            assign.expression = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseExpression", this).call(this);
            this.semicolon();
            return this.finishNode(assign, "TSExportAssignment");
          } else if (this.eatContextual(93)) {
            var decl = node;
            this.expectContextual(124);
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, "TSNamespaceExportDeclaration");
          } else {
            if (this.isContextual(126) && this.lookahead().type === 5) {
              this.next();
              node.exportKind = "type";
            } else {
              node.exportKind = "value";
            }

            return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseExport", this).call(this, node);
          }
        }
      }, {
        key: "isAbstractClass",
        value: function isAbstractClass() {
          return this.isContextual(120) && this.lookahead().type === 80;
        }
      }, {
        key: "parseExportDefaultExpression",
        value: function parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            var cls = this.startNode();
            this.next();
            cls["abstract"] = true;
            return this.parseClass(cls, true, true);
          }

          if (this.match(125)) {
            var result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result) return result;
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseExportDefaultExpression", this).call(this);
        }
      }, {
        key: "parseVarStatement",
        value: function parseVarStatement(node, kind) {
          var allowMissingInitializer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var isAmbientContext = this.state.isAmbientContext;

          var declaration = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseVarStatement", this).call(this, node, kind, allowMissingInitializer || isAmbientContext);

          if (!isAmbientContext) return declaration;
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = declaration.declarations[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var _step6$value = _step6.value,
                  id = _step6$value.id,
                  init = _step6$value.init;
              if (!init) continue;

              if (kind !== "const" || !!id.typeAnnotation) {
                this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
                  at: init
                });
              } else if (init.type !== "StringLiteral" && init.type !== "BooleanLiteral" && init.type !== "NumericLiteral" && init.type !== "BigIntLiteral" && (init.type !== "TemplateLiteral" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) {
                this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                  at: init
                });
              }
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }

          return declaration;
        }
      }, {
        key: "parseStatementContent",
        value: function parseStatementContent(context, topLevel) {
          if (this.match(75) && this.isLookaheadContextual("enum")) {
            var node = this.startNode();
            this.expect(75);
            return this.tsParseEnumDeclaration(node, {
              "const": true
            });
          }

          if (this.isContextual(122)) {
            return this.tsParseEnumDeclaration(this.startNode());
          }

          if (this.isContextual(125)) {
            var result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result) return result;
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseStatementContent", this).call(this, context, topLevel);
        }
      }, {
        key: "parseAccessModifier",
        value: function parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        }
      }, {
        key: "tsHasSomeModifiers",
        value: function tsHasSomeModifiers(member, modifiers) {
          return modifiers.some(function (modifier) {
            if (tsIsAccessModifier(modifier)) {
              return member.accessibility === modifier;
            }

            return !!member[modifier];
          });
        }
      }, {
        key: "tsIsStartOfStaticBlocks",
        value: function tsIsStartOfStaticBlocks() {
          return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
      }, {
        key: "parseClassMember",
        value: function parseClassMember(classBody, member, state) {
          var _this46 = this;

          var modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
          this.tsParseModifiers({
            modified: member,
            allowedModifiers: modifiers,
            disallowedModifiers: ["in", "out"],
            stopOnStartOfClassStaticBlock: true,
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });

          var callParseClassMemberWithIsStatic = function callParseClassMemberWithIsStatic() {
            if (_this46.tsIsStartOfStaticBlocks()) {
              _this46.next();

              _this46.next();

              if (_this46.tsHasSomeModifiers(member, modifiers)) {
                _this46.raise(TSErrors.StaticBlockCannotHaveModifier, {
                  at: _this46.state.curPosition()
                });
              }

              _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseClassStaticBlock", _this46).call(_this46, classBody, member);
            } else {
              _this46.parseClassMemberWithIsStatic(classBody, member, state, !!member["static"]);
            }
          };

          if (member.declare) {
            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
          } else {
            callParseClassMemberWithIsStatic();
          }
        }
      }, {
        key: "parseClassMemberWithIsStatic",
        value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          var idx = this.tsTryParseIndexSignature(member);

          if (idx) {
            classBody.body.push(idx);

            if (member["abstract"]) {
              this.raise(TSErrors.IndexSignatureHasAbstract, {
                at: member
              });
            }

            if (member.accessibility) {
              this.raise(TSErrors.IndexSignatureHasAccessibility, {
                at: member,
                modifier: member.accessibility
              });
            }

            if (member.declare) {
              this.raise(TSErrors.IndexSignatureHasDeclare, {
                at: member
              });
            }

            if (member.override) {
              this.raise(TSErrors.IndexSignatureHasOverride, {
                at: member
              });
            }

            return;
          }

          if (!this.state.inAbstractClass && member["abstract"]) {
            this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
              at: member
            });
          }

          if (member.override) {
            if (!state.hadSuperClass) {
              this.raise(TSErrors.OverrideNotInSubClass, {
                at: member
              });
            }
          }

          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseClassMemberWithIsStatic", this).call(this, classBody, member, state, isStatic);
        }
      }, {
        key: "parsePostMemberNameModifiers",
        value: function parsePostMemberNameModifiers(methodOrProp) {
          var optional = this.eat(17);
          if (optional) methodOrProp.optional = true;

          if (methodOrProp.readonly && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasReadonly, {
              at: methodOrProp
            });
          }

          if (methodOrProp.declare && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasDeclare, {
              at: methodOrProp
            });
          }
        }
      }, {
        key: "parseExpressionStatement",
        value: function parseExpressionStatement(node, expr) {
          var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
          return decl || _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseExpressionStatement", this).call(this, node, expr);
        }
      }, {
        key: "shouldParseExportDeclaration",
        value: function shouldParseExportDeclaration() {
          if (this.tsIsDeclarationStart()) return true;
          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "shouldParseExportDeclaration", this).call(this);
        }
      }, {
        key: "parseConditional",
        value: function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          var _this47 = this;

          if (!this.state.maybeInArrowParameters || !this.match(17)) {
            return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseConditional", this).call(this, expr, startPos, startLoc, refExpressionErrors);
          }

          var result = this.tryParse(function () {
            return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseConditional", _this47).call(_this47, expr, startPos, startLoc);
          });

          if (!result.node) {
            if (result.error) {
              _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "setOptionalParametersError", this).call(this, refExpressionErrors, result.error);
            }

            return expr;
          }

          if (result.error) this.state = result.failState;
          return result.node;
        }
      }, {
        key: "parseParenItem",
        value: function parseParenItem(node, startPos, startLoc) {
          node = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseParenItem", this).call(this, node, startPos, startLoc);

          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }

          if (this.match(14)) {
            var typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TSTypeCastExpression");
          }

          return node;
        }
      }, {
        key: "parseExportDeclaration",
        value: function parseExportDeclaration(node) {
          var _this48 = this;

          if (!this.state.isAmbientContext && this.isContextual(121)) {
            return this.tsInAmbientContext(function () {
              return _this48.parseExportDeclaration(node);
            });
          }

          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var isDeclare = this.eatContextual(121);

          if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {
            throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
              at: this.state.startLoc
            });
          }

          var isIdentifier = tokenIsIdentifier(this.state.type);

          var declaration = isIdentifier && this.tsTryParseExportDeclaration() || _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseExportDeclaration", this).call(this, node);

          if (!declaration) return null;

          if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
            node.exportKind = "type";
          }

          if (isDeclare) {
            this.resetStartLocation(declaration, startPos, startLoc);
            declaration.declare = true;
          }

          return declaration;
        }
      }, {
        key: "parseClassId",
        value: function parseClassId(node, isStatement, optionalId, bindingType) {
          if ((!isStatement || optionalId) && this.isContextual(110)) {
            return;
          }

          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseClassId", this).call(this, node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);

          var typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (typeParameters) node.typeParameters = typeParameters;
        }
      }, {
        key: "parseClassPropertyAnnotation",
        value: function parseClassPropertyAnnotation(node) {
          if (!node.optional && this.eat(35)) {
            node.definite = true;
          }

          var type = this.tsTryParseTypeAnnotation();
          if (type) node.typeAnnotation = type;
        }
      }, {
        key: "parseClassProperty",
        value: function parseClassProperty(node) {
          this.parseClassPropertyAnnotation(node);

          if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
            this.raise(TSErrors.DeclareClassFieldHasInitializer, {
              at: this.state.startLoc
            });
          }

          if (node["abstract"] && this.match(29)) {
            var key = node.key;
            this.raise(TSErrors.AbstractPropertyHasInitializer, {
              at: this.state.startLoc,
              propertyName: key.type === "Identifier" && !node.computed ? key.name : "[".concat(this.input.slice(key.start, key.end), "]")
            });
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseClassProperty", this).call(this, node);
        }
      }, {
        key: "parseClassPrivateProperty",
        value: function parseClassPrivateProperty(node) {
          if (node["abstract"]) {
            this.raise(TSErrors.PrivateElementHasAbstract, {
              at: node
            });
          }

          if (node.accessibility) {
            this.raise(TSErrors.PrivateElementHasAccessibility, {
              at: node,
              modifier: node.accessibility
            });
          }

          this.parseClassPropertyAnnotation(node);
          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseClassPrivateProperty", this).call(this, node);
        }
      }, {
        key: "pushClassMethod",
        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          var typeParameters = this.tsTryParseTypeParameters();

          if (typeParameters && isConstructor) {
            this.raise(TSErrors.ConstructorHasTypeParameters, {
              at: typeParameters
            });
          }

          var _method$declare = method.declare,
              declare = _method$declare === void 0 ? false : _method$declare,
              kind = method.kind;

          if (declare && (kind === "get" || kind === "set")) {
            this.raise(TSErrors.DeclareAccessor, {
              at: method,
              kind: kind
            });
          }

          if (typeParameters) method.typeParameters = typeParameters;

          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "pushClassMethod", this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
      }, {
        key: "pushClassPrivateMethod",
        value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) method.typeParameters = typeParameters;

          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "pushClassPrivateMethod", this).call(this, classBody, method, isGenerator, isAsync);
        }
      }, {
        key: "declareClassPrivateMethodInScope",
        value: function declareClassPrivateMethodInScope(node, kind) {
          if (node.type === "TSDeclareMethod") return;
          if (node.type === "MethodDefinition" && !node.value.body) return;

          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "declareClassPrivateMethodInScope", this).call(this, node, kind);
        }
      }, {
        key: "parseClassSuper",
        value: function parseClassSuper(node) {
          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseClassSuper", this).call(this, node);

          if (node.superClass && (this.match(47) || this.match(51))) {
            node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }

          if (this.eatContextual(110)) {
            node["implements"] = this.tsParseHeritageClause("implements");
          }
        }
      }, {
        key: "parseObjPropValue",
        value: function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) prop.typeParameters = typeParameters;
          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseObjPropValue", this).call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        }
      }, {
        key: "parseFunctionParams",
        value: function parseFunctionParams(node, allowModifiers) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) node.typeParameters = typeParameters;

          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseFunctionParams", this).call(this, node, allowModifiers);
        }
      }, {
        key: "parseVarId",
        value: function parseVarId(decl, kind) {
          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseVarId", this).call(this, decl, kind);

          if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
            decl.definite = true;
          }

          var type = this.tsTryParseTypeAnnotation();

          if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
          }
        }
      }, {
        key: "parseAsyncArrowFromCallExpression",
        value: function parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeAnnotation();
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node, call);
        }
      }, {
        key: "parseMaybeAssign",
        value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _this49 = this;

          var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;

          var state;
          var jsx;
          var typeCast;

          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            state = this.state.clone();
            jsx = this.tryParse(function () {
              return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseMaybeAssign", _this49).call(_this49, refExpressionErrors, afterLeftParse);
            }, state);
            if (!jsx.error) return jsx.node;
            var context = this.state.context;
            var currentContext = context[context.length - 1];

            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context.pop();
            }
          }

          if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {
            return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseMaybeAssign", this).call(this, refExpressionErrors, afterLeftParse);
          }

          if (!state || state === this.state) state = this.state.clone();
          var typeParameters;
          var arrow = this.tryParse(function (abort) {
            var _expr$extra, _typeParameters;

            typeParameters = _this49.tsParseTypeParameters();

            var expr = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseMaybeAssign", _this49).call(_this49, refExpressionErrors, afterLeftParse);

            if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
              abort();
            }

            if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
              _this49.resetStartLocationFromNode(expr, typeParameters);
            }

            expr.typeParameters = typeParameters;
            return expr;
          }, state);

          if (!arrow.error && !arrow.aborted) {
            if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }

          if (!jsx) {
            assert(!this.hasPlugin("jsx"));
            typeCast = this.tryParse(function () {
              return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseMaybeAssign", _this49).call(_this49, refExpressionErrors, afterLeftParse);
            }, state);
            if (!typeCast.error) return typeCast.node;
          }

          if ((_jsx2 = jsx) != null && _jsx2.node) {
            this.state = jsx.failState;
            return jsx.node;
          }

          if (arrow.node) {
            this.state = arrow.failState;
            if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }

          if ((_typeCast = typeCast) != null && _typeCast.node) {
            this.state = typeCast.failState;
            return typeCast.node;
          }

          if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;
          throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
        }
      }, {
        key: "reportReservedArrowTypeParam",
        value: function reportReservedArrowTypeParam(node) {
          var _node$extra;

          if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedArrowTypeParam, {
              at: node
            });
          }
        }
      }, {
        key: "parseMaybeUnary",
        value: function parseMaybeUnary(refExpressionErrors, sawUnary) {
          if (!this.hasPlugin("jsx") && this.match(47)) {
            return this.tsParseTypeAssertion();
          } else {
            return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseMaybeUnary", this).call(this, refExpressionErrors, sawUnary);
          }
        }
      }, {
        key: "parseArrow",
        value: function parseArrow(node) {
          var _this50 = this;

          if (this.match(14)) {
            var result = this.tryParse(function (abort) {
              var returnType = _this50.tsParseTypeOrTypePredicateAnnotation(14);

              if (_this50.canInsertSemicolon() || !_this50.match(19)) abort();
              return returnType;
            });
            if (result.aborted) return;

            if (!result.thrown) {
              if (result.error) this.state = result.failState;
              node.returnType = result.node;
            }
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseArrow", this).call(this, node);
        }
      }, {
        key: "parseAssignableListItemTypes",
        value: function parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
              this.raise(TSErrors.PatternIsOptional, {
                at: param
              });
            }

            param.optional = true;
          }

          var type = this.tsTryParseTypeAnnotation();
          if (type) param.typeAnnotation = type;
          this.resetEndLocation(param);
          return param;
        }
      }, {
        key: "isAssignable",
        value: function isAssignable(node, isBinding) {
          switch (node.type) {
            case "TSTypeCastExpression":
              return this.isAssignable(node.expression, isBinding);

            case "TSParameterProperty":
              return true;

            default:
              return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "isAssignable", this).call(this, node, isBinding);
          }
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node) {
          var isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          switch (node.type) {
            case "ParenthesizedExpression":
              this.toAssignableParenthesizedExpression(node, isLHS);
              break;

            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              if (isLHS) {
                this.expressionScope.recordArrowParemeterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              } else {
                this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              }

              this.toAssignable(node.expression, isLHS);
              break;

            case "AssignmentExpression":
              if (!isLHS && node.left.type === "TSTypeCastExpression") {
                node.left = this.typeCastToParameter(node.left);
              }

            default:
              _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);

          }
        }
      }, {
        key: "toAssignableParenthesizedExpression",
        value: function toAssignableParenthesizedExpression(node, isLHS) {
          switch (node.expression.type) {
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isLHS);
              break;

            default:
              _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);

          }
        }
      }, {
        key: "checkToRestConversion",
        value: function checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "TSAsExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              this.checkToRestConversion(node.expression, false);
              break;

            default:
              _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "checkToRestConversion", this).call(this, node, allowPattern);

          }
        }
      }, {
        key: "isValidLVal",
        value: function isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn$1({
            TSTypeCastExpression: true,
            TSParameterProperty: "parameter",
            TSNonNullExpression: "expression",
            TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
            TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true]
          }, type) || _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "isValidLVal", this).call(this, type, isUnparenthesizedInAssign, binding);
        }
      }, {
        key: "parseBindingAtom",
        value: function parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);

            default:
              return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseBindingAtom", this).call(this);
          }
        }
      }, {
        key: "parseMaybeDecoratorArguments",
        value: function parseMaybeDecoratorArguments(expr) {
          if (this.match(47) || this.match(51)) {
            var typeArguments = this.tsParseTypeArgumentsInExpression();

            if (this.match(10)) {
              var call = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);

              call.typeParameters = typeArguments;
              return call;
            }

            this.unexpected(null, 10);
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);
        }
      }, {
        key: "checkCommaAfterRest",
        value: function checkCommaAfterRest(close) {
          if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
            this.next();
            return false;
          } else {
            return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "checkCommaAfterRest", this).call(this, close);
          }
        }
      }, {
        key: "isClassMethod",
        value: function isClassMethod() {
          return this.match(47) || _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "isClassMethod", this).call(this);
        }
      }, {
        key: "isClassProperty",
        value: function isClassProperty() {
          return this.match(35) || this.match(14) || _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "isClassProperty", this).call(this);
        }
      }, {
        key: "parseMaybeDefault",
        value: function parseMaybeDefault(startPos, startLoc, left) {
          var node = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseMaybeDefault", this).call(this, startPos, startLoc, left);

          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(TSErrors.TypeAnnotationAfterAssign, {
              at: node.typeAnnotation
            });
          }

          return node;
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          if (this.state.inType) {
            if (code === 62) {
              return this.finishOp(48, 1);
            }

            if (code === 60) {
              return this.finishOp(47, 1);
            }
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "getTokenFromCode", this).call(this, code);
        }
      }, {
        key: "reScan_lt_gt",
        value: function reScan_lt_gt() {
          var type = this.state.type;

          if (type === 47) {
            this.state.pos -= 1;
            this.readToken_lt();
          } else if (type === 48) {
            this.state.pos -= 1;
            this.readToken_gt();
          }
        }
      }, {
        key: "reScan_lt",
        value: function reScan_lt() {
          var type = this.state.type;

          if (type === 51) {
            this.state.pos -= 2;
            this.finishOp(47, 1);
            return 47;
          }

          return type;
        }
      }, {
        key: "toAssignableList",
        value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];

            if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }

          _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "toAssignableList", this).call(this, exprList, trailingCommaLoc, isLHS);
        }
      }, {
        key: "typeCastToParameter",
        value: function typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
      }, {
        key: "shouldParseArrow",
        value: function shouldParseArrow(params) {
          var _this51 = this;

          if (this.match(14)) {
            return params.every(function (expr) {
              return _this51.isAssignable(expr, true);
            });
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "shouldParseArrow", this).call(this, params);
        }
      }, {
        key: "shouldParseAsyncArrow",
        value: function shouldParseAsyncArrow() {
          return this.match(14) || _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "shouldParseAsyncArrow", this).call(this);
        }
      }, {
        key: "canHaveLeadingDecorator",
        value: function canHaveLeadingDecorator() {
          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "canHaveLeadingDecorator", this).call(this) || this.isAbstractClass();
        }
      }, {
        key: "jsxParseOpeningElementAfterName",
        value: function jsxParseOpeningElementAfterName(node) {
          var _this52 = this;

          if (this.match(47) || this.match(51)) {
            var typeArguments = this.tsTryParseAndCatch(function () {
              return _this52.tsParseTypeArgumentsInExpression();
            });
            if (typeArguments) node.typeParameters = typeArguments;
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "jsxParseOpeningElementAfterName", this).call(this, node);
        }
      }, {
        key: "getGetterSetterExpectedParamCount",
        value: function getGetterSetterExpectedParamCount(method) {
          var baseCount = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "getGetterSetterExpectedParamCount", this).call(this, method);

          var params = this.getObjectOrClassMethodParams(method);
          var firstParam = params[0];
          var hasContextParam = firstParam && this.isThisParam(firstParam);
          return hasContextParam ? baseCount + 1 : baseCount;
        }
      }, {
        key: "parseCatchClauseParam",
        value: function parseCatchClauseParam() {
          var param = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseCatchClauseParam", this).call(this);

          var type = this.tsTryParseTypeAnnotation();

          if (type) {
            param.typeAnnotation = type;
            this.resetEndLocation(param);
          }

          return param;
        }
      }, {
        key: "tsInAmbientContext",
        value: function tsInAmbientContext(cb) {
          var oldIsAmbientContext = this.state.isAmbientContext;
          this.state.isAmbientContext = true;

          try {
            return cb();
          } finally {
            this.state.isAmbientContext = oldIsAmbientContext;
          }
        }
      }, {
        key: "parseClass",
        value: function parseClass(node, isStatement, optionalId) {
          var oldInAbstractClass = this.state.inAbstractClass;
          this.state.inAbstractClass = !!node["abstract"];

          try {
            return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseClass", this).call(this, node, isStatement, optionalId);
          } finally {
            this.state.inAbstractClass = oldInAbstractClass;
          }
        }
      }, {
        key: "tsParseAbstractDeclaration",
        value: function tsParseAbstractDeclaration(node) {
          if (this.match(80)) {
            node["abstract"] = true;
            return this.parseClass(node, true, false);
          } else if (this.isContextual(125)) {
            if (!this.hasFollowingLineBreak()) {
              node["abstract"] = true;
              this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
                at: node
              });
              return this.tsParseInterfaceDeclaration(node);
            }
          } else {
            this.unexpected(null, 80);
          }
        }
      }, {
        key: "parseMethod",
        value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
          var method = _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseMethod", this).call(this, node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);

          if (method["abstract"]) {
            var hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;

            if (hasBody) {
              var key = method.key;
              this.raise(TSErrors.AbstractMethodHasImplementation, {
                at: method,
                methodName: key.type === "Identifier" && !method.computed ? key.name : "[".concat(this.input.slice(key.start, key.end), "]")
              });
            }
          }

          return method;
        }
      }, {
        key: "tsParseTypeParameterName",
        value: function tsParseTypeParameterName() {
          var typeName = this.parseIdentifier();
          return typeName.name;
        }
      }, {
        key: "shouldParseAsAmbientContext",
        value: function shouldParseAsAmbientContext() {
          return !!this.getPluginOption("typescript", "dts");
        }
      }, {
        key: "parse",
        value: function parse() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parse", this).call(this);
        }
      }, {
        key: "getExpression",
        value: function getExpression() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }

          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "getExpression", this).call(this);
        }
      }, {
        key: "parseExportSpecifier",
        value: function parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
          if (!isString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
            return this.finishNode(node, "ExportSpecifier");
          }

          node.exportKind = "value";
          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseExportSpecifier", this).call(this, node, isString, isInTypeExport, isMaybeTypeOnly);
        }
      }, {
        key: "parseImportSpecifier",
        value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
          if (!importedIsString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
            return this.finishNode(specifier, "ImportSpecifier");
          }

          specifier.importKind = "value";
          return _get(_getPrototypeOf(TypeScriptParserMixin.prototype), "parseImportSpecifier", this).call(this, specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);
        }
      }, {
        key: "parseTypeOnlyImportExportSpecifier",
        value: function parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
          var leftOfAsKey = isImport ? "imported" : "local";
          var rightOfAsKey = isImport ? "local" : "exported";
          var leftOfAs = node[leftOfAsKey];
          var rightOfAs;
          var hasTypeSpecifier = false;
          var canParseAsKeyword = true;
          var loc = leftOfAs.loc.start;

          if (this.isContextual(93)) {
            var firstAs = this.parseIdentifier();

            if (this.isContextual(93)) {
              var secondAs = this.parseIdentifier();

              if (tokenIsKeywordOrIdentifier(this.state.type)) {
                hasTypeSpecifier = true;
                leftOfAs = firstAs;
                rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                canParseAsKeyword = false;
              } else {
                rightOfAs = secondAs;
                canParseAsKeyword = false;
              }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
              canParseAsKeyword = false;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            } else {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;

            if (isImport) {
              leftOfAs = this.parseIdentifier(true);

              if (!this.isContextual(93)) {
                this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
              }
            } else {
              leftOfAs = this.parseModuleExportName();
            }
          }

          if (hasTypeSpecifier && isInTypeOnlyImportExport) {
            this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
              at: loc
            });
          }

          node[leftOfAsKey] = leftOfAs;
          node[rightOfAsKey] = rightOfAs;
          var kindKey = isImport ? "importKind" : "exportKind";
          node[kindKey] = hasTypeSpecifier ? "type" : "value";

          if (canParseAsKeyword && this.eatContextual(93)) {
            node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          }

          if (!node[rightOfAsKey]) {
            node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
          }

          if (isImport) {
            this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);
          }
        }
      }]);

      return TypeScriptParserMixin;
    }(superClass)
  );
};

function isPossiblyLiteralEnum(expression) {
  if (expression.type !== "MemberExpression") return false;
  var computed = expression.computed,
      property = expression.property;

  if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
    return false;
  }

  return isUncomputedMemberExpressionChain(expression.object);
}

function isUncomputedMemberExpressionChain(expression) {
  if (expression.type === "Identifier") return true;
  if (expression.type !== "MemberExpression") return false;
  if (expression.computed) return false;
  return isUncomputedMemberExpressionChain(expression.object);
}

var PlaceholderErrors = ParseErrorEnum(_templateObject5())({
  ClassNameIsRequired: "A class name is required.",
  UnexpectedSpace: "Unexpected space in placeholder."
});

var placeholders = function placeholders(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass5) {
      _inherits(PlaceholdersParserMixin, _superClass5);

      function PlaceholdersParserMixin() {
        _classCallCheck(this, PlaceholdersParserMixin);

        return _possibleConstructorReturn(this, _getPrototypeOf(PlaceholdersParserMixin).apply(this, arguments));
      }

      _createClass(PlaceholdersParserMixin, [{
        key: "parsePlaceholder",
        value: function parsePlaceholder(expectedNode) {
          if (this.match(140)) {
            var node = this.startNode();
            this.next();
            this.assertNoSpace();
            node.name = _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseIdentifier", this).call(this, true);
            this.assertNoSpace();
            this.expect(140);
            return this.finishPlaceholder(node, expectedNode);
          }
        }
      }, {
        key: "finishPlaceholder",
        value: function finishPlaceholder(node, expectedNode) {
          var isFinished = !!(node.expectedNode && node.type === "Placeholder");
          node.expectedNode = expectedNode;
          return isFinished ? node : this.finishNode(node, "Placeholder");
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            return this.finishOp(140, 2);
          }

          return _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "getTokenFromCode", this).call(this, code);
        }
      }, {
        key: "parseExprAtom",
        value: function parseExprAtom(refExpressionErrors) {
          return this.parsePlaceholder("Expression") || _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
        }
      }, {
        key: "parseIdentifier",
        value: function parseIdentifier(liberal) {
          return this.parsePlaceholder("Identifier") || _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseIdentifier", this).call(this, liberal);
        }
      }, {
        key: "checkReservedWord",
        value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word !== undefined) {
            _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "checkReservedWord", this).call(this, word, startLoc, checkKeywords, isBinding);
          }
        }
      }, {
        key: "parseBindingAtom",
        value: function parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseBindingAtom", this).call(this);
        }
      }, {
        key: "isValidLVal",
        value: function isValidLVal(type, isParenthesized, binding) {
          return type === "Placeholder" || _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "isValidLVal", this).call(this, type, isParenthesized, binding);
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node, isLHS) {
          if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
            node.expectedNode = "Pattern";
          } else {
            _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
          }
        }
      }, {
        key: "isLet",
        value: function isLet(context) {
          if (_get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "isLet", this).call(this, context)) {
            return true;
          }

          if (!this.isContextual(99)) {
            return false;
          }

          if (context) return false;
          var nextToken = this.lookahead();

          if (nextToken.type === 140) {
            return true;
          }

          return false;
        }
      }, {
        key: "verifyBreakContinue",
        value: function verifyBreakContinue(node, isBreak) {
          if (node.label && node.label.type === "Placeholder") return;

          _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "verifyBreakContinue", this).call(this, node, isBreak);
        }
      }, {
        key: "parseExpressionStatement",
        value: function parseExpressionStatement(node, expr) {
          if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
            return _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseExpressionStatement", this).call(this, node, expr);
          }

          if (this.match(14)) {
            var stmt = node;
            stmt.label = this.finishPlaceholder(expr, "Identifier");
            this.next();
            stmt.body = _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseStatement", this).call(this, "label");
            return this.finishNode(stmt, "LabeledStatement");
          }

          this.semicolon();
          node.name = expr.name;
          return this.finishPlaceholder(node, "Statement");
        }
      }, {
        key: "parseBlock",
        value: function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
          return this.parsePlaceholder("BlockStatement") || _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseBlock", this).call(this, allowDirectives, createNewLexicalScope, afterBlockParse);
        }
      }, {
        key: "parseFunctionId",
        value: function parseFunctionId(requireId) {
          return this.parsePlaceholder("Identifier") || _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseFunctionId", this).call(this, requireId);
        }
      }, {
        key: "parseClass",
        value: function parseClass(node, isStatement, optionalId) {
          var type = isStatement ? "ClassDeclaration" : "ClassExpression";
          this.next();
          this.takeDecorators(node);
          var oldStrict = this.state.strict;
          var placeholder = this.parsePlaceholder("Identifier");

          if (placeholder) {
            if (this.match(81) || this.match(140) || this.match(5)) {
              node.id = placeholder;
            } else if (optionalId || !isStatement) {
              node.id = null;
              node.body = this.finishPlaceholder(placeholder, "ClassBody");
              return this.finishNode(node, type);
            } else {
              throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
                at: this.state.startLoc
              });
            }
          } else {
            this.parseClassId(node, isStatement, optionalId);
          }

          _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseClassSuper", this).call(this, node);

          node.body = this.parsePlaceholder("ClassBody") || _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseClassBody", this).call(this, !!node.superClass, oldStrict);
          return this.finishNode(node, type);
        }
      }, {
        key: "parseExport",
        value: function parseExport(node) {
          var placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder) return _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseExport", this).call(this, node);

          if (!this.isContextual(97) && !this.match(12)) {
            node.specifiers = [];
            node.source = null;
            node.declaration = this.finishPlaceholder(placeholder, "Declaration");
            return this.finishNode(node, "ExportNamedDeclaration");
          }

          this.expectPlugin("exportDefaultFrom");
          var specifier = this.startNode();
          specifier.exported = placeholder;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseExport", this).call(this, node);
        }
      }, {
        key: "isExportDefaultSpecifier",
        value: function isExportDefaultSpecifier() {
          if (this.match(65)) {
            var next = this.nextTokenStart();

            if (this.isUnparsedContextual(next, "from")) {
              if (this.input.startsWith(tokenLabelName(140), this.nextTokenStartSince(next + 4))) {
                return true;
              }
            }
          }

          return _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "isExportDefaultSpecifier", this).call(this);
        }
      }, {
        key: "maybeParseExportDefaultSpecifier",
        value: function maybeParseExportDefaultSpecifier(node) {
          if (node.specifiers && node.specifiers.length > 0) {
            return true;
          }

          return _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "maybeParseExportDefaultSpecifier", this).call(this, node);
        }
      }, {
        key: "checkExport",
        value: function checkExport(node) {
          var specifiers = node.specifiers;

          if (specifiers != null && specifiers.length) {
            node.specifiers = specifiers.filter(function (node) {
              return node.exported.type === "Placeholder";
            });
          }

          _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "checkExport", this).call(this, node);

          node.specifiers = specifiers;
        }
      }, {
        key: "parseImport",
        value: function parseImport(node) {
          var placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder) return _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseImport", this).call(this, node);
          node.specifiers = [];

          if (!this.isContextual(97) && !this.match(12)) {
            node.source = this.finishPlaceholder(placeholder, "StringLiteral");
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
          }

          var specifier = this.startNodeAtNode(placeholder);
          specifier.local = placeholder;
          node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));

          if (this.eat(12)) {
            var hasStarImport = this.maybeParseStarImportSpecifier(node);
            if (!hasStarImport) this.parseNamedImportSpecifiers(node);
          }

          this.expectContextual(97);
          node.source = this.parseImportSource();
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
      }, {
        key: "parseImportSource",
        value: function parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || _get(_getPrototypeOf(PlaceholdersParserMixin.prototype), "parseImportSource", this).call(this);
        }
      }, {
        key: "assertNoSpace",
        value: function assertNoSpace() {
          if (this.state.start > this.state.lastTokEndLoc.index) {
            this.raise(PlaceholderErrors.UnexpectedSpace, {
              at: this.state.lastTokEndLoc
            });
          }
        }
      }]);

      return PlaceholdersParserMixin;
    }(superClass)
  );
};

var v8intrinsic = function v8intrinsic(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass6) {
      _inherits(V8IntrinsicMixin, _superClass6);

      function V8IntrinsicMixin() {
        _classCallCheck(this, V8IntrinsicMixin);

        return _possibleConstructorReturn(this, _getPrototypeOf(V8IntrinsicMixin).apply(this, arguments));
      }

      _createClass(V8IntrinsicMixin, [{
        key: "parseV8Intrinsic",
        value: function parseV8Intrinsic() {
          if (this.match(54)) {
            var v8IntrinsicStartLoc = this.state.startLoc;
            var node = this.startNode();
            this.next();

            if (tokenIsIdentifier(this.state.type)) {
              var name = this.parseIdentifierName(this.state.start);
              var identifier = this.createIdentifier(node, name);
              identifier.type = "V8IntrinsicIdentifier";

              if (this.match(10)) {
                return identifier;
              }
            }

            this.unexpected(v8IntrinsicStartLoc);
          }
        }
      }, {
        key: "parseExprAtom",
        value: function parseExprAtom(refExpressionErrors) {
          return this.parseV8Intrinsic() || _get(_getPrototypeOf(V8IntrinsicMixin.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
        }
      }]);

      return V8IntrinsicMixin;
    }(superClass)
  );
};

function hasPlugin(plugins, expectedConfig) {
  var _ref94 = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig,
      _ref95 = _slicedToArray(_ref94, 2),
      expectedName = _ref95[0],
      expectedOptions = _ref95[1];

  var expectedKeys = Object.keys(expectedOptions);
  var expectedOptionsIsEmpty = expectedKeys.length === 0;
  return plugins.some(function (p) {
    if (typeof p === "string") {
      return expectedOptionsIsEmpty && p === expectedName;
    } else {
      var _p = _slicedToArray(p, 2),
          pluginName = _p[0],
          pluginOptions = _p[1];

      if (pluginName !== expectedName) {
        return false;
      }

      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = expectedKeys[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var key = _step7.value;

          if (pluginOptions[key] !== expectedOptions[key]) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      return true;
    }
  });
}

function getPluginOption(plugins, name, option) {
  var plugin = plugins.find(function (plugin) {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });

  if (plugin && Array.isArray(plugin) && plugin.length > 1) {
    return plugin[1][option];
  }

  return null;
}

var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];

function validatePlugins(plugins) {
  if (hasPlugin(plugins, "decorators")) {
    if (hasPlugin(plugins, "decorators-legacy")) {
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    }

    var decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
      throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }

    var allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");

    if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
      throw new Error("'allowCallParenthesized' must be a boolean.");
    }
  }

  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }

  if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  }

  if (hasPlugin(plugins, "pipelineOperator")) {
    var proposal = getPluginOption(plugins, "pipelineOperator", "proposal");

    if (!PIPELINE_PROPOSALS.includes(proposal)) {
      var proposalList = PIPELINE_PROPOSALS.map(function (p) {
        return "\"".concat(p, "\"");
      }).join(", ");
      throw new Error("\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ".concat(proposalList, "."));
    }

    var tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
      syntaxType: "hash"
    }]);

    if (proposal === "hack") {
      if (hasPlugin(plugins, "placeholders")) {
        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
      }

      if (hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
      }

      var topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");

      if (!TOPIC_TOKENS.includes(topicToken)) {
        var tokenList = TOPIC_TOKENS.map(function (t) {
          return "\"".concat(t, "\"");
        }).join(", ");
        throw new Error("\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ".concat(tokenList, "."));
      }

      if (topicToken === "#" && tupleSyntaxIsHash) {
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      }
    } else if (proposal === "smart" && tupleSyntaxIsHash) {
      throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
  }

  if (hasPlugin(plugins, "moduleAttributes")) {
    {
      if (hasPlugin(plugins, "importAssertions")) {
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      }

      var moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");

      if (moduleAttributesVersionPluginOption !== "may-2020") {
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
      }
    }
  }

  if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
    throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function (p) {
      return "'".concat(p, "'");
    }).join(", "));
  }

  if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
    var error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
    error.missingPlugins = "doExpressions";
    throw error;
  }
}

var mixinPlugins = {
  estree: estree,
  jsx: jsx,
  flow: flow,
  typescript: typescript,
  v8intrinsic: v8intrinsic,
  placeholders: placeholders
};
var mixinPluginNames = Object.keys(mixinPlugins);
var defaultOptions = {
  sourceType: "script",
  sourceFilename: undefined,
  startColumn: 0,
  startLine: 1,
  allowAwaitOutsideFunction: false,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowSuperOutsideMethod: false,
  allowUndeclaredExports: false,
  plugins: [],
  strictMode: null,
  ranges: false,
  tokens: false,
  createParenthesizedExpressions: false,
  errorRecovery: false,
  attachComment: true
};

function getOptions(opts) {
  var options = {};

  for (var _i5 = 0, _Object$keys3 = Object.keys(defaultOptions); _i5 < _Object$keys3.length; _i5++) {
    var key = _Object$keys3[_i5];
    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
  }

  return options;
}

var getOwn = function getOwn(object, key) {
  return Object.hasOwnProperty.call(object, key) && object[key];
};

var unwrapParenthesizedExpression = function unwrapParenthesizedExpression(node) {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

var LValParser =
/*#__PURE__*/
function (_NodeUtils) {
  _inherits(LValParser, _NodeUtils);

  function LValParser() {
    _classCallCheck(this, LValParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(LValParser).apply(this, arguments));
  }

  _createClass(LValParser, [{
    key: "toAssignable",
    value: function toAssignable(node) {
      var isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var _node$extra, _node$extra3;

      var parenthesized = undefined;

      if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
        parenthesized = unwrapParenthesizedExpression(node);

        if (isLHS) {
          if (parenthesized.type === "Identifier") {
            this.expressionScope.recordArrowParemeterBindingError(Errors.InvalidParenthesizedAssignment, {
              at: node
            });
          } else if (parenthesized.type !== "MemberExpression") {
            this.raise(Errors.InvalidParenthesizedAssignment, {
              at: node
            });
          }
        } else {
          this.raise(Errors.InvalidParenthesizedAssignment, {
            at: node
          });
        }
      }

      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;

        case "ObjectExpression":
          node.type = "ObjectPattern";

          for (var i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
            var _node$extra2;

            var prop = node.properties[i];
            var isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS);

            if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, {
                at: node.extra.trailingCommaLoc
              });
            }
          }

          break;

        case "ObjectProperty":
          {
            var key = node.key,
                value = node.value;

            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }

            this.toAssignable(value, isLHS);
            break;
          }

        case "SpreadElement":
          {
            throw new Error("Internal @babel/parser error (this is a bug, please report it)." + " SpreadElement should be converted by .toAssignable's caller.");
          }

        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
          break;

        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(Errors.MissingEqInAssignment, {
              at: node.left.loc.end
            });
          }

          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isLHS);
          break;

        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }
    }
  }, {
    key: "toAssignableObjectExpressionProp",
    value: function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod") {
        this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
          at: prop.key
        });
      } else if (prop.type === "SpreadElement") {
        prop.type = "RestElement";
        var arg = prop.argument;
        this.checkToRestConversion(arg, false);
        this.toAssignable(arg, isLHS);

        if (!isLast) {
          this.raise(Errors.RestTrailingComma, {
            at: prop
          });
        }
      } else {
        this.toAssignable(prop, isLHS);
      }
    }
  }, {
    key: "toAssignableList",
    value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
      var end = exprList.length - 1;

      for (var i = 0; i <= end; i++) {
        var elt = exprList[i];
        if (!elt) continue;

        if (elt.type === "SpreadElement") {
          elt.type = "RestElement";
          var arg = elt.argument;
          this.checkToRestConversion(arg, true);
          this.toAssignable(arg, isLHS);
        } else {
          this.toAssignable(elt, isLHS);
        }

        if (elt.type === "RestElement") {
          if (i < end) {
            this.raise(Errors.RestTrailingComma, {
              at: elt
            });
          } else if (trailingCommaLoc) {
            this.raise(Errors.RestTrailingComma, {
              at: trailingCommaLoc
            });
          }
        }
      }
    }
  }, {
    key: "isAssignable",
    value: function isAssignable(node, isBinding) {
      var _this53 = this;

      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;

        case "ObjectExpression":
          {
            var last = node.properties.length - 1;
            return node.properties.every(function (prop, i) {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && _this53.isAssignable(prop);
            });
          }

        case "ObjectProperty":
          return this.isAssignable(node.value);

        case "SpreadElement":
          return this.isAssignable(node.argument);

        case "ArrayExpression":
          return node.elements.every(function (element) {
            return element === null || _this53.isAssignable(element);
          });

        case "AssignmentExpression":
          return node.operator === "=";

        case "ParenthesizedExpression":
          return this.isAssignable(node.expression);

        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding;

        default:
          return false;
      }
    }
  }, {
    key: "toReferencedList",
    value: function toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
  }, {
    key: "toReferencedListDeep",
    value: function toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = exprList[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var expr = _step8.value;

          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
  }, {
    key: "parseSpread",
    value: function parseSpread(refExpressionErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);
      return this.finishNode(node, "SpreadElement");
    }
  }, {
    key: "parseRestBinding",
    value: function parseRestBinding() {
      var node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    }
  }, {
    key: "parseBindingAtom",
    value: function parseBindingAtom() {
      switch (this.state.type) {
        case 0:
          {
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }

        case 5:
          return this.parseObjectLike(8, true);
      }

      return this.parseIdentifier();
    }
  }, {
    key: "parseBindingList",
    value: function parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
        }

        if (allowEmpty && this.match(12)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(21)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));

          if (!this.checkCommaAfterRest(closeCharCode)) {
            this.expect(close);
            break;
          }
        } else {
          var decorators = [];

          if (this.match(26) && this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedParameterDecorator, {
              at: this.state.startLoc
            });
          }

          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }

          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }

      return elts;
    }
  }, {
    key: "parseBindingRestProperty",
    value: function parseBindingRestProperty(prop) {
      this.next();
      prop.argument = this.parseIdentifier();
      this.checkCommaAfterRest(125);
      return this.finishNode(prop, "RestElement");
    }
  }, {
    key: "parseBindingProperty",
    value: function parseBindingProperty() {
      var prop = this.startNode();
      var _this$state3 = this.state,
          type = _this$state3.type,
          startPos = _this$state3.start,
          startLoc = _this$state3.startLoc;

      if (type === 21) {
        return this.parseBindingRestProperty(prop);
      } else if (type === 134) {
        this.expectPlugin("destructuringPrivate", startLoc);
        this.classScope.usePrivateName(this.state.value, startLoc);
        prop.key = this.parsePrivateName();
      } else {
        this.parsePropertyName(prop);
      }

      prop.method = false;
      return this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false);
    }
  }, {
    key: "parseAssignableListItem",
    value: function parseAssignableListItem(allowModifiers, decorators) {
      var left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    }
  }, {
    key: "parseAssignableListItemTypes",
    value: function parseAssignableListItemTypes(param) {
      return param;
    }
  }, {
    key: "parseMaybeDefault",
    value: function parseMaybeDefault(startPos, startLoc, left) {
      var _startLoc, _startPos, _left;

      startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
      startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
      left = (_left = left) != null ? _left : this.parseBindingAtom();
      if (!this.eat(29)) return left;
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node, "AssignmentPattern");
    }
  }, {
    key: "isValidLVal",
    value: function isValidLVal(type, isUnparenthesizedInAssign, binding) {
      return getOwn({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, type);
    }
  }, {
    key: "checkLVal",
    value: function checkLVal(expression, _ref96) {
      var ancestor = _ref96["in"],
          _ref96$binding = _ref96.binding,
          binding = _ref96$binding === void 0 ? BIND_NONE : _ref96$binding,
          _ref96$checkClashes = _ref96.checkClashes,
          checkClashes = _ref96$checkClashes === void 0 ? false : _ref96$checkClashes,
          _ref96$strictModeChan = _ref96.strictModeChanged,
          strictModeChanged = _ref96$strictModeChan === void 0 ? false : _ref96$strictModeChan,
          _ref96$allowingSloppy = _ref96.allowingSloppyLetBinding,
          allowingSloppyLetBinding = _ref96$allowingSloppy === void 0 ? !(binding & BIND_SCOPE_LEXICAL) : _ref96$allowingSloppy,
          _ref96$hasParenthesiz = _ref96.hasParenthesizedAncestor,
          hasParenthesizedAncestor = _ref96$hasParenthesiz === void 0 ? false : _ref96$hasParenthesiz;

      var _expression$extra;

      var type = expression.type;
      if (this.isObjectMethod(expression)) return;

      if (type === "MemberExpression") {
        if (binding !== BIND_NONE) {
          this.raise(Errors.InvalidPropertyBindingPattern, {
            at: expression
          });
        }

        return;
      }

      if (expression.type === "Identifier") {
        this.checkIdentifier(expression, binding, strictModeChanged, allowingSloppyLetBinding);
        var name = expression.name;

        if (checkClashes) {
          if (checkClashes.has(name)) {
            this.raise(Errors.ParamDupe, {
              at: expression
            });
          } else {
            checkClashes.add(name);
          }
        }

        return;
      }

      var validity = this.isValidLVal(expression.type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
      if (validity === true) return;

      if (validity === false) {
        var ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
        this.raise(ParseErrorClass, {
          at: expression,
          ancestor: ancestor.type === "UpdateExpression" ? {
            type: "UpdateExpression",
            prefix: ancestor.prefix
          } : {
            type: ancestor.type
          }
        });
        return;
      }

      var _ref97 = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"],
          _ref98 = _slicedToArray(_ref97, 2),
          key = _ref98[0],
          isParenthesizedExpression = _ref98[1];

      var nextAncestor = expression.type === "ArrayPattern" || expression.type === "ObjectPattern" || expression.type === "ParenthesizedExpression" ? expression : ancestor;
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = [].concat(expression[key])[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var child = _step9.value;

          if (child) {
            this.checkLVal(child, {
              "in": nextAncestor,
              binding: binding,
              checkClashes: checkClashes,
              allowingSloppyLetBinding: allowingSloppyLetBinding,
              strictModeChanged: strictModeChanged,
              hasParenthesizedAncestor: isParenthesizedExpression
            });
          }
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }
    }
  }, {
    key: "checkIdentifier",
    value: function checkIdentifier(at, bindingType) {
      var strictModeChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var allowLetBinding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !(bindingType & BIND_SCOPE_LEXICAL);

      if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
        if (bindingType === BIND_NONE) {
          this.raise(Errors.StrictEvalArguments, {
            at: at,
            referenceName: at.name
          });
        } else {
          this.raise(Errors.StrictEvalArgumentsBinding, {
            at: at,
            bindingName: at.name
          });
        }
      }

      if (!allowLetBinding && at.name === "let") {
        this.raise(Errors.LetInLexicalBinding, {
          at: at
        });
      }

      if (!(bindingType & BIND_NONE)) {
        this.declareNameFromIdentifier(at, bindingType);
      }
    }
  }, {
    key: "declareNameFromIdentifier",
    value: function declareNameFromIdentifier(identifier, binding) {
      this.scope.declareName(identifier.name, binding, identifier.loc.start);
    }
  }, {
    key: "checkToRestConversion",
    value: function checkToRestConversion(node, allowPattern) {
      switch (node.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(node.expression, allowPattern);
          break;

        case "Identifier":
        case "MemberExpression":
          break;

        case "ArrayExpression":
        case "ObjectExpression":
          if (allowPattern) break;

        default:
          this.raise(Errors.InvalidRestAssignmentPattern, {
            at: node
          });
      }
    }
  }, {
    key: "checkCommaAfterRest",
    value: function checkCommaAfterRest(close) {
      if (!this.match(12)) {
        return false;
      }

      this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
        at: this.state.startLoc
      });
      return true;
    }
  }]);

  return LValParser;
}(NodeUtils);

var ExpressionParser =
/*#__PURE__*/
function (_LValParser) {
  _inherits(ExpressionParser, _LValParser);

  function ExpressionParser() {
    _classCallCheck(this, ExpressionParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(ExpressionParser).apply(this, arguments));
  }

  _createClass(ExpressionParser, [{
    key: "checkProto",
    value: function checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
        return;
      }

      var key = prop.key;
      var name = key.type === "Identifier" ? key.name : key.value;

      if (name === "__proto__") {
        if (isRecord) {
          this.raise(Errors.RecordNoProto, {
            at: key
          });
          return;
        }

        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProtoLoc === null) {
              refExpressionErrors.doubleProtoLoc = key.loc.start;
            }
          } else {
            this.raise(Errors.DuplicateProto, {
              at: key
            });
          }
        }

        protoRef.used = true;
      }
    }
  }, {
    key: "shouldExitDescending",
    value: function shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    }
  }, {
    key: "getExpression",
    value: function getExpression() {
      this.enterInitialScopes();
      this.nextToken();
      var expr = this.parseExpression();

      if (!this.match(135)) {
        this.unexpected();
      }

      this.finalizeRemainingComments();
      expr.comments = this.state.comments;
      expr.errors = this.state.errors;

      if (this.options.tokens) {
        expr.tokens = this.tokens;
      }

      return expr;
    }
  }, {
    key: "parseExpression",
    value: function parseExpression(disallowIn, refExpressionErrors) {
      var _this54 = this;

      if (disallowIn) {
        return this.disallowInAnd(function () {
          return _this54.parseExpressionBase(refExpressionErrors);
        });
      }

      return this.allowInAnd(function () {
        return _this54.parseExpressionBase(refExpressionErrors);
      });
    }
  }, {
    key: "parseExpressionBase",
    value: function parseExpressionBase(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseMaybeAssign(refExpressionErrors);

      if (this.match(12)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];

        while (this.eat(12)) {
          node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }

        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }

      return expr;
    }
  }, {
    key: "parseMaybeAssignDisallowIn",
    value: function parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      var _this55 = this;

      return this.disallowInAnd(function () {
        return _this55.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      });
    }
  }, {
    key: "parseMaybeAssignAllowIn",
    value: function parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      var _this56 = this;

      return this.allowInAnd(function () {
        return _this56.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      });
    }
  }, {
    key: "setOptionalParametersError",
    value: function setOptionalParametersError(refExpressionErrors, resultError) {
      var _resultError$loc;

      refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
    }
  }, {
    key: "parseMaybeAssign",
    value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      if (this.isContextual(105)) {
        if (this.prodParam.hasYield) {
          var _left2 = this.parseYield();

          if (afterLeftParse) {
            _left2 = afterLeftParse.call(this, _left2, startPos, startLoc);
          }

          return _left2;
        }
      }

      var ownExpressionErrors;

      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }

      var type = this.state.type;

      if (type === 10 || tokenIsIdentifier(type)) {
        this.state.potentialArrowAt = this.state.start;
      }

      var left = this.parseMaybeConditional(refExpressionErrors);

      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }

      if (tokenIsAssignment(this.state.type)) {
        var node = this.startNodeAt(startPos, startLoc);
        var operator = this.state.value;
        node.operator = operator;

        if (this.match(29)) {
          this.toAssignable(left, true);
          node.left = left;

          if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {
            refExpressionErrors.doubleProtoLoc = null;
          }

          if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startPos) {
            refExpressionErrors.shorthandAssignLoc = null;
          }

          if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {
            this.checkDestructuringPrivate(refExpressionErrors);
            refExpressionErrors.privateKeyLoc = null;
          }
        } else {
          node.left = left;
        }

        this.next();
        node.right = this.parseMaybeAssign();
        this.checkLVal(left, {
          "in": this.finishNode(node, "AssignmentExpression")
        });
        return node;
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      return left;
    }
  }, {
    key: "parseMaybeConditional",
    value: function parseMaybeConditional(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprOps(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
    }
  }, {
    key: "parseConditional",
    value: function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (this.eat(17)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssignAllowIn();
        this.expect(14);
        node.alternate = this.parseMaybeAssign();
        return this.finishNode(node, "ConditionalExpression");
      }

      return expr;
    }
  }, {
    key: "parseMaybeUnaryOrPrivate",
    value: function parseMaybeUnaryOrPrivate(refExpressionErrors) {
      return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    }
  }, {
    key: "parseExprOps",
    value: function parseExprOps(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseExprOp(expr, startPos, startLoc, -1);
    }
  }, {
    key: "parseExprOp",
    value: function parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      if (this.isPrivateName(left)) {
        var value = this.getPrivateNameSV(left);

        if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
          this.raise(Errors.PrivateInExpectedIn, {
            at: left,
            identifierName: value
          });
        }

        this.classScope.usePrivateName(value, left.loc.start);
      }

      var op = this.state.type;

      if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
        var prec = tokenOperatorPrecedence(op);

        if (prec > minPrec) {
          if (op === 39) {
            this.expectPlugin("pipelineOperator");

            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }

            this.checkPipelineAtInfixOperator(left, leftStartLoc);
          }

          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.state.value;
          var logical = op === 41 || op === 42;
          var coalesce = op === 40;

          if (coalesce) {
            prec = tokenOperatorPrecedence(42);
          }

          this.next();

          if (op === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }])) {
            if (this.state.type === 96 && this.prodParam.hasAwait) {
              throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                at: this.state.startLoc
              });
            }
          }

          node.right = this.parseExprOpRightExpr(op, prec);
          var finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          var nextOp = this.state.type;

          if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
            throw this.raise(Errors.MixingCoalesceWithLogical, {
              at: this.state.startLoc
            });
          }

          return this.parseExprOp(finishedNode, leftStartPos, leftStartLoc, minPrec);
        }
      }

      return left;
    }
  }, {
    key: "parseExprOpRightExpr",
    value: function parseExprOpRightExpr(op, prec) {
      var _this57 = this;

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      switch (op) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(function () {
                return _this57.parseHackPipeBody();
              });

            case "smart":
              return this.withTopicBindingContext(function () {
                if (_this57.prodParam.hasYield && _this57.isContextual(105)) {
                  throw _this57.raise(Errors.PipeBodyIsTighter, {
                    at: _this57.state.startLoc
                  });
                }

                return _this57.parseSmartPipelineBodyInStyle(_this57.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
              });

            case "fsharp":
              return this.withSoloAwaitPermittingContext(function () {
                return _this57.parseFSharpPipelineBody(prec);
              });
          }

        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    }
  }, {
    key: "parseExprOpBaseRightExpr",
    value: function parseExprOpBaseRightExpr(op, prec) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
    }
  }, {
    key: "parseHackPipeBody",
    value: function parseHackPipeBody() {
      var _body$extra;

      var startLoc = this.state.startLoc;
      var body = this.parseMaybeAssign();
      var requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);

      if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
        this.raise(Errors.PipeUnparenthesizedBody, {
          at: startLoc,
          type: body.type
        });
      }

      if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(Errors.PipeTopicUnused, {
          at: startLoc
        });
      }

      return body;
    }
  }, {
    key: "checkExponentialAfterUnary",
    value: function checkExponentialAfterUnary(node) {
      if (this.match(57)) {
        this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
          at: node.argument
        });
      }
    }
  }, {
    key: "parseMaybeUnary",
    value: function parseMaybeUnary(refExpressionErrors, sawUnary) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var isAwait = this.isContextual(96);

      if (isAwait && this.isAwaitAllowed()) {
        this.next();

        var _expr = this.parseAwait(startPos, startLoc);

        if (!sawUnary) this.checkExponentialAfterUnary(_expr);
        return _expr;
      }

      var update = this.match(34);
      var node = this.startNode();

      if (tokenIsPrefix(this.state.type)) {
        node.operator = this.state.value;
        node.prefix = true;

        if (this.match(72)) {
          this.expectPlugin("throwExpressions");
        }

        var isDelete = this.match(89);
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refExpressionErrors, true);

        if (this.state.strict && isDelete) {
          var arg = node.argument;

          if (arg.type === "Identifier") {
            this.raise(Errors.StrictDelete, {
              at: node
            });
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(Errors.DeletePrivateField, {
              at: node
            });
          }
        }

        if (!update) {
          if (!sawUnary) {
            this.checkExponentialAfterUnary(node);
          }

          return this.finishNode(node, "UnaryExpression");
        }
      }

      var expr = this.parseUpdate(node, update, refExpressionErrors);

      if (isAwait) {
        var type = this.state.type;

        var _startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);

        if (_startsExpr && !this.isAmbiguousAwait()) {
          this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
            at: startLoc
          });
          return this.parseAwait(startPos, startLoc);
        }
      }

      return expr;
    }
  }, {
    key: "parseUpdate",
    value: function parseUpdate(node, update, refExpressionErrors) {
      if (update) {
        var updateExpressionNode = node;
        this.checkLVal(updateExpressionNode.argument, {
          "in": this.finishNode(updateExpressionNode, "UpdateExpression")
        });
        return node;
      }

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

      while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
        var _node10 = this.startNodeAt(startPos, startLoc);

        _node10.operator = this.state.value;
        _node10.prefix = false;
        _node10.argument = expr;
        this.next();
        this.checkLVal(expr, {
          "in": expr = this.finishNode(_node10, "UpdateExpression")
        });
      }

      return expr;
    }
  }, {
    key: "parseExprSubscripts",
    value: function parseExprSubscripts(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprAtom(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseSubscripts(expr, startPos, startLoc);
    }
  }, {
    key: "parseSubscripts",
    value: function parseSubscripts(base, startPos, startLoc, noCalls) {
      var state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };

      do {
        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);

      return base;
    }
  }, {
    key: "parseSubscript",
    value: function parseSubscript(base, startPos, startLoc, noCalls, state) {
      var type = this.state.type;

      if (!noCalls && type === 15) {
        return this.parseBind(base, startPos, startLoc, noCalls, state);
      } else if (tokenIsTemplate(type)) {
        return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
      }

      var optional = false;

      if (type === 18) {
        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }

        state.optionalChainMember = optional = true;
        this.next();
      }

      if (!noCalls && this.match(10)) {
        return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
      } else {
        var computed = this.eat(0);

        if (computed || optional || this.eat(16)) {
          return this.parseMember(base, startPos, startLoc, state, computed, optional);
        } else {
          state.stop = true;
          return base;
        }
      }
    }
  }, {
    key: "parseMember",
    value: function parseMember(base, startPos, startLoc, state, computed, optional) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.computed = computed;

      if (computed) {
        node.property = this.parseExpression();
        this.expect(3);
      } else if (this.match(134)) {
        if (base.type === "Super") {
          this.raise(Errors.SuperPrivateField, {
            at: startLoc
          });
        }

        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
        node.property = this.parsePrivateName();
      } else {
        node.property = this.parseIdentifier(true);
      }

      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, "OptionalMemberExpression");
      } else {
        return this.finishNode(node, "MemberExpression");
      }
    }
  }, {
    key: "parseBind",
    value: function parseBind(base, startPos, startLoc, noCalls, state) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      this.next();
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    }
  }, {
    key: "parseCoverCallAndAsyncArrowHead",
    value: function parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var refExpressionErrors = null;
      this.state.maybeInArrowParameters = true;
      this.next();
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      var maybeAsyncArrow = state.maybeAsyncArrow,
          optionalChainMember = state.optionalChainMember;

      if (maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
        refExpressionErrors = new ExpressionErrors();
      }

      if (optionalChainMember) {
        node.optional = optional;
      }

      if (optional) {
        node.arguments = this.parseCallExpressionArguments(11);
      } else {
        node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
      }

      var finishedNode = this.finishCallExpression(node, optionalChainMember);

      if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.checkDestructuringPrivate(refExpressionErrors);
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), finishedNode);
      } else {
        if (maybeAsyncArrow) {
          this.checkExpressionErrors(refExpressionErrors, true);
          this.expressionScope.exit();
        }

        this.toReferencedArguments(finishedNode);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return finishedNode;
    }
  }, {
    key: "toReferencedArguments",
    value: function toReferencedArguments(node, isParenthesizedExpr) {
      this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    }
  }, {
    key: "parseTaggedTemplateExpression",
    value: function parseTaggedTemplateExpression(base, startPos, startLoc, state) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);

      if (state.optionalChainMember) {
        this.raise(Errors.OptionalChainingNoTemplate, {
          at: startLoc
        });
      }

      return this.finishNode(node, "TaggedTemplateExpression");
    }
  }, {
    key: "atPossibleAsyncArrow",
    value: function atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    }
  }, {
    key: "finishCallExpression",
    value: function finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length === 2) {
          {
            if (!this.hasPlugin("moduleAttributes")) {
              this.expectPlugin("importAssertions");
            }
          }
        }

        if (node.arguments.length === 0 || node.arguments.length > 2) {
          this.raise(Errors.ImportCallArity, {
            at: node,
            maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
          });
        } else {
          var _iteratorNormalCompletion10 = true;
          var _didIteratorError10 = false;
          var _iteratorError10 = undefined;

          try {
            for (var _iterator10 = node.arguments[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
              var arg = _step10.value;

              if (arg.type === "SpreadElement") {
                this.raise(Errors.ImportCallSpreadArgument, {
                  at: arg
                });
              }
            }
          } catch (err) {
            _didIteratorError10 = true;
            _iteratorError10 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
                _iterator10["return"]();
              }
            } finally {
              if (_didIteratorError10) {
                throw _iteratorError10;
              }
            }
          }
        }
      }

      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }
  }, {
    key: "parseCallExpressionArguments",
    value: function parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
      var elts = [];
      var first = true;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);

          if (this.match(close)) {
            if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
              this.raise(Errors.ImportCallArgumentTrailingComma, {
                at: this.state.lastTokStartLoc
              });
            }

            if (nodeForExtra) {
              this.addTrailingCommaExtraToNode(nodeForExtra);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }
  }, {
    key: "shouldParseAsyncArrow",
    value: function shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
  }, {
    key: "parseAsyncArrowFromCallExpression",
    value: function parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;

      this.resetPreviousNodeTrailingComments(call);
      this.expect(19);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);

      if (call.innerComments) {
        setInnerComments(node, call.innerComments);
      }

      if (call.callee.trailingComments) {
        setInnerComments(node, call.callee.trailingComments);
      }

      return node;
    }
  }, {
    key: "parseNoCallExpr",
    value: function parseNoCallExpr() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    }
  }, {
    key: "parseExprAtom",
    value: function parseExprAtom(refExpressionErrors) {
      var node;
      var type = this.state.type;

      switch (type) {
        case 79:
          return this.parseSuper();

        case 83:
          node = this.startNode();
          this.next();

          if (this.match(16)) {
            return this.parseImportMetaProperty(node);
          }

          if (!this.match(10)) {
            this.raise(Errors.UnsupportedImport, {
              at: this.state.lastTokStartLoc
            });
          }

          return this.finishNode(node, "Import");

        case 78:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");

        case 90:
          {
            return this.parseDo(this.startNode(), false);
          }

        case 56:
        case 31:
          {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }

        case 130:
          return this.parseNumericLiteral(this.state.value);

        case 131:
          return this.parseBigIntLiteral(this.state.value);

        case 132:
          return this.parseDecimalLiteral(this.state.value);

        case 129:
          return this.parseStringLiteral(this.state.value);

        case 84:
          return this.parseNullLiteral();

        case 85:
          return this.parseBooleanLiteral(true);

        case 86:
          return this.parseBooleanLiteral(false);

        case 10:
          {
            var canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }

        case 2:
        case 1:
          {
            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
          }

        case 0:
          {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }

        case 6:
        case 7:
          {
            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
          }

        case 5:
          {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }

        case 68:
          return this.parseFunctionOrFunctionSent();

        case 26:
          this.parseDecorators();

        case 80:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);

        case 77:
          return this.parseNewOrNewTarget();

        case 25:
        case 24:
          return this.parseTemplate(false);

        case 15:
          {
            node = this.startNode();
            this.next();
            node.object = null;
            var callee = node.callee = this.parseNoCallExpr();

            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, {
                at: callee
              });
            }
          }

        case 134:
          {
            this.raise(Errors.PrivateInExpectedIn, {
              at: this.state.startLoc,
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }

        case 33:
          {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }

        case 32:
          {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }

        case 37:
        case 38:
          {
            return this.parseTopicReference("hack");
          }

        case 44:
        case 54:
        case 27:
          {
            var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");

            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            } else {
              throw this.unexpected();
            }
          }

        case 47:
          {
            var lookaheadCh = this.input.codePointAt(this.nextTokenStart());

            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
              break;
            } else {
              throw this.unexpected();
            }
          }

        default:
          if (tokenIsIdentifier(type)) {
            if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
              return this.parseModuleExpression();
            }

            var _canBeArrow = this.state.potentialArrowAt === this.state.start;

            var containsEsc = this.state.containsEsc;
            var id = this.parseIdentifier();

            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              var _type = this.state.type;

              if (_type === 68) {
                this.resetPreviousNodeTrailingComments(id);
                this.next();
                return this.parseFunction(this.startNodeAtNode(id), undefined, true);
              } else if (tokenIsIdentifier(_type)) {
                if (this.lookaheadCharCode() === 61) {
                  return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                } else {
                  return id;
                }
              } else if (_type === 90) {
                this.resetPreviousNodeTrailingComments(id);
                return this.parseDo(this.startNodeAtNode(id), true);
              }
            }

            if (_canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }

            return id;
          } else {
            throw this.unexpected();
          }

      }
    }
  }, {
    key: "parseTopicReferenceThenEqualsSign",
    value: function parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
      var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");

      if (pipeProposal) {
        this.state.type = topicTokenType;
        this.state.value = topicTokenValue;
        this.state.pos--;
        this.state.end--;
        this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
        return this.parseTopicReference(pipeProposal);
      } else {
        throw this.unexpected();
      }
    }
  }, {
    key: "parseTopicReference",
    value: function parseTopicReference(pipeProposal) {
      var node = this.startNode();
      var startLoc = this.state.startLoc;
      var tokenType = this.state.type;
      this.next();
      return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
    }
  }, {
    key: "finishTopicReference",
    value: function finishTopicReference(node, startLoc, pipeProposal, tokenType) {
      if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
        var nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";

        if (!this.topicReferenceIsAllowedInCurrentContext()) {
          this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
            at: startLoc
          });
        }

        this.registerTopicReference();
        return this.finishNode(node, nodeType);
      } else {
        throw this.raise(Errors.PipeTopicUnconfiguredToken, {
          at: startLoc,
          token: tokenLabelName(tokenType)
        });
      }
    }
  }, {
    key: "testTopicReferenceConfiguration",
    value: function testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
      switch (pipeProposal) {
        case "hack":
          {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            }]);
          }

        case "smart":
          return tokenType === 27;

        default:
          throw this.raise(Errors.PipeTopicRequiresHackPipes, {
            at: startLoc
          });
      }
    }
  }, {
    key: "parseAsyncArrowUnaryFunction",
    value: function parseAsyncArrowUnaryFunction(node) {
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      var params = [this.parseIdentifier()];
      this.prodParam.exit();

      if (this.hasPrecedingLineBreak()) {
        this.raise(Errors.LineTerminatorBeforeArrow, {
          at: this.state.curPosition()
        });
      }

      this.expect(19);
      return this.parseArrowExpression(node, params, true);
    }
  }, {
    key: "parseDo",
    value: function parseDo(node, isAsync) {
      this.expectPlugin("doExpressions");

      if (isAsync) {
        this.expectPlugin("asyncDoExpressions");
      }

      node.async = isAsync;
      this.next();
      var oldLabels = this.state.labels;
      this.state.labels = [];

      if (isAsync) {
        this.prodParam.enter(PARAM_AWAIT);
        node.body = this.parseBlock();
        this.prodParam.exit();
      } else {
        node.body = this.parseBlock();
      }

      this.state.labels = oldLabels;
      return this.finishNode(node, "DoExpression");
    }
  }, {
    key: "parseSuper",
    value: function parseSuper() {
      var node = this.startNode();
      this.next();

      if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(Errors.SuperNotAllowed, {
          at: node
        });
      } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(Errors.UnexpectedSuper, {
          at: node
        });
      }

      if (!this.match(10) && !this.match(0) && !this.match(16)) {
        this.raise(Errors.UnsupportedSuper, {
          at: node
        });
      }

      return this.finishNode(node, "Super");
    }
  }, {
    key: "parsePrivateName",
    value: function parsePrivateName() {
      var node = this.startNode();
      var id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1));
      var name = this.state.value;
      this.next();
      node.id = this.createIdentifier(id, name);
      return this.finishNode(node, "PrivateName");
    }
  }, {
    key: "parseFunctionOrFunctionSent",
    value: function parseFunctionOrFunctionSent() {
      var node = this.startNode();
      this.next();

      if (this.prodParam.hasYield && this.match(16)) {
        var meta = this.createIdentifier(this.startNodeAtNode(node), "function");
        this.next();

        if (this.match(102)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }

        return this.parseMetaProperty(node, meta, "sent");
      }

      return this.parseFunction(node);
    }
  }, {
    key: "parseMetaProperty",
    value: function parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;
      var containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);

      if (node.property.name !== propertyName || containsEsc) {
        this.raise(Errors.UnsupportedMetaProperty, {
          at: node.property,
          target: meta.name,
          onlyValidPropertyName: propertyName
        });
      }

      return this.finishNode(node, "MetaProperty");
    }
  }, {
    key: "parseImportMetaProperty",
    value: function parseImportMetaProperty(node) {
      var id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.next();

      if (this.isContextual(100)) {
        if (!this.inModule) {
          this.raise(Errors.ImportMetaOutsideModule, {
            at: id
          });
        }

        this.sawUnambiguousESM = true;
      }

      return this.parseMetaProperty(node, id, "meta");
    }
  }, {
    key: "parseLiteralAtNode",
    value: function parseLiteralAtNode(value, type, node) {
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    }
  }, {
    key: "parseLiteral",
    value: function parseLiteral(value, type) {
      var node = this.startNode();
      return this.parseLiteralAtNode(value, type, node);
    }
  }, {
    key: "parseStringLiteral",
    value: function parseStringLiteral(value) {
      return this.parseLiteral(value, "StringLiteral");
    }
  }, {
    key: "parseNumericLiteral",
    value: function parseNumericLiteral(value) {
      return this.parseLiteral(value, "NumericLiteral");
    }
  }, {
    key: "parseBigIntLiteral",
    value: function parseBigIntLiteral(value) {
      return this.parseLiteral(value, "BigIntLiteral");
    }
  }, {
    key: "parseDecimalLiteral",
    value: function parseDecimalLiteral(value) {
      return this.parseLiteral(value, "DecimalLiteral");
    }
  }, {
    key: "parseRegExpLiteral",
    value: function parseRegExpLiteral(value) {
      var node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;
    }
  }, {
    key: "parseBooleanLiteral",
    value: function parseBooleanLiteral(value) {
      var node = this.startNode();
      node.value = value;
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    }
  }, {
    key: "parseNullLiteral",
    value: function parseNullLiteral() {
      var node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");
    }
  }, {
    key: "parseParenAndDistinguishExpression",
    value: function parseParenAndDistinguishExpression(canBeArrow) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      var innerStartPos = this.state.start;
      var innerStartLoc = this.state.startLoc;
      var exprList = [];
      var refExpressionErrors = new ExpressionErrors();
      var first = true;
      var spreadStartLoc;
      var optionalCommaStartLoc;

      while (!this.match(11)) {
        if (first) {
          first = false;
        } else {
          this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);

          if (this.match(11)) {
            optionalCommaStartLoc = this.state.startLoc;
            break;
          }
        }

        if (this.match(21)) {
          var spreadNodeStartPos = this.state.start;
          var spreadNodeStartLoc = this.state.startLoc;
          spreadStartLoc = this.state.startLoc;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));

          if (!this.checkCommaAfterRest(41)) {
            break;
          }
        } else {
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
        }
      }

      var innerEndLoc = this.state.lastTokEndLoc;
      this.expect(11);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var arrowNode = this.startNodeAt(startPos, startLoc);

      if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
        this.checkDestructuringPrivate(refExpressionErrors);
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }

      this.expressionScope.exit();

      if (!exprList.length) {
        this.unexpected(this.state.lastTokStartLoc);
      }

      if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
      if (spreadStartLoc) this.unexpected(spreadStartLoc);
      this.checkExpressionErrors(refExpressionErrors, true);
      this.toReferencedListDeep(exprList, true);

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNode(val, "SequenceExpression");
        this.resetEndLocation(val, innerEndLoc);
      } else {
        val = exprList[0];
      }

      return this.wrapParenthesis(startPos, startLoc, val);
    }
  }, {
    key: "wrapParenthesis",
    value: function wrapParenthesis(startPos, startLoc, expression) {
      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(expression, "parenthesized", true);
        this.addExtra(expression, "parenStart", startPos);
        this.takeSurroundingComments(expression, startPos, this.state.lastTokEndLoc.index);
        return expression;
      }

      var parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = expression;
      return this.finishNode(parenExpression, "ParenthesizedExpression");
    }
  }, {
    key: "shouldParseArrow",
    value: function shouldParseArrow(params) {
      return !this.canInsertSemicolon();
    }
  }, {
    key: "parseArrow",
    value: function parseArrow(node) {
      if (this.eat(19)) {
        return node;
      }
    }
  }, {
    key: "parseParenItem",
    value: function parseParenItem(node, startPos, startLoc) {
      return node;
    }
  }, {
    key: "parseNewOrNewTarget",
    value: function parseNewOrNewTarget() {
      var node = this.startNode();
      this.next();

      if (this.match(16)) {
        var meta = this.createIdentifier(this.startNodeAtNode(node), "new");
        this.next();
        var metaProp = this.parseMetaProperty(node, meta, "target");

        if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
          this.raise(Errors.UnexpectedNewTarget, {
            at: metaProp
          });
        }

        return metaProp;
      }

      return this.parseNew(node);
    }
  }, {
    key: "parseNew",
    value: function parseNew(node) {
      this.parseNewCallee(node);

      if (this.eat(10)) {
        var args = this.parseExprList(11);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }

      return this.finishNode(node, "NewExpression");
    }
  }, {
    key: "parseNewCallee",
    value: function parseNewCallee(node) {
      node.callee = this.parseNoCallExpr();

      if (node.callee.type === "Import") {
        this.raise(Errors.ImportCallNotNewExpression, {
          at: node.callee
        });
      } else if (this.isOptionalChain(node.callee)) {
        this.raise(Errors.OptionalChainingNoNew, {
          at: this.state.lastTokEndLoc
        });
      } else if (this.eat(18)) {
        this.raise(Errors.OptionalChainingNoNew, {
          at: this.state.startLoc
        });
      }
    }
  }, {
    key: "parseTemplateElement",
    value: function parseTemplateElement(isTagged) {
      var _this$state4 = this.state,
          start = _this$state4.start,
          startLoc = _this$state4.startLoc,
          end = _this$state4.end,
          value = _this$state4.value;
      var elemStart = start + 1;
      var elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));

      if (value === null) {
        if (!isTagged) {
          this.raise(Errors.InvalidEscapeSequenceTemplate, {
            at: createPositionWithColumnOffset(startLoc, 2)
          });
        }
      }

      var isTail = this.match(24);
      var endOffset = isTail ? -1 : -2;
      var elemEnd = end + endOffset;
      elem.value = {
        raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
        cooked: value === null ? null : value.slice(1, endOffset)
      };
      elem.tail = isTail;
      this.next();
      var finishedNode = this.finishNode(elem, "TemplateElement");
      this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
      return finishedNode;
    }
  }, {
    key: "parseTemplate",
    value: function parseTemplate(isTagged) {
      var node = this.startNode();
      node.expressions = [];
      var curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];

      while (!curElt.tail) {
        node.expressions.push(this.parseTemplateSubstitution());
        this.readTemplateContinuation();
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }

      return this.finishNode(node, "TemplateLiteral");
    }
  }, {
    key: "parseTemplateSubstitution",
    value: function parseTemplateSubstitution() {
      return this.parseExpression();
    }
  }, {
    key: "parseObjectLike",
    value: function parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }

      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      var propHash = Object.create(null);
      var first = true;
      var node = this.startNode();
      node.properties = [];
      this.next();

      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);

          if (this.match(close)) {
            this.addTrailingCommaExtraToNode(node);
            break;
          }
        }

        var prop = void 0;

        if (isPattern) {
          prop = this.parseBindingProperty();
        } else {
          prop = this.parsePropertyDefinition(refExpressionErrors);
          this.checkProto(prop, isRecord, propHash, refExpressionErrors);
        }

        if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
          this.raise(Errors.InvalidRecordProperty, {
            at: prop
          });
        }

        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }

        node.properties.push(prop);
      }

      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var type = "ObjectExpression";

      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }

      return this.finishNode(node, type);
    }
  }, {
    key: "addTrailingCommaExtraToNode",
    value: function addTrailingCommaExtraToNode(node) {
      this.addExtra(node, "trailingComma", this.state.lastTokStart);
      this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
  }, {
    key: "maybeAsyncOrAccessorProp",
    value: function maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
  }, {
    key: "parsePropertyDefinition",
    value: function parsePropertyDefinition(refExpressionErrors) {
      var decorators = [];

      if (this.match(26)) {
        if (this.hasPlugin("decorators")) {
          this.raise(Errors.UnsupportedPropertyDecorator, {
            at: this.state.startLoc
          });
        }

        while (this.match(26)) {
          decorators.push(this.parseDecorator());
        }
      }

      var prop = this.startNode();
      var isAsync = false;
      var isAccessor = false;
      var startPos;
      var startLoc;

      if (this.match(21)) {
        if (decorators.length) this.unexpected();
        return this.parseSpread();
      }

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      prop.method = false;

      if (refExpressionErrors) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      var isGenerator = this.eat(55);
      this.parsePropertyNamePrefixOperator(prop);
      var containsEsc = this.state.containsEsc;
      var key = this.parsePropertyName(prop, refExpressionErrors);

      if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        var keyName = key.name;

        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          this.resetPreviousNodeTrailingComments(key);
          isGenerator = this.eat(55);
          this.parsePropertyName(prop);
        }

        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          this.resetPreviousNodeTrailingComments(key);
          prop.kind = keyName;

          if (this.match(55)) {
            isGenerator = true;
            this.raise(Errors.AccessorIsGenerator, {
              at: this.state.curPosition(),
              kind: keyName
            });
            this.next();
          }

          this.parsePropertyName(prop);
        }
      }

      return this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
    }
  }, {
    key: "getGetterSetterExpectedParamCount",
    value: function getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }
  }, {
    key: "getObjectOrClassMethodParams",
    value: function getObjectOrClassMethodParams(method) {
      return method.params;
    }
  }, {
    key: "checkGetterSetterParams",
    value: function checkGetterSetterParams(method) {
      var _params;

      var paramCount = this.getGetterSetterExpectedParamCount(method);
      var params = this.getObjectOrClassMethodParams(method);

      if (params.length !== paramCount) {
        this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
          at: method
        });
      }

      if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
        this.raise(Errors.BadSetterRestParameter, {
          at: method
        });
      }
    }
  }, {
    key: "parseObjectMethod",
    value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        var finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(finishedProp);
        return finishedProp;
      }

      if (isAsync || isGenerator || this.match(10)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }
    }
  }, {
    key: "parseObjectProperty",
    value: function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;

      if (this.eat(14)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
        return this.finishNode(prop, "ObjectProperty");
      }

      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);

        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
        } else if (this.match(29)) {
          var shorthandAssignLoc = this.state.startLoc;

          if (refExpressionErrors != null) {
            if (refExpressionErrors.shorthandAssignLoc === null) {
              refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
            }
          } else {
            this.raise(Errors.InvalidCoverInitializedName, {
              at: shorthandAssignLoc
            });
          }

          prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
        } else {
          prop.value = cloneIdentifier(prop.key);
        }

        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    }
  }, {
    key: "parseObjPropValue",
    value: function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
      if (!node) this.unexpected();
      return node;
    }
  }, {
    key: "parsePropertyName",
    value: function parsePropertyName(prop, refExpressionErrors) {
      if (this.eat(0)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(3);
      } else {
        var _this$state5 = this.state,
            type = _this$state5.type,
            value = _this$state5.value;
        var key;

        if (tokenIsKeywordOrIdentifier(type)) {
          key = this.parseIdentifier(true);
        } else {
          switch (type) {
            case 130:
              key = this.parseNumericLiteral(value);
              break;

            case 129:
              key = this.parseStringLiteral(value);
              break;

            case 131:
              key = this.parseBigIntLiteral(value);
              break;

            case 132:
              key = this.parseDecimalLiteral(value);
              break;

            case 134:
              {
                var privateKeyLoc = this.state.startLoc;

                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, {
                    at: privateKeyLoc
                  });
                }

                key = this.parsePrivateName();
                break;
              }

            default:
              throw this.unexpected();
          }
        }

        prop.key = key;

        if (type !== 134) {
          prop.computed = false;
        }
      }

      return prop.key;
    }
  }, {
    key: "initFunction",
    value: function initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    }
  }, {
    key: "parseMethod",
    value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
      var inClassScope = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      var allowModifiers = isConstructor;
      this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, allowModifiers);
      var finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return finishedNode;
    }
  }, {
    key: "parseArrayLike",
    value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }

      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      var node = this.startNode();
      this.next();
      node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    }
  }, {
    key: "parseArrowExpression",
    value: function parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      var flags = functionFlags(isAsync, false);

      if (!this.match(5) && this.prodParam.hasIn) {
        flags |= PARAM_IN;
      }

      this.prodParam.enter(flags);
      this.initFunction(node, isAsync);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;

      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaLoc);
      }

      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node, "ArrowFunctionExpression");
    }
  }, {
    key: "setArrowFunctionParameters",
    value: function setArrowFunctionParameters(node, params, trailingCommaLoc) {
      this.toAssignableList(params, trailingCommaLoc, false);
      node.params = params;
    }
  }, {
    key: "parseFunctionBodyAndFinish",
    value: function parseFunctionBodyAndFinish(node, type) {
      var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.parseFunctionBody(node, false, isMethod);
      return this.finishNode(node, type);
    }
  }, {
    key: "parseFunctionBody",
    value: function parseFunctionBody(node, allowExpression) {
      var _this58 = this;

      var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var isExpression = allowExpression && !this.match(5);
      this.expressionScope.enter(newExpressionScope());

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        var oldStrict = this.state.strict;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
        node.body = this.parseBlock(true, false, function (hasStrictModeDirective) {
          var nonSimple = !_this58.isSimpleParamList(node.params);

          if (hasStrictModeDirective && nonSimple) {
            _this58.raise(Errors.IllegalLanguageModeDirective, {
              at: (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node
            });
          }

          var strictModeChanged = !oldStrict && _this58.state.strict;

          _this58.checkParams(node, !_this58.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

          if (_this58.state.strict && node.id) {
            _this58.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.state.labels = oldLabels;
      }

      this.expressionScope.exit();
    }
  }, {
    key: "isSimpleParameter",
    value: function isSimpleParameter(node) {
      return node.type === "Identifier";
    }
  }, {
    key: "isSimpleParamList",
    value: function isSimpleParamList(params) {
      for (var i = 0, len = params.length; i < len; i++) {
        if (!this.isSimpleParameter(params[i])) return false;
      }

      return true;
    }
  }, {
    key: "checkParams",
    value: function checkParams(node, allowDuplicates, isArrowFunction) {
      var strictModeChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var checkClashes = !allowDuplicates && new Set();
      var formalParameters = {
        type: "FormalParameters"
      };
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = node.params[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var param = _step11.value;
          this.checkLVal(param, {
            "in": formalParameters,
            binding: BIND_VAR,
            checkClashes: checkClashes,
            strictModeChanged: strictModeChanged
          });
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }
    }
  }, {
    key: "parseExprList",
    value: function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);

          if (this.match(close)) {
            if (nodeForExtra) {
              this.addTrailingCommaExtraToNode(nodeForExtra);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }

      return elts;
    }
  }, {
    key: "parseExprListItem",
    value: function parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
      var elt;

      if (this.match(12)) {
        if (!allowEmpty) {
          this.raise(Errors.UnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: ","
          });
        }

        elt = null;
      } else if (this.match(21)) {
        var spreadNodeStartPos = this.state.start;
        var spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication");

        if (!allowPlaceholder) {
          this.raise(Errors.UnexpectedArgumentPlaceholder, {
            at: this.state.startLoc
          });
        }

        var node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
      }

      return elt;
    }
  }, {
    key: "parseIdentifier",
    value: function parseIdentifier(liberal) {
      var node = this.startNode();
      var name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    }
  }, {
    key: "createIdentifier",
    value: function createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    }
  }, {
    key: "parseIdentifierName",
    value: function parseIdentifierName(pos, liberal) {
      var name;
      var _this$state6 = this.state,
          startLoc = _this$state6.startLoc,
          type = _this$state6.type;

      if (tokenIsKeywordOrIdentifier(type)) {
        name = this.state.value;
      } else {
        throw this.unexpected();
      }

      var tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);

      if (liberal) {
        if (tokenIsKeyword) {
          this.replaceToken(128);
        }
      } else {
        this.checkReservedWord(name, startLoc, tokenIsKeyword, false);
      }

      this.next();
      return name;
    }
  }, {
    key: "checkReservedWord",
    value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word.length > 10) {
        return;
      }

      if (!canBeReservedWord(word)) {
        return;
      }

      if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(Errors.YieldBindingIdentifier, {
            at: startLoc
          });
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(Errors.AwaitBindingIdentifier, {
            at: startLoc
          });
          return;
        }

        if (this.scope.inStaticBlock) {
          this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
            at: startLoc
          });
          return;
        }

        this.expressionScope.recordAsyncArrowParametersError({
          at: startLoc
        });
      } else if (word === "arguments") {
        if (this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(Errors.ArgumentsInClass, {
            at: startLoc
          });
          return;
        }
      }

      if (checkKeywords && isKeyword(word)) {
        this.raise(Errors.UnexpectedKeyword, {
          at: startLoc,
          keyword: word
        });
        return;
      }

      var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

      if (reservedTest(word, this.inModule)) {
        this.raise(Errors.UnexpectedReservedWord, {
          at: startLoc,
          reservedWord: word
        });
      }
    }
  }, {
    key: "isAwaitAllowed",
    value: function isAwaitAllowed() {
      if (this.prodParam.hasAwait) return true;

      if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
        return true;
      }

      return false;
    }
  }, {
    key: "parseAwait",
    value: function parseAwait(startPos, startLoc) {
      var node = this.startNodeAt(startPos, startLoc);
      this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
        at: node
      });

      if (this.eat(55)) {
        this.raise(Errors.ObsoleteAwaitStar, {
          at: node
        });
      }

      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.isAmbiguousAwait()) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }

      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary(null, true);
      }

      return this.finishNode(node, "AwaitExpression");
    }
  }, {
    key: "isAmbiguousAwait",
    value: function isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return true;
      var type = this.state.type;
      return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 133 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
    }
  }, {
    key: "parseYield",
    value: function parseYield() {
      var node = this.startNode();
      this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
        at: node
      });
      this.next();
      var delegating = false;
      var argument = null;

      if (!this.hasPrecedingLineBreak()) {
        delegating = this.eat(55);

        switch (this.state.type) {
          case 13:
          case 135:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!delegating) break;

          default:
            argument = this.parseMaybeAssign();
        }
      }

      node.delegate = delegating;
      node.argument = argument;
      return this.finishNode(node, "YieldExpression");
    }
  }, {
    key: "checkPipelineAtInfixOperator",
    value: function checkPipelineAtInfixOperator(left, leftStartLoc) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        if (left.type === "SequenceExpression") {
          this.raise(Errors.PipelineHeadSequenceExpression, {
            at: leftStartLoc
          });
        }
      }
    }
  }, {
    key: "parseSmartPipelineBodyInStyle",
    value: function parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
      if (this.isSimpleReference(childExpr)) {
        var bodyNode = this.startNodeAt(startPos, startLoc);
        bodyNode.callee = childExpr;
        return this.finishNode(bodyNode, "PipelineBareFunction");
      } else {
        var _bodyNode2 = this.startNodeAt(startPos, startLoc);

        this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
        _bodyNode2.expression = childExpr;
        return this.finishNode(_bodyNode2, "PipelineTopicExpression");
      }
    }
  }, {
    key: "isSimpleReference",
    value: function isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);

        case "Identifier":
          return true;

        default:
          return false;
      }
    }
  }, {
    key: "checkSmartPipeTopicBodyEarlyErrors",
    value: function checkSmartPipeTopicBodyEarlyErrors(startLoc) {
      if (this.match(19)) {
        throw this.raise(Errors.PipelineBodyNoArrow, {
          at: this.state.startLoc
        });
      }

      if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(Errors.PipelineTopicUnused, {
          at: startLoc
        });
      }
    }
  }, {
    key: "withTopicBindingContext",
    value: function withTopicBindingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
  }, {
    key: "withSmartMixTopicForbiddingContext",
    value: function withSmartMixTopicForbiddingContext(callback) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        var outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };

        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      } else {
        return callback();
      }
    }
  }, {
    key: "withSoloAwaitPermittingContext",
    value: function withSoloAwaitPermittingContext(callback) {
      var outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;

      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
  }, {
    key: "allowInAnd",
    value: function allowInAnd(callback) {
      var flags = this.prodParam.currentFlags();
      var prodParamToSet = PARAM_IN & ~flags;

      if (prodParamToSet) {
        this.prodParam.enter(flags | PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    }
  }, {
    key: "disallowInAnd",
    value: function disallowInAnd(callback) {
      var flags = this.prodParam.currentFlags();
      var prodParamToClear = PARAM_IN & flags;

      if (prodParamToClear) {
        this.prodParam.enter(flags & ~PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    }
  }, {
    key: "registerTopicReference",
    value: function registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
  }, {
    key: "topicReferenceIsAllowedInCurrentContext",
    value: function topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
  }, {
    key: "topicReferenceWasUsedInCurrentContext",
    value: function topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
  }, {
    key: "parseFSharpPipelineBody",
    value: function parseFSharpPipelineBody(prec) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      var ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }
  }, {
    key: "parseModuleExpression",
    value: function parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      var node = this.startNode();
      this.next();
      this.eat(5);
      var revertScopes = this.initializeScopes(true);
      this.enterInitialScopes();
      var program = this.startNode();

      try {
        node.body = this.parseProgram(program, 8, "module");
      } finally {
        revertScopes();
      }

      this.eat(8);
      return this.finishNode(node, "ModuleExpression");
    }
  }, {
    key: "parsePropertyNamePrefixOperator",
    value: function parsePropertyNamePrefixOperator(prop) {}
  }]);

  return ExpressionParser;
}(LValParser);

var loopLabel = {
  kind: "loop"
},
    switchLabel = {
  kind: "switch"
};
var FUNC_NO_FLAGS = 0,
    FUNC_STATEMENT = 1,
    FUNC_HANGING_STATEMENT = 2,
    FUNC_NULLABLE_ID = 4;
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var keywordRelationalOperator = new RegExp("in(?:stanceof)?", "y");

function babel7CompatTokens(tokens, input) {
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    var type = token.type;

    if (typeof type === "number") {
      {
        if (type === 134) {
          var loc = token.loc,
              start = token.start,
              value = token.value,
              end = token.end;
          var hashEndPos = start + 1;
          var hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
          tokens.splice(i, 1, new Token({
            type: getExportedToken(27),
            value: "#",
            start: start,
            end: hashEndPos,
            startLoc: loc.start,
            endLoc: hashEndLoc
          }), new Token({
            type: getExportedToken(128),
            value: value,
            start: hashEndPos,
            end: end,
            startLoc: hashEndLoc,
            endLoc: loc.end
          }));
          i++;
          continue;
        }

        if (tokenIsTemplate(type)) {
          var _loc = token.loc,
              _start = token.start,
              _value = token.value,
              _end = token.end;
          var backquoteEnd = _start + 1;
          var backquoteEndLoc = createPositionWithColumnOffset(_loc.start, 1);
          var startToken = void 0;

          if (input.charCodeAt(_start) === 96) {
            startToken = new Token({
              type: getExportedToken(22),
              value: "`",
              start: _start,
              end: backquoteEnd,
              startLoc: _loc.start,
              endLoc: backquoteEndLoc
            });
          } else {
            startToken = new Token({
              type: getExportedToken(8),
              value: "}",
              start: _start,
              end: backquoteEnd,
              startLoc: _loc.start,
              endLoc: backquoteEndLoc
            });
          }

          var templateValue = void 0,
              templateElementEnd = void 0,
              templateElementEndLoc = void 0,
              endToken = void 0;

          if (type === 24) {
            templateElementEnd = _end - 1;
            templateElementEndLoc = createPositionWithColumnOffset(_loc.end, -1);
            templateValue = _value === null ? null : _value.slice(1, -1);
            endToken = new Token({
              type: getExportedToken(22),
              value: "`",
              start: templateElementEnd,
              end: _end,
              startLoc: templateElementEndLoc,
              endLoc: _loc.end
            });
          } else {
            templateElementEnd = _end - 2;
            templateElementEndLoc = createPositionWithColumnOffset(_loc.end, -2);
            templateValue = _value === null ? null : _value.slice(1, -2);
            endToken = new Token({
              type: getExportedToken(23),
              value: "${",
              start: templateElementEnd,
              end: _end,
              startLoc: templateElementEndLoc,
              endLoc: _loc.end
            });
          }

          tokens.splice(i, 1, startToken, new Token({
            type: getExportedToken(20),
            value: templateValue,
            start: backquoteEnd,
            end: templateElementEnd,
            startLoc: backquoteEndLoc,
            endLoc: templateElementEndLoc
          }), endToken);
          i += 2;
          continue;
        }
      }
      token.type = getExportedToken(type);
    }
  }

  return tokens;
}

var StatementParser =
/*#__PURE__*/
function (_ExpressionParser) {
  _inherits(StatementParser, _ExpressionParser);

  function StatementParser() {
    _classCallCheck(this, StatementParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(StatementParser).apply(this, arguments));
  }

  _createClass(StatementParser, [{
    key: "parseTopLevel",
    value: function parseTopLevel(file, program) {
      file.program = this.parseProgram(program);
      file.comments = this.state.comments;

      if (this.options.tokens) {
        file.tokens = babel7CompatTokens(this.tokens, this.input);
      }

      return this.finishNode(file, "File");
    }
  }, {
    key: "parseProgram",
    value: function parseProgram(program) {
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 135;
      var sourceType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.options.sourceType;
      program.sourceType = sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, end);

      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (var _i6 = 0, _Array$from2 = Array.from(this.scope.undefinedExports); _i6 < _Array$from2.length; _i6++) {
          var _Array$from2$_i = _slicedToArray(_Array$from2[_i6], 2),
              localName = _Array$from2$_i[0],
              at = _Array$from2$_i[1];

          this.raise(Errors.ModuleExportUndefined, {
            at: at,
            localName: localName
          });
        }
      }

      return this.finishNode(program, "Program");
    }
  }, {
    key: "stmtToDirective",
    value: function stmtToDirective(stmt) {
      var directive = stmt;
      directive.type = "Directive";
      directive.value = directive.expression;
      delete directive.expression;
      var directiveLiteral = directive.value;
      var expressionValue = directiveLiteral.value;
      var raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
      var val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      this.addExtra(directiveLiteral, "expressionValue", expressionValue);
      directiveLiteral.type = "DirectiveLiteral";
      return directive;
    }
  }, {
    key: "parseInterpreterDirective",
    value: function parseInterpreterDirective() {
      if (!this.match(28)) {
        return null;
      }

      var node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    }
  }, {
    key: "isLet",
    value: function isLet(context) {
      if (!this.isContextual(99)) {
        return false;
      }

      return this.isLetKeyword(context);
    }
  }, {
    key: "isLetKeyword",
    value: function isLetKeyword(context) {
      var next = this.nextTokenStart();
      var nextCh = this.codePointAtPos(next);

      if (nextCh === 92 || nextCh === 91) {
        return true;
      }

      if (context) return false;
      if (nextCh === 123) return true;

      if (isIdentifierStart(nextCh)) {
        keywordRelationalOperator.lastIndex = next;

        if (keywordRelationalOperator.test(this.input)) {
          var endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);

          if (!isIdentifierChar(endCh) && endCh !== 92) {
            return false;
          }
        }

        return true;
      }

      return false;
    }
  }, {
    key: "parseStatement",
    value: function parseStatement(context, topLevel) {
      if (this.match(26)) {
        this.parseDecorators(true);
      }

      return this.parseStatementContent(context, topLevel);
    }
  }, {
    key: "parseStatementContent",
    value: function parseStatementContent(context, topLevel) {
      var starttype = this.state.type;
      var node = this.startNode();
      var kind;

      if (this.isLet(context)) {
        starttype = 74;
        kind = "let";
      }

      switch (starttype) {
        case 60:
          return this.parseBreakContinueStatement(node, true);

        case 63:
          return this.parseBreakContinueStatement(node, false);

        case 64:
          return this.parseDebuggerStatement(node);

        case 90:
          return this.parseDoStatement(node);

        case 91:
          return this.parseForStatement(node);

        case 68:
          if (this.lookaheadCharCode() === 46) break;

          if (context) {
            if (this.state.strict) {
              this.raise(Errors.StrictFunction, {
                at: this.state.startLoc
              });
            } else if (context !== "if" && context !== "label") {
              this.raise(Errors.SloppyFunction, {
                at: this.state.startLoc
              });
            }
          }

          return this.parseFunctionStatement(node, false, !context);

        case 80:
          if (context) this.unexpected();
          return this.parseClass(node, true);

        case 69:
          return this.parseIfStatement(node);

        case 70:
          return this.parseReturnStatement(node);

        case 71:
          return this.parseSwitchStatement(node);

        case 72:
          return this.parseThrowStatement(node);

        case 73:
          return this.parseTryStatement(node);

        case 75:
        case 74:
          kind = kind || this.state.value;

          if (context && kind !== "var") {
            this.raise(Errors.UnexpectedLexicalDeclaration, {
              at: this.state.startLoc
            });
          }

          return this.parseVarStatement(node, kind);

        case 92:
          return this.parseWhileStatement(node);

        case 76:
          return this.parseWithStatement(node);

        case 5:
          return this.parseBlock();

        case 13:
          return this.parseEmptyStatement(node);

        case 83:
          {
            var nextTokenCharCode = this.lookaheadCharCode();

            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }

        case 82:
          {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, {
                at: this.state.startLoc
              });
            }

            this.next();
            var result;

            if (starttype === 83) {
              result = this.parseImport(node);

              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);

              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }

            this.assertModuleNodeAllowed(result);
            return result;
          }

        default:
          {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                  at: this.state.startLoc
                });
              }

              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
      }

      var maybeName = this.state.value;
      var expr = this.parseExpression();

      if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    }
  }, {
    key: "assertModuleNodeAllowed",
    value: function assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(Errors.ImportOutsideModule, {
          at: node
        });
      }
    }
  }, {
    key: "takeDecorators",
    value: function takeDecorators(node) {
      var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    }
  }, {
    key: "canHaveLeadingDecorator",
    value: function canHaveLeadingDecorator() {
      return this.match(80);
    }
  }, {
    key: "parseDecorators",
    value: function parseDecorators(allowExport) {
      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      while (this.match(26)) {
        var decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }

      if (this.match(82)) {
        if (!allowExport) {
          this.unexpected();
        }

        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(Errors.DecoratorExportClass, {
            at: this.state.startLoc
          });
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(Errors.UnexpectedLeadingDecorator, {
          at: this.state.startLoc
        });
      }
    }
  }, {
    key: "parseDecorator",
    value: function parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      var node = this.startNode();
      this.next();

      if (this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var expr;

        if (this.match(10)) {
          var _startPos2 = this.state.start;
          var _startLoc2 = this.state.startLoc;
          this.next();
          expr = this.parseExpression();
          this.expect(11);
          expr = this.wrapParenthesis(_startPos2, _startLoc2, expr);
          var paramsStartLoc = this.state.startLoc;
          node.expression = this.parseMaybeDecoratorArguments(expr);

          if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
            this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
              at: paramsStartLoc
            });
          }
        } else {
          expr = this.parseIdentifier(false);

          while (this.eat(16)) {
            var _node11 = this.startNodeAt(startPos, startLoc);

            _node11.object = expr;

            if (this.match(134)) {
              this.classScope.usePrivateName(this.state.value, this.state.startLoc);
              _node11.property = this.parsePrivateName();
            } else {
              _node11.property = this.parseIdentifier(true);
            }

            _node11.computed = false;
            expr = this.finishNode(_node11, "MemberExpression");
          }

          node.expression = this.parseMaybeDecoratorArguments(expr);
        }

        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }

      return this.finishNode(node, "Decorator");
    }
  }, {
    key: "parseMaybeDecoratorArguments",
    value: function parseMaybeDecoratorArguments(expr) {
      if (this.eat(10)) {
        var node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(11, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }

      return expr;
    }
  }, {
    key: "parseBreakContinueStatement",
    value: function parseBreakContinueStatement(node, isBreak) {
      this.next();

      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }

      this.verifyBreakContinue(node, isBreak);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }
  }, {
    key: "verifyBreakContinue",
    value: function verifyBreakContinue(node, isBreak) {
      var i;

      for (i = 0; i < this.state.labels.length; ++i) {
        var lab = this.state.labels[i];

        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }

      if (i === this.state.labels.length) {
        var type = isBreak ? "BreakStatement" : "ContinueStatement";
        this.raise(Errors.IllegalBreakContinue, {
          at: node,
          type: type
        });
      }
    }
  }, {
    key: "parseDebuggerStatement",
    value: function parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    }
  }, {
    key: "parseHeaderExpression",
    value: function parseHeaderExpression() {
      this.expect(10);
      var val = this.parseExpression();
      this.expect(11);
      return val;
    }
  }, {
    key: "parseDoStatement",
    value: function parseDoStatement(node) {
      var _this59 = this;

      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return _this59.parseStatement("do");
      });
      this.state.labels.pop();
      this.expect(92);
      node.test = this.parseHeaderExpression();
      this.eat(13);
      return this.finishNode(node, "DoWhileStatement");
    }
  }, {
    key: "parseForStatement",
    value: function parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      var awaitAt = null;

      if (this.isAwaitAllowed() && this.eatContextual(96)) {
        awaitAt = this.state.lastTokStartLoc;
      }

      this.scope.enter(SCOPE_OTHER);
      this.expect(10);

      if (this.match(13)) {
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, null);
      }

      var startsWithLet = this.isContextual(99);
      var isLet = startsWithLet && this.isLetKeyword();

      if (this.match(74) || this.match(75) || isLet) {
        var initNode = this.startNode();
        var kind = isLet ? "let" : this.state.value;
        this.next();
        this.parseVar(initNode, true, kind);

        var _init = this.finishNode(initNode, "VariableDeclaration");

        if ((this.match(58) || this.isContextual(101)) && _init.declarations.length === 1) {
          return this.parseForIn(node, _init, awaitAt);
        }

        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, _init);
      }

      var startsWithAsync = this.isContextual(95);
      var refExpressionErrors = new ExpressionErrors();
      var init = this.parseExpression(true, refExpressionErrors);
      var isForOf = this.isContextual(101);

      if (isForOf) {
        if (startsWithLet) {
          this.raise(Errors.ForOfLet, {
            at: init
          });
        }

        if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
          this.raise(Errors.ForOfAsync, {
            at: init
          });
        }
      }

      if (isForOf || this.match(58)) {
        this.checkDestructuringPrivate(refExpressionErrors);
        this.toAssignable(init, true);
        var type = isForOf ? "ForOfStatement" : "ForInStatement";
        this.checkLVal(init, {
          "in": {
            type: type
          }
        });
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      if (awaitAt !== null) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }
  }, {
    key: "parseFunctionStatement",
    value: function parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
    }
  }, {
    key: "parseIfStatement",
    value: function parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(66) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    }
  }, {
    key: "parseReturnStatement",
    value: function parseReturnStatement(node) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
        this.raise(Errors.IllegalReturn, {
          at: this.state.startLoc
        });
      }

      this.next();

      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }

      return this.finishNode(node, "ReturnStatement");
    }
  }, {
    key: "parseSwitchStatement",
    value: function parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      var cases = node.cases = [];
      this.expect(5);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      var cur;

      for (var sawDefault; !this.match(8);) {
        if (this.match(61) || this.match(65)) {
          var isCase = this.match(61);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();

          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(Errors.MultipleDefaultsInSwitch, {
                at: this.state.lastTokStartLoc
              });
            }

            sawDefault = true;
            cur.test = null;
          }

          this.expect(14);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }

      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    }
  }, {
    key: "parseThrowStatement",
    value: function parseThrowStatement(node) {
      this.next();

      if (this.hasPrecedingLineBreak()) {
        this.raise(Errors.NewlineAfterThrow, {
          at: this.state.lastTokEndLoc
        });
      }

      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    }
  }, {
    key: "parseCatchClauseParam",
    value: function parseCatchClauseParam() {
      var param = this.parseBindingAtom();
      var simple = param.type === "Identifier";
      this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(param, {
        "in": {
          type: "CatchClause"
        },
        binding: BIND_LEXICAL,
        allowingSloppyLetBinding: true
      });
      return param;
    }
  }, {
    key: "parseTryStatement",
    value: function parseTryStatement(node) {
      var _this60 = this;

      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.match(62)) {
        var clause = this.startNode();
        this.next();

        if (this.match(10)) {
          this.expect(10);
          clause.param = this.parseCatchClauseParam();
          this.expect(11);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }

        clause.body = this.withSmartMixTopicForbiddingContext(function () {
          return _this60.parseBlock(false, false);
        });
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }

      node.finalizer = this.eat(67) ? this.parseBlock() : null;

      if (!node.handler && !node.finalizer) {
        this.raise(Errors.NoCatchOrFinally, {
          at: node
        });
      }

      return this.finishNode(node, "TryStatement");
    }
  }, {
    key: "parseVarStatement",
    value: function parseVarStatement(node, kind) {
      var allowMissingInitializer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.next();
      this.parseVar(node, false, kind, allowMissingInitializer);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    }
  }, {
    key: "parseWhileStatement",
    value: function parseWhileStatement(node) {
      var _this61 = this;

      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return _this61.parseStatement("while");
      });
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    }
  }, {
    key: "parseWithStatement",
    value: function parseWithStatement(node) {
      var _this62 = this;

      if (this.state.strict) {
        this.raise(Errors.StrictWith, {
          at: this.state.startLoc
        });
      }

      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return _this62.parseStatement("with");
      });
      return this.finishNode(node, "WithStatement");
    }
  }, {
    key: "parseEmptyStatement",
    value: function parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    }
  }, {
    key: "parseLabeledStatement",
    value: function parseLabeledStatement(node, maybeName, expr, context) {
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = this.state.labels[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var _label = _step12.value;

          if (_label.name === maybeName) {
            this.raise(Errors.LabelRedeclaration, {
              at: expr,
              labelName: maybeName
            });
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
            _iterator12["return"]();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      var kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;

      for (var i = this.state.labels.length - 1; i >= 0; i--) {
        var label = this.state.labels[i];

        if (label.statementStart === node.start) {
          label.statementStart = this.state.start;
          label.kind = kind;
        } else {
          break;
        }
      }

      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start
      });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    }
  }, {
    key: "parseExpressionStatement",
    value: function parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    }
  }, {
    key: "parseBlock",
    value: function parseBlock() {
      var allowDirectives = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var createNewLexicalScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var afterBlockParse = arguments.length > 2 ? arguments[2] : undefined;
      var node = this.startNode();

      if (allowDirectives) {
        this.state.strictErrors.clear();
      }

      this.expect(5);

      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }

      this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);

      if (createNewLexicalScope) {
        this.scope.exit();
      }

      return this.finishNode(node, "BlockStatement");
    }
  }, {
    key: "isValidDirective",
    value: function isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
  }, {
    key: "parseBlockBody",
    value: function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      var body = node.body = [];
      var directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    }
  }, {
    key: "parseBlockOrModuleBlockBody",
    value: function parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      var oldStrict = this.state.strict;
      var hasStrictModeDirective = false;
      var parsedNonDirective = false;

      while (!this.match(end)) {
        var stmt = this.parseStatement(null, topLevel);

        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            var directive = this.stmtToDirective(stmt);
            directives.push(directive);

            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }

            continue;
          }

          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }

        body.push(stmt);
      }

      if (afterBlockParse) {
        afterBlockParse.call(this, hasStrictModeDirective);
      }

      if (!oldStrict) {
        this.setStrict(false);
      }

      this.next();
    }
  }, {
    key: "parseFor",
    value: function parseFor(node, init) {
      var _this63 = this;

      node.init = init;
      this.semicolon(false);
      node.test = this.match(13) ? null : this.parseExpression();
      this.semicolon(false);
      node.update = this.match(11) ? null : this.parseExpression();
      this.expect(11);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return _this63.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    }
  }, {
    key: "parseForIn",
    value: function parseForIn(node, init, awaitAt) {
      var _this64 = this;

      var isForIn = this.match(58);
      this.next();

      if (isForIn) {
        if (awaitAt !== null) this.unexpected(awaitAt);
      } else {
        node["await"] = awaitAt !== null;
      }

      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(Errors.ForInOfLoopInitializer, {
          at: init,
          type: isForIn ? "ForInStatement" : "ForOfStatement"
        });
      }

      if (init.type === "AssignmentPattern") {
        this.raise(Errors.InvalidLhs, {
          at: init,
          ancestor: {
            type: "ForStatement"
          }
        });
      }

      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(11);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return _this64.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }
  }, {
    key: "parseVar",
    value: function parseVar(node, isFor, kind) {
      var allowMissingInitializer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var declarations = node.declarations = [];
      node.kind = kind;

      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();

        if (decl.init === null && !allowMissingInitializer) {
          if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
            this.raise(Errors.DeclarationMissingInitializer, {
              at: this.state.lastTokEndLoc,
              kind: "destructuring"
            });
          } else if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
            this.raise(Errors.DeclarationMissingInitializer, {
              at: this.state.lastTokEndLoc,
              kind: "const"
            });
          }
        }

        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(12)) break;
      }

      return node;
    }
  }, {
    key: "parseVarId",
    value: function parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, {
        "in": {
          type: "VariableDeclarator"
        },
        binding: kind === "var" ? BIND_VAR : BIND_LEXICAL
      });
    }
  }, {
    key: "parseFunction",
    value: function parseFunction(node) {
      var _this65 = this;

      var statement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FUNC_NO_FLAGS;
      var isAsync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var isStatement = statement & FUNC_STATEMENT;
      var isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      var requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);

      if (this.match(55) && isHangingStatement) {
        this.raise(Errors.GeneratorInSingleStatementContext, {
          at: this.state.startLoc
        });
      }

      node.generator = this.eat(55);

      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }

      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(SCOPE_FUNCTION);
      this.prodParam.enter(functionFlags(isAsync, node.generator));

      if (!isStatement) {
        node.id = this.parseFunctionId();
      }

      this.parseFunctionParams(node, false);
      this.withSmartMixTopicForbiddingContext(function () {
        _this65.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();

      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }
  }, {
    key: "parseFunctionId",
    value: function parseFunctionId(requireId) {
      return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    }
  }, {
    key: "parseFunctionParams",
    value: function parseFunctionParams(node, allowModifiers) {
      this.expect(10);
      this.expressionScope.enter(newParameterDeclarationScope());
      node.params = this.parseBindingList(11, 41, false, allowModifiers);
      this.expressionScope.exit();
    }
  }, {
    key: "registerFunctionStatementId",
    value: function registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);
    }
  }, {
    key: "parseClass",
    value: function parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      var oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
  }, {
    key: "isClassProperty",
    value: function isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
  }, {
    key: "isClassMethod",
    value: function isClassMethod() {
      return this.match(10);
    }
  }, {
    key: "isNonstaticConstructor",
    value: function isNonstaticConstructor(method) {
      return !method.computed && !method["static"] && (method.key.name === "constructor" || method.key.value === "constructor");
    }
  }, {
    key: "parseClassBody",
    value: function parseClassBody(hadSuperClass, oldStrict) {
      var _this66 = this;

      this.classScope.enter();
      var state = {
        hadConstructor: false,
        hadSuperClass: hadSuperClass
      };
      var decorators = [];
      var classBody = this.startNode();
      classBody.body = [];
      this.expect(5);
      this.withSmartMixTopicForbiddingContext(function () {
        while (!_this66.match(8)) {
          if (_this66.eat(13)) {
            if (decorators.length > 0) {
              throw _this66.raise(Errors.DecoratorSemicolon, {
                at: _this66.state.lastTokEndLoc
              });
            }

            continue;
          }

          if (_this66.match(26)) {
            decorators.push(_this66.parseDecorator());
            continue;
          }

          var member = _this66.startNode();

          if (decorators.length) {
            member.decorators = decorators;

            _this66.resetStartLocationFromNode(member, decorators[0]);

            decorators = [];
          }

          _this66.parseClassMember(classBody, member, state);

          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            _this66.raise(Errors.DecoratorConstructor, {
              at: member
            });
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();

      if (decorators.length) {
        throw this.raise(Errors.TrailingDecorator, {
          at: this.state.startLoc
        });
      }

      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    }
  }, {
    key: "parseClassMemberFromModifier",
    value: function parseClassMemberFromModifier(classBody, member) {
      var key = this.parseIdentifier(true);

      if (this.isClassMethod()) {
        var method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method["static"] = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        var prop = member;
        prop.computed = false;
        prop.key = key;
        prop["static"] = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }

      this.resetPreviousNodeTrailingComments(key);
      return false;
    }
  }, {
    key: "parseClassMember",
    value: function parseClassMember(classBody, member, state) {
      var isStatic = this.isContextual(104);

      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }

        if (this.eat(5)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }

      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
  }, {
    key: "parseClassMemberWithIsStatic",
    value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      var publicMethod = member;
      var privateMethod = member;
      var publicProp = member;
      var privateProp = member;
      var accessorProp = member;
      var method = publicMethod;
      var publicMember = publicMethod;
      member["static"] = isStatic;
      this.parsePropertyNamePrefixOperator(member);

      if (this.eat(55)) {
        method.kind = "method";
        var isPrivateName = this.match(134);
        this.parseClassElementName(method);

        if (isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }

        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors.ConstructorIsGenerator, {
            at: publicMethod.key
          });
        }

        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }

      var isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
      var isPrivate = this.match(134);
      var key = this.parseClassElementName(member);
      var maybeQuestionTokenStartLoc = this.state.startLoc;
      this.parsePostMemberNameModifiers(publicMember);

      if (this.isClassMethod()) {
        method.kind = "method";

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }

        var isConstructor = this.isNonstaticConstructor(publicMethod);
        var allowsDirectSuper = false;

        if (isConstructor) {
          publicMethod.kind = "constructor";

          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(Errors.DuplicateConstructor, {
              at: key
            });
          }

          if (isConstructor && this.hasPlugin("typescript") && member.override) {
            this.raise(Errors.OverrideOnConstructor, {
              at: key
            });
          }

          state.hadConstructor = true;
          allowsDirectSuper = state.hadSuperClass;
        }

        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(key);
        var isGenerator = this.eat(55);

        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStartLoc);
        }

        method.kind = "method";

        var _isPrivate = this.match(134);

        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);

        if (_isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsAsync, {
              at: publicMethod.key
            });
          }

          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(key);
        method.kind = key.name;

        var _isPrivate2 = this.match(134);

        this.parseClassElementName(publicMethod);

        if (_isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsAccessor, {
              at: publicMethod.key
            });
          }

          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }

        this.checkGetterSetterParams(publicMethod);
      } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors");
        this.resetPreviousNodeTrailingComments(key);

        var _isPrivate3 = this.match(134);

        this.parseClassElementName(publicProp);
        this.pushClassAccessorProperty(classBody, accessorProp, _isPrivate3);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }
  }, {
    key: "parseClassElementName",
    value: function parseClassElementName(member) {
      var _this$state7 = this.state,
          type = _this$state7.type,
          value = _this$state7.value;

      if ((type === 128 || type === 129) && member["static"] && value === "prototype") {
        this.raise(Errors.StaticPrototype, {
          at: this.state.startLoc
        });
      }

      if (type === 134) {
        if (value === "constructor") {
          this.raise(Errors.ConstructorClassPrivateField, {
            at: this.state.startLoc
          });
        }

        var key = this.parsePrivateName();
        member.key = key;
        return key;
      }

      return this.parsePropertyName(member);
    }
  }, {
    key: "parseClassStaticBlock",
    value: function parseClassStaticBlock(classBody, member) {
      var _member$decorators;

      this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
      var oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(PARAM);
      var body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
      this.prodParam.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, "StaticBlock"));

      if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
        this.raise(Errors.DecoratorStaticBlock, {
          at: member
        });
      }
    }
  }, {
    key: "pushClassProperty",
    value: function pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(Errors.ConstructorClassField, {
          at: prop.key
        });
      }

      classBody.body.push(this.parseClassProperty(prop));
    }
  }, {
    key: "pushClassPrivateProperty",
    value: function pushClassPrivateProperty(classBody, prop) {
      var node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
    }
  }, {
    key: "pushClassAccessorProperty",
    value: function pushClassAccessorProperty(classBody, prop, isPrivate) {
      if (!isPrivate && !prop.computed) {
        var key = prop.key;

        if (key.name === "constructor" || key.value === "constructor") {
          this.raise(Errors.ConstructorClassField, {
            at: key
          });
        }
      }

      var node = this.parseClassAccessorProperty(prop);
      classBody.body.push(node);

      if (isPrivate) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
      }
    }
  }, {
    key: "pushClassMethod",
    value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }
  }, {
    key: "pushClassPrivateMethod",
    value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      var node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node);
      var kind = node.kind === "get" ? node["static"] ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node["static"] ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
      this.declareClassPrivateMethodInScope(node, kind);
    }
  }, {
    key: "declareClassPrivateMethodInScope",
    value: function declareClassPrivateMethodInScope(node, kind) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
    }
  }, {
    key: "parsePostMemberNameModifiers",
    value: function parsePostMemberNameModifiers(methodOrProp) {}
  }, {
    key: "parseClassPrivateProperty",
    value: function parseClassPrivateProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassPrivateProperty");
    }
  }, {
    key: "parseClassProperty",
    value: function parseClassProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassProperty");
    }
  }, {
    key: "parseClassAccessorProperty",
    value: function parseClassAccessorProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassAccessorProperty");
    }
  }, {
    key: "parseInitializer",
    value: function parseInitializer(node) {
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(PARAM);
      node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    }
  }, {
    key: "parseClassId",
    value: function parseClassId(node, isStatement, optionalId) {
      var bindingType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BIND_CLASS;

      if (tokenIsIdentifier(this.state.type)) {
        node.id = this.parseIdentifier();

        if (isStatement) {
          this.declareNameFromIdentifier(node.id, bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          throw this.raise(Errors.MissingClassName, {
            at: this.state.startLoc
          });
        }
      }
    }
  }, {
    key: "parseClassSuper",
    value: function parseClassSuper(node) {
      node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
  }, {
    key: "parseExport",
    value: function parseExport(node) {
      var hasDefault = this.maybeParseExportDefaultSpecifier(node);
      var parseAfterDefault = !hasDefault || this.eat(12);
      var hasStar = parseAfterDefault && this.eatExportStar(node);
      var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
      var isFromRequired = hasDefault || hasStar;

      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }

      var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
        throw this.unexpected(null, 5);
      }

      var hasDeclaration;

      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }

      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      if (this.eat(65)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      }

      throw this.unexpected(null, 5);
    }
  }, {
    key: "eatExportStar",
    value: function eatExportStar(node) {
      return this.eat(55);
    }
  }, {
    key: "maybeParseExportDefaultSpecifier",
    value: function maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseExportNamespaceSpecifier",
    value: function maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual(93)) {
        if (!node.specifiers) node.specifiers = [];
        var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseModuleExportName();
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseExportNamedSpecifiers",
    value: function maybeParseExportNamedSpecifiers(node) {
      if (this.match(5)) {
        var _node$specifiers;

        if (!node.specifiers) node.specifiers = [];
        var isTypeExport = node.exportKind === "type";

        (_node$specifiers = node.specifiers).push.apply(_node$specifiers, _toConsumableArray(this.parseExportSpecifiers(isTypeExport)));

        node.source = null;
        node.declaration = null;

        if (this.hasPlugin("importAssertions")) {
          node.assertions = [];
        }

        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseExportDeclaration",
    value: function maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;

        if (this.hasPlugin("importAssertions")) {
          node.assertions = [];
        }

        node.declaration = this.parseExportDeclaration(node);
        return true;
      }

      return false;
    }
  }, {
    key: "isAsyncFunction",
    value: function isAsyncFunction() {
      if (!this.isContextual(95)) return false;
      var next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    }
  }, {
    key: "parseExportDefaultExpression",
    value: function parseExportDefaultExpression() {
      var expr = this.startNode();
      var isAsync = this.isAsyncFunction();

      if (this.match(68) || isAsync) {
        this.next();

        if (isAsync) {
          this.next();
        }

        return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
      }

      if (this.match(80)) {
        return this.parseClass(expr, true, true);
      }

      if (this.match(26)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(Errors.DecoratorBeforeExport, {
            at: this.state.startLoc
          });
        }

        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      }

      if (this.match(75) || this.match(74) || this.isLet()) {
        throw this.raise(Errors.UnsupportedDefaultExport, {
          at: this.state.startLoc
        });
      }

      var res = this.parseMaybeAssignAllowIn();
      this.semicolon();
      return res;
    }
  }, {
    key: "parseExportDeclaration",
    value: function parseExportDeclaration(node) {
      return this.parseStatement(null);
    }
  }, {
    key: "isExportDefaultSpecifier",
    value: function isExportDefaultSpecifier() {
      var type = this.state.type;

      if (tokenIsIdentifier(type)) {
        if (type === 95 && !this.state.containsEsc || type === 99) {
          return false;
        }

        if ((type === 126 || type === 125) && !this.state.containsEsc) {
          var _this$lookahead = this.lookahead(),
              nextType = _this$lookahead.type;

          if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(65)) {
        return false;
      }

      var next = this.nextTokenStart();
      var hasFrom = this.isUnparsedContextual(next, "from");

      if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
        return true;
      }

      if (this.match(65) && hasFrom) {
        var nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }

      return false;
    }
  }, {
    key: "parseExportFrom",
    value: function parseExportFrom(node, expect) {
      if (this.eatContextual(97)) {
        node.source = this.parseImportSource();
        this.checkExport(node);
        var assertions = this.maybeParseImportAssertions();

        if (assertions) {
          node.assertions = assertions;
          this.checkJSONModuleImport(node);
        }
      } else if (expect) {
        this.unexpected();
      }

      this.semicolon();
    }
  }, {
    key: "shouldParseExportDeclaration",
    value: function shouldParseExportDeclaration() {
      var type = this.state.type;

      if (type === 26) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);

        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            throw this.raise(Errors.DecoratorBeforeExport, {
              at: this.state.startLoc
            });
          }

          return true;
        }
      }

      return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
    }
  }, {
    key: "checkExport",
    value: function checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");

          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;

            var declaration = node.declaration;

            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
              this.raise(Errors.ExportDefaultFromAsIdentifier, {
                at: declaration
              });
            }
          }
        } else if (node.specifiers && node.specifiers.length) {
          var _iteratorNormalCompletion13 = true;
          var _didIteratorError13 = false;
          var _iteratorError13 = undefined;

          try {
            for (var _iterator13 = node.specifiers[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
              var specifier = _step13.value;
              var exported = specifier.exported;
              var exportName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportName);

              if (!isFrom && specifier.local) {
                var local = specifier.local;

                if (local.type !== "Identifier") {
                  this.raise(Errors.ExportBindingIsString, {
                    at: specifier,
                    localName: local.value,
                    exportName: exportName
                  });
                } else {
                  this.checkReservedWord(local.name, local.loc.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } catch (err) {
            _didIteratorError13 = true;
            _iteratorError13 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
                _iterator13["return"]();
              }
            } finally {
              if (_didIteratorError13) {
                throw _iteratorError13;
              }
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            var id = node.declaration.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            var _iteratorNormalCompletion14 = true;
            var _didIteratorError14 = false;
            var _iteratorError14 = undefined;

            try {
              for (var _iterator14 = node.declaration.declarations[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                var _declaration = _step14.value;
                this.checkDeclaration(_declaration.id);
              }
            } catch (err) {
              _didIteratorError14 = true;
              _iteratorError14 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
                  _iterator14["return"]();
                }
              } finally {
                if (_didIteratorError14) {
                  throw _iteratorError14;
                }
              }
            }
          }
        }
      }

      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (currentContextDecorators.length) {
        throw this.raise(Errors.UnsupportedDecoratorExport, {
          at: node
        });
      }
    }
  }, {
    key: "checkDeclaration",
    value: function checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        var _iteratorNormalCompletion15 = true;
        var _didIteratorError15 = false;
        var _iteratorError15 = undefined;

        try {
          for (var _iterator15 = node.properties[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
            var prop = _step15.value;
            this.checkDeclaration(prop);
          }
        } catch (err) {
          _didIteratorError15 = true;
          _iteratorError15 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
              _iterator15["return"]();
            }
          } finally {
            if (_didIteratorError15) {
              throw _iteratorError15;
            }
          }
        }
      } else if (node.type === "ArrayPattern") {
        var _iteratorNormalCompletion16 = true;
        var _didIteratorError16 = false;
        var _iteratorError16 = undefined;

        try {
          for (var _iterator16 = node.elements[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
            var elem = _step16.value;

            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } catch (err) {
          _didIteratorError16 = true;
          _iteratorError16 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
              _iterator16["return"]();
            }
          } finally {
            if (_didIteratorError16) {
              throw _iteratorError16;
            }
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    }
  }, {
    key: "checkDuplicateExports",
    value: function checkDuplicateExports(node, exportName) {
      if (this.exportedIdentifiers.has(exportName)) {
        if (exportName === "default") {
          this.raise(Errors.DuplicateDefaultExport, {
            at: node
          });
        } else {
          this.raise(Errors.DuplicateExport, {
            at: node,
            exportName: exportName
          });
        }
      }

      this.exportedIdentifiers.add(exportName);
    }
  }, {
    key: "parseExportSpecifiers",
    value: function parseExportSpecifiers(isInTypeExport) {
      var nodes = [];
      var first = true;
      this.expect(5);

      while (!this.eat(8)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.eat(8)) break;
        }

        var isMaybeTypeOnly = this.isContextual(126);
        var isString = this.match(129);
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
      }

      return nodes;
    }
  }, {
    key: "parseExportSpecifier",
    value: function parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
      if (this.eatContextual(93)) {
        node.exported = this.parseModuleExportName();
      } else if (isString) {
        node.exported = cloneStringLiteral(node.local);
      } else if (!node.exported) {
        node.exported = cloneIdentifier(node.local);
      }

      return this.finishNode(node, "ExportSpecifier");
    }
  }, {
    key: "parseModuleExportName",
    value: function parseModuleExportName() {
      if (this.match(129)) {
        var result = this.parseStringLiteral(this.state.value);
        var surrogate = result.value.match(loneSurrogate);

        if (surrogate) {
          this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
            at: result,
            surrogateCharCode: surrogate[0].charCodeAt(0)
          });
        }

        return result;
      }

      return this.parseIdentifier(true);
    }
  }, {
    key: "isJSONModuleImport",
    value: function isJSONModuleImport(node) {
      if (node.assertions != null) {
        return node.assertions.some(function (_ref99) {
          var key = _ref99.key,
              value = _ref99.value;
          return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
        });
      }

      return false;
    }
  }, {
    key: "checkJSONModuleImport",
    value: function checkJSONModuleImport(node) {
      if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
        var specifiers = node.specifiers;

        if (specifiers != null) {
          var nonDefaultNamedSpecifier = specifiers.find(function (specifier) {
            var imported;

            if (specifier.type === "ExportSpecifier") {
              imported = specifier.local;
            } else if (specifier.type === "ImportSpecifier") {
              imported = specifier.imported;
            }

            if (imported !== undefined) {
              return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
            }
          });

          if (nonDefaultNamedSpecifier !== undefined) {
            this.raise(Errors.ImportJSONBindingNotDefault, {
              at: nonDefaultNamedSpecifier.loc.start
            });
          }
        }
      }
    }
  }, {
    key: "parseImport",
    value: function parseImport(node) {
      node.specifiers = [];

      if (!this.match(129)) {
        var hasDefault = this.maybeParseDefaultImportSpecifier(node);
        var parseNext = !hasDefault || this.eat(12);
        var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual(97);
      }

      node.source = this.parseImportSource();
      var assertions = this.maybeParseImportAssertions();

      if (assertions) {
        node.assertions = assertions;
      } else {
        var attributes = this.maybeParseModuleAttributes();

        if (attributes) {
          node.attributes = attributes;
        }
      }

      this.checkJSONModuleImport(node);
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }
  }, {
    key: "parseImportSource",
    value: function parseImportSource() {
      if (!this.match(129)) this.unexpected();
      return this.parseExprAtom();
    }
  }, {
    key: "shouldParseDefaultImport",
    value: function shouldParseDefaultImport(node) {
      return tokenIsIdentifier(this.state.type);
    }
  }, {
    key: "parseImportSpecifierLocal",
    value: function parseImportSpecifierLocal(node, specifier, type) {
      specifier.local = this.parseIdentifier();
      node.specifiers.push(this.finishImportSpecifier(specifier, type));
    }
  }, {
    key: "finishImportSpecifier",
    value: function finishImportSpecifier(specifier, type) {
      var bindingType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BIND_LEXICAL;
      this.checkLVal(specifier.local, {
        "in": specifier,
        binding: bindingType
      });
      return this.finishNode(specifier, type);
    }
  }, {
    key: "parseAssertEntries",
    value: function parseAssertEntries() {
      var attrs = [];
      var attrNames = new Set();

      do {
        if (this.match(8)) {
          break;
        }

        var node = this.startNode();
        var keyName = this.state.value;

        if (attrNames.has(keyName)) {
          this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
            at: this.state.startLoc,
            key: keyName
          });
        }

        attrNames.add(keyName);

        if (this.match(129)) {
          node.key = this.parseStringLiteral(keyName);
        } else {
          node.key = this.parseIdentifier(true);
        }

        this.expect(14);

        if (!this.match(129)) {
          throw this.raise(Errors.ModuleAttributeInvalidValue, {
            at: this.state.startLoc
          });
        }

        node.value = this.parseStringLiteral(this.state.value);
        attrs.push(this.finishNode(node, "ImportAttribute"));
      } while (this.eat(12));

      return attrs;
    }
  }, {
    key: "maybeParseModuleAttributes",
    value: function maybeParseModuleAttributes() {
      if (this.match(76) && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("moduleAttributes");
        this.next();
      } else {
        if (this.hasPlugin("moduleAttributes")) return [];
        return null;
      }

      var attrs = [];
      var attributes = new Set();

      do {
        var node = this.startNode();
        node.key = this.parseIdentifier(true);

        if (node.key.name !== "type") {
          this.raise(Errors.ModuleAttributeDifferentFromType, {
            at: node.key
          });
        }

        if (attributes.has(node.key.name)) {
          this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
            at: node.key,
            key: node.key.name
          });
        }

        attributes.add(node.key.name);
        this.expect(14);

        if (!this.match(129)) {
          throw this.raise(Errors.ModuleAttributeInvalidValue, {
            at: this.state.startLoc
          });
        }

        node.value = this.parseStringLiteral(this.state.value);
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(12));

      return attrs;
    }
  }, {
    key: "maybeParseImportAssertions",
    value: function maybeParseImportAssertions() {
      if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("importAssertions");
        this.next();
      } else {
        if (this.hasPlugin("importAssertions")) return [];
        return null;
      }

      this.eat(5);
      var attrs = this.parseAssertEntries();
      this.eat(8);
      return attrs;
    }
  }, {
    key: "maybeParseDefaultImportSpecifier",
    value: function maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseStarImportSpecifier",
    value: function maybeParseStarImportSpecifier(node) {
      if (this.match(55)) {
        var specifier = this.startNode();
        this.next();
        this.expectContextual(93);
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
        return true;
      }

      return false;
    }
  }, {
    key: "parseNamedImportSpecifiers",
    value: function parseNamedImportSpecifiers(node) {
      var first = true;
      this.expect(5);

      while (!this.eat(8)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(14)) {
            throw this.raise(Errors.DestructureNamedImport, {
              at: this.state.startLoc
            });
          }

          this.expect(12);
          if (this.eat(8)) break;
        }

        var specifier = this.startNode();
        var importedIsString = this.match(129);
        var isMaybeTypeOnly = this.isContextual(126);
        specifier.imported = this.parseModuleExportName();
        var importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, undefined);
        node.specifiers.push(importSpecifier);
      }
    }
  }, {
    key: "parseImportSpecifier",
    value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      if (this.eatContextual(93)) {
        specifier.local = this.parseIdentifier();
      } else {
        var imported = specifier.imported;

        if (importedIsString) {
          throw this.raise(Errors.ImportBindingIsString, {
            at: specifier,
            importName: imported.value
          });
        }

        this.checkReservedWord(imported.name, specifier.loc.start, true, true);

        if (!specifier.local) {
          specifier.local = cloneIdentifier(imported);
        }
      }

      return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
    }
  }, {
    key: "isThisParam",
    value: function isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    }
  }]);

  return StatementParser;
}(ExpressionParser);

var Parser =
/*#__PURE__*/
function (_StatementParser) {
  _inherits(Parser, _StatementParser);

  function Parser(options, input) {
    var _this67;

    _classCallCheck(this, Parser);

    options = getOptions(options);
    _this67 = _possibleConstructorReturn(this, _getPrototypeOf(Parser).call(this, options, input));
    _this67.options = options;

    _this67.initializeScopes();

    _this67.plugins = pluginsMap(_this67.options.plugins);
    _this67.filename = options.sourceFilename;
    return _this67;
  }

  _createClass(Parser, [{
    key: "getScopeHandler",
    value: function getScopeHandler() {
      return ScopeHandler;
    }
  }, {
    key: "parse",
    value: function parse() {
      this.enterInitialScopes();
      var file = this.startNode();
      var program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    }
  }]);

  return Parser;
}(StatementParser);

function pluginsMap(plugins) {
  var pluginMap = new Map();
  var _iteratorNormalCompletion17 = true;
  var _didIteratorError17 = false;
  var _iteratorError17 = undefined;

  try {
    for (var _iterator17 = plugins[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
      var plugin = _step17.value;

      var _ref100 = Array.isArray(plugin) ? plugin : [plugin, {}],
          _ref101 = _slicedToArray(_ref100, 2),
          name = _ref101[0],
          options = _ref101[1];

      if (!pluginMap.has(name)) pluginMap.set(name, options || {});
    }
  } catch (err) {
    _didIteratorError17 = true;
    _iteratorError17 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
        _iterator17["return"]();
      }
    } finally {
      if (_didIteratorError17) {
        throw _iteratorError17;
      }
    }
  }

  return pluginMap;
}

function parse(input, options) {
  var _options;

  if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
    options = Object.assign({}, options);

    try {
      options.sourceType = "module";
      var parser = getParser(options, input);
      var ast = parser.parse();

      if (parser.sawUnambiguousESM) {
        return ast;
      }

      if (parser.ambiguousScriptDifferentAst) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused) {}
      } else {
        ast.program.sourceType = "script";
      }

      return ast;
    } catch (moduleError) {
      try {
        options.sourceType = "script";
        return getParser(options, input).parse();
      } catch (_unused2) {}

      throw moduleError;
    }
  } else {
    return getParser(options, input).parse();
  }
}

function parseExpression(input, options) {
  var parser = getParser(options, input);

  if (parser.options.strictMode) {
    parser.state.strict = true;
  }

  return parser.getExpression();
}

function generateExportedTokenTypes(internalTokenTypes) {
  var tokenTypes = {};

  for (var _i7 = 0, _Object$keys4 = Object.keys(internalTokenTypes); _i7 < _Object$keys4.length; _i7++) {
    var typeName = _Object$keys4[_i7];
    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);
  }

  return tokenTypes;
}

var tokTypes = generateExportedTokenTypes(tt);

function getParser(options, input) {
  var cls = Parser;

  if (options != null && options.plugins) {
    validatePlugins(options.plugins);
    cls = getParserClass(options.plugins);
  }

  return new cls(options, input);
}

var parserClassCache = {};

function getParserClass(pluginsFromOptions) {
  var pluginList = mixinPluginNames.filter(function (name) {
    return hasPlugin(pluginsFromOptions, name);
  });
  var key = pluginList.join("/");
  var cls = parserClassCache[key];

  if (!cls) {
    cls = Parser;
    var _iteratorNormalCompletion18 = true;
    var _didIteratorError18 = false;
    var _iteratorError18 = undefined;

    try {
      for (var _iterator18 = pluginList[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
        var plugin = _step18.value;
        cls = mixinPlugins[plugin](cls);
      }
    } catch (err) {
      _didIteratorError18 = true;
      _iteratorError18 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
          _iterator18["return"]();
        }
      } finally {
        if (_didIteratorError18) {
          throw _iteratorError18;
        }
      }
    }

    parserClassCache[key] = cls;
  }

  return cls;
}

exports.parse = parse;
exports.parseExpression = parseExpression;
exports.tokTypes = tokTypes;