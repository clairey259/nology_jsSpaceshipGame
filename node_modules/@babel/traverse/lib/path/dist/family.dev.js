"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._getKey = _getKey;
exports._getPattern = _getPattern;
exports.get = get;
exports.getAllNextSiblings = getAllNextSiblings;
exports.getAllPrevSiblings = getAllPrevSiblings;
exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
exports.getBindingIdentifiers = getBindingIdentifiers;
exports.getCompletionRecords = getCompletionRecords;
exports.getNextSibling = getNextSibling;
exports.getOpposite = getOpposite;
exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
exports.getPrevSibling = getPrevSibling;
exports.getSibling = getSibling;

var _index = require("./index");

var _t = require("@babel/types");

var _getBindingIdentifiers = _t.getBindingIdentifiers,
    _getOuterBindingIdentifiers = _t.getOuterBindingIdentifiers,
    isDeclaration = _t.isDeclaration,
    numericLiteral = _t.numericLiteral,
    unaryExpression = _t.unaryExpression;
var NORMAL_COMPLETION = 0;
var BREAK_COMPLETION = 1;

function NormalCompletion(path) {
  return {
    type: NORMAL_COMPLETION,
    path: path
  };
}

function BreakCompletion(path) {
  return {
    type: BREAK_COMPLETION,
    path: path
  };
}

function getOpposite() {
  if (this.key === "left") {
    return this.getSibling("right");
  } else if (this.key === "right") {
    return this.getSibling("left");
  }

  return null;
}

function addCompletionRecords(path, records, context) {
  if (path) {
    records.push.apply(records, _toConsumableArray(_getCompletionRecords(path, context)));
  }

  return records;
}

function completionRecordForSwitch(cases, records, context) {
  var lastNormalCompletions = [];

  for (var i = 0; i < cases.length; i++) {
    var casePath = cases[i];

    var caseCompletions = _getCompletionRecords(casePath, context);

    var normalCompletions = [];
    var breakCompletions = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = caseCompletions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var c = _step.value;

        if (c.type === NORMAL_COMPLETION) {
          normalCompletions.push(c);
        }

        if (c.type === BREAK_COMPLETION) {
          breakCompletions.push(c);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (normalCompletions.length) {
      lastNormalCompletions = normalCompletions;
    }

    records.push.apply(records, breakCompletions);
  }

  records.push.apply(records, _toConsumableArray(lastNormalCompletions));
  return records;
}

function normalCompletionToBreak(completions) {
  completions.forEach(function (c) {
    c.type = BREAK_COMPLETION;
  });
}

function replaceBreakStatementInBreakCompletion(completions, reachable) {
  completions.forEach(function (c) {
    if (c.path.isBreakStatement({
      label: null
    })) {
      if (reachable) {
        c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
      } else {
        c.path.remove();
      }
    }
  });
}

function getStatementListCompletion(paths, context) {
  var completions = [];

  if (context.canHaveBreak) {
    var lastNormalCompletions = [];

    for (var i = 0; i < paths.length; i++) {
      var path = paths[i];
      var newContext = Object.assign({}, context, {
        inCaseClause: false
      });

      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
        newContext.shouldPopulateBreak = true;
      } else {
        newContext.shouldPopulateBreak = false;
      }

      var statementCompletions = _getCompletionRecords(path, newContext);

      if (statementCompletions.length > 0 && statementCompletions.every(function (c) {
        return c.type === BREAK_COMPLETION;
      })) {
        if (lastNormalCompletions.length > 0 && statementCompletions.every(function (c) {
          return c.path.isBreakStatement({
            label: null
          });
        })) {
          normalCompletionToBreak(lastNormalCompletions);
          completions.push.apply(completions, _toConsumableArray(lastNormalCompletions));

          if (lastNormalCompletions.some(function (c) {
            return c.path.isDeclaration();
          })) {
            completions.push.apply(completions, _toConsumableArray(statementCompletions));
            replaceBreakStatementInBreakCompletion(statementCompletions, true);
          }

          replaceBreakStatementInBreakCompletion(statementCompletions, false);
        } else {
          completions.push.apply(completions, _toConsumableArray(statementCompletions));

          if (!context.shouldPopulateBreak) {
            replaceBreakStatementInBreakCompletion(statementCompletions, true);
          }
        }

        break;
      }

      if (i === paths.length - 1) {
        completions.push.apply(completions, _toConsumableArray(statementCompletions));
      } else {
        lastNormalCompletions = [];

        for (var _i = 0; _i < statementCompletions.length; _i++) {
          var c = statementCompletions[_i];

          if (c.type === BREAK_COMPLETION) {
            completions.push(c);
          }

          if (c.type === NORMAL_COMPLETION) {
            lastNormalCompletions.push(c);
          }
        }
      }
    }
  } else if (paths.length) {
    for (var _i2 = paths.length - 1; _i2 >= 0; _i2--) {
      var pathCompletions = _getCompletionRecords(paths[_i2], context);

      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
        completions.push.apply(completions, _toConsumableArray(pathCompletions));
        break;
      }
    }
  }

  return completions;
}

function _getCompletionRecords(path, context) {
  var records = [];

  if (path.isIfStatement()) {
    records = addCompletionRecords(path.get("consequent"), records, context);
    records = addCompletionRecords(path.get("alternate"), records, context);
  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
    return addCompletionRecords(path.get("body"), records, context);
  } else if (path.isProgram() || path.isBlockStatement()) {
    return getStatementListCompletion(path.get("body"), context);
  } else if (path.isFunction()) {
    return _getCompletionRecords(path.get("body"), context);
  } else if (path.isTryStatement()) {
    records = addCompletionRecords(path.get("block"), records, context);
    records = addCompletionRecords(path.get("handler"), records, context);
  } else if (path.isCatchClause()) {
    return addCompletionRecords(path.get("body"), records, context);
  } else if (path.isSwitchStatement()) {
    return completionRecordForSwitch(path.get("cases"), records, context);
  } else if (path.isSwitchCase()) {
    return getStatementListCompletion(path.get("consequent"), {
      canHaveBreak: true,
      shouldPopulateBreak: false,
      inCaseClause: true
    });
  } else if (path.isBreakStatement()) {
    records.push(BreakCompletion(path));
  } else {
    records.push(NormalCompletion(path));
  }

  return records;
}

function getCompletionRecords() {
  var records = _getCompletionRecords(this, {
    canHaveBreak: false,
    shouldPopulateBreak: false,
    inCaseClause: false
  });

  return records.map(function (r) {
    return r.path;
  });
}

function getSibling(key) {
  return _index["default"].get({
    parentPath: this.parentPath,
    parent: this.parent,
    container: this.container,
    listKey: this.listKey,
    key: key
  }).setContext(this.context);
}

function getPrevSibling() {
  return this.getSibling(this.key - 1);
}

function getNextSibling() {
  return this.getSibling(this.key + 1);
}

function getAllNextSiblings() {
  var _key = this.key;
  var sibling = this.getSibling(++_key);
  var siblings = [];

  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(++_key);
  }

  return siblings;
}

function getAllPrevSiblings() {
  var _key = this.key;
  var sibling = this.getSibling(--_key);
  var siblings = [];

  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(--_key);
  }

  return siblings;
}

function get(key) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (context === true) context = this.context;
  var parts = key.split(".");

  if (parts.length === 1) {
    return this._getKey(key, context);
  } else {
    return this._getPattern(parts, context);
  }
}

function _getKey(key, context) {
  var _this = this;

  var node = this.node;
  var container = node[key];

  if (Array.isArray(container)) {
    return container.map(function (_, i) {
      return _index["default"].get({
        listKey: key,
        parentPath: _this,
        parent: node,
        container: container,
        key: i
      }).setContext(context);
    });
  } else {
    return _index["default"].get({
      parentPath: this,
      parent: node,
      container: node,
      key: key
    }).setContext(context);
  }
}

function _getPattern(parts, context) {
  var path = this;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = parts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var part = _step2.value;

      if (part === ".") {
        path = path.parentPath;
      } else {
        if (Array.isArray(path)) {
          path = path[part];
        } else {
          path = path.get(part, context);
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return path;
}

function getBindingIdentifiers(duplicates) {
  return _getBindingIdentifiers(this.node, duplicates);
}

function getOuterBindingIdentifiers(duplicates) {
  return _getOuterBindingIdentifiers(this.node, duplicates);
}

function getBindingIdentifierPaths() {
  var duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var outerOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var path = this;
  var search = [path];
  var ids = Object.create(null);

  while (search.length) {
    var id = search.shift();
    if (!id) continue;
    if (!id.node) continue;
    var keys = _getBindingIdentifiers.keys[id.node.type];

    if (id.isIdentifier()) {
      if (duplicates) {
        var _ids = ids[id.node.name] = ids[id.node.name] || [];

        _ids.push(id);
      } else {
        ids[id.node.name] = id;
      }

      continue;
    }

    if (id.isExportDeclaration()) {
      var declaration = id.get("declaration");

      if (isDeclaration(declaration)) {
        search.push(declaration);
      }

      continue;
    }

    if (outerOnly) {
      if (id.isFunctionDeclaration()) {
        search.push(id.get("id"));
        continue;
      }

      if (id.isFunctionExpression()) {
        continue;
      }
    }

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var child = id.get(key);

        if (Array.isArray(child)) {
          search.push.apply(search, _toConsumableArray(child));
        } else if (child.node) {
          search.push(child);
        }
      }
    }
  }

  return ids;
}

function getOuterBindingIdentifierPaths() {
  var duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return this.getBindingIdentifierPaths(duplicates, true);
}