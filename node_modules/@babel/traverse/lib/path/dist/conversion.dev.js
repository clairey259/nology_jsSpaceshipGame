"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrowFunctionToExpression = arrowFunctionToExpression;
exports.arrowFunctionToShadowed = arrowFunctionToShadowed;
exports.ensureBlock = ensureBlock;
exports.toComputedKey = toComputedKey;
exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;

var _t = require("@babel/types");

var _helperEnvironmentVisitor = require("@babel/helper-environment-visitor");

var _helperFunctionName = require("@babel/helper-function-name");

var _visitors = require("../visitors");

var arrowFunctionExpression = _t.arrowFunctionExpression,
    assignmentExpression = _t.assignmentExpression,
    binaryExpression = _t.binaryExpression,
    blockStatement = _t.blockStatement,
    callExpression = _t.callExpression,
    conditionalExpression = _t.conditionalExpression,
    expressionStatement = _t.expressionStatement,
    identifier = _t.identifier,
    isIdentifier = _t.isIdentifier,
    jsxIdentifier = _t.jsxIdentifier,
    logicalExpression = _t.logicalExpression,
    LOGICAL_OPERATORS = _t.LOGICAL_OPERATORS,
    memberExpression = _t.memberExpression,
    metaProperty = _t.metaProperty,
    numericLiteral = _t.numericLiteral,
    objectExpression = _t.objectExpression,
    restElement = _t.restElement,
    returnStatement = _t.returnStatement,
    sequenceExpression = _t.sequenceExpression,
    spreadElement = _t.spreadElement,
    stringLiteral = _t.stringLiteral,
    _super = _t["super"],
    thisExpression = _t.thisExpression,
    toExpression = _t.toExpression,
    unaryExpression = _t.unaryExpression;

function toComputedKey() {
  var key;

  if (this.isMemberExpression()) {
    key = this.node.property;
  } else if (this.isProperty() || this.isMethod()) {
    key = this.node.key;
  } else {
    throw new ReferenceError("todo");
  }

  if (!this.node.computed) {
    if (isIdentifier(key)) key = stringLiteral(key.name);
  }

  return key;
}

function ensureBlock() {
  var body = this.get("body");
  var bodyNode = body.node;

  if (Array.isArray(body)) {
    throw new Error("Can't convert array path to a block statement");
  }

  if (!bodyNode) {
    throw new Error("Can't convert node without a body");
  }

  if (body.isBlockStatement()) {
    return bodyNode;
  }

  var statements = [];
  var stringPath = "body";
  var key;
  var listKey;

  if (body.isStatement()) {
    listKey = "body";
    key = 0;
    statements.push(body.node);
  } else {
    stringPath += ".body.0";

    if (this.isFunction()) {
      key = "argument";
      statements.push(returnStatement(body.node));
    } else {
      key = "expression";
      statements.push(expressionStatement(body.node));
    }
  }

  this.node.body = blockStatement(statements);
  var parentPath = this.get(stringPath);
  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
  return this.node;
}

function arrowFunctionToShadowed() {
  if (!this.isArrowFunctionExpression()) return;
  this.arrowFunctionToExpression();
}

function unwrapFunctionEnvironment() {
  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
  }

  hoistFunctionEnvironment(this);
}

function setType(path, type) {
  path.node.type = type;
}

function arrowFunctionToExpression() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$allowInsertArrow = _ref.allowInsertArrow,
      allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,
      _ref$specCompliant = _ref.specCompliant,
      specCompliant = _ref$specCompliant === void 0 ? false : _ref$specCompliant,
      _ref$noNewArrows = _ref.noNewArrows,
      noNewArrows = _ref$noNewArrows === void 0 ? !specCompliant : _ref$noNewArrows;

  if (!this.isArrowFunctionExpression()) {
    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
  }

  var _hoistFunctionEnviron = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow),
      thisBinding = _hoistFunctionEnviron.thisBinding,
      fn = _hoistFunctionEnviron.fnPath;

  fn.ensureBlock();
  setType(fn, "FunctionExpression");

  if (!noNewArrows) {
    var checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");

    if (checkBinding) {
      fn.parentPath.scope.push({
        id: checkBinding,
        init: objectExpression([])
      });
    }

    fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName["default"])(this, true) || fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
    return fn.get("callee.object");
  }

  return fn;
}

var getSuperCallsVisitor = (0, _visitors.merge)([{
  CallExpression: function CallExpression(child, _ref2) {
    var allSuperCalls = _ref2.allSuperCalls;
    if (!child.get("callee").isSuper()) return;
    allSuperCalls.push(child);
  }
}, _helperEnvironmentVisitor["default"]]);

function hoistFunctionEnvironment(fnPath) {
  var noNewArrows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var allowInsertArrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var arrowParent;
  var thisEnvFn = fnPath.findParent(function (p) {
    if (p.isArrowFunctionExpression()) {
      var _arrowParent;

      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;
      return false;
    }

    return p.isFunction() || p.isProgram() || p.isClassProperty({
      "static": false
    }) || p.isClassPrivateProperty({
      "static": false
    });
  });
  var inConstructor = thisEnvFn.isClassMethod({
    kind: "constructor"
  });

  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
    if (arrowParent) {
      thisEnvFn = arrowParent;
    } else if (allowInsertArrow) {
      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
      thisEnvFn = fnPath.get("callee");
      fnPath = thisEnvFn.get("body");
    } else {
      throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
    }
  }

  var _getScopeInformation = getScopeInformation(fnPath),
      thisPaths = _getScopeInformation.thisPaths,
      argumentsPaths = _getScopeInformation.argumentsPaths,
      newTargetPaths = _getScopeInformation.newTargetPaths,
      superProps = _getScopeInformation.superProps,
      superCalls = _getScopeInformation.superCalls;

  if (inConstructor && superCalls.length > 0) {
    if (!allowInsertArrow) {
      throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
    }

    var allSuperCalls = [];
    thisEnvFn.traverse(getSuperCallsVisitor, {
      allSuperCalls: allSuperCalls
    });
    var superBinding = getSuperBinding(thisEnvFn);
    allSuperCalls.forEach(function (superCall) {
      var callee = identifier(superBinding);
      callee.loc = superCall.node.callee.loc;
      superCall.get("callee").replaceWith(callee);
    });
  }

  if (argumentsPaths.length > 0) {
    var argumentsBinding = getBinding(thisEnvFn, "arguments", function () {
      var args = function args() {
        return identifier("arguments");
      };

      if (thisEnvFn.scope.path.isProgram()) {
        return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
      } else {
        return args();
      }
    });
    argumentsPaths.forEach(function (argumentsChild) {
      var argsRef = identifier(argumentsBinding);
      argsRef.loc = argumentsChild.node.loc;
      argumentsChild.replaceWith(argsRef);
    });
  }

  if (newTargetPaths.length > 0) {
    var newTargetBinding = getBinding(thisEnvFn, "newtarget", function () {
      return metaProperty(identifier("new"), identifier("target"));
    });
    newTargetPaths.forEach(function (targetChild) {
      var targetRef = identifier(newTargetBinding);
      targetRef.loc = targetChild.node.loc;
      targetChild.replaceWith(targetRef);
    });
  }

  if (superProps.length > 0) {
    if (!allowInsertArrow) {
      throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
    }

    var flatSuperProps = superProps.reduce(function (acc, superProp) {
      return acc.concat(standardizeSuperProperty(superProp));
    }, []);
    flatSuperProps.forEach(function (superProp) {
      var key = superProp.node.computed ? "" : superProp.get("property").node.name;
      var superParentPath = superProp.parentPath;
      var isAssignment = superParentPath.isAssignmentExpression({
        left: superProp.node
      });
      var isCall = superParentPath.isCallExpression({
        callee: superProp.node
      });
      var superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
      var args = [];

      if (superProp.node.computed) {
        args.push(superProp.get("property").node);
      }

      if (isAssignment) {
        var value = superParentPath.node.right;
        args.push(value);
      }

      var call = callExpression(identifier(superBinding), args);

      if (isCall) {
        superParentPath.unshiftContainer("arguments", thisExpression());
        superProp.replaceWith(memberExpression(call, identifier("call")));
        thisPaths.push(superParentPath.get("arguments.0"));
      } else if (isAssignment) {
        superParentPath.replaceWith(call);
      } else {
        superProp.replaceWith(call);
      }
    });
  }

  var thisBinding;

  if (thisPaths.length > 0 || !noNewArrows) {
    thisBinding = getThisBinding(thisEnvFn, inConstructor);

    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
      thisPaths.forEach(function (thisChild) {
        var thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
        thisRef.loc = thisChild.node.loc;
        thisChild.replaceWith(thisRef);
      });
      if (!noNewArrows) thisBinding = null;
    }
  }

  return {
    thisBinding: thisBinding,
    fnPath: fnPath
  };
}

function isLogicalOp(op) {
  return LOGICAL_OPERATORS.includes(op);
}

function standardizeSuperProperty(superProp) {
  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
    var assignmentPath = superProp.parentPath;
    var op = assignmentPath.node.operator.slice(0, -1);
    var value = assignmentPath.node.right;
    var isLogicalAssignment = isLogicalOp(op);

    if (superProp.node.computed) {
      var tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      var object = superProp.node.object;
      var property = superProp.node.property;
      assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true));
      assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value));
    } else {
      var _object = superProp.node.object;
      var _property = superProp.node.property;
      assignmentPath.get("left").replaceWith(memberExpression(_object, _property));
      assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(_object, identifier(_property.name)), value));
    }

    if (isLogicalAssignment) {
      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
    } else {
      assignmentPath.node.operator = "=";
    }

    return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
  } else if (superProp.parentPath.isUpdateExpression()) {
    var updateExpr = superProp.parentPath;

    var _tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");

    var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
    var parts = [assignmentExpression("=", _tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(_tmp.name), numericLiteral(1)))];

    if (!superProp.parentPath.node.prefix) {
      parts.push(identifier(_tmp.name));
    }

    updateExpr.replaceWith(sequenceExpression(parts));
    var left = updateExpr.get("expressions.0.right");
    var right = updateExpr.get("expressions.1.left");
    return [left, right];
  }

  return [superProp];

  function rightExpression(op, left, right) {
    if (op === "=") {
      return assignmentExpression("=", left, right);
    } else {
      return binaryExpression(op, left, right);
    }
  }
}

function hasSuperClass(thisEnvFn) {
  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
}

var assignSuperThisVisitor = (0, _visitors.merge)([{
  CallExpression: function CallExpression(child, _ref3) {
    var supers = _ref3.supers,
        thisBinding = _ref3.thisBinding;
    if (!child.get("callee").isSuper()) return;
    if (supers.has(child.node)) return;
    supers.add(child.node);
    child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
  }
}, _helperEnvironmentVisitor["default"]]);

function getThisBinding(thisEnvFn, inConstructor) {
  return getBinding(thisEnvFn, "this", function (thisBinding) {
    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
    thisEnvFn.traverse(assignSuperThisVisitor, {
      supers: new WeakSet(),
      thisBinding: thisBinding
    });
  });
}

function getSuperBinding(thisEnvFn) {
  return getBinding(thisEnvFn, "supercall", function () {
    var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
  });
}

function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
  var op = isAssignment ? "set" : "get";
  return getBinding(thisEnvFn, "superprop_".concat(op, ":").concat(propName || ""), function () {
    var argsList = [];
    var fnBody;

    if (propName) {
      fnBody = memberExpression(_super(), identifier(propName));
    } else {
      var method = thisEnvFn.scope.generateUidIdentifier("prop");
      argsList.unshift(method);
      fnBody = memberExpression(_super(), identifier(method.name), true);
    }

    if (isAssignment) {
      var valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
      argsList.push(valueIdent);
      fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
    }

    return arrowFunctionExpression(argsList, fnBody);
  });
}

function getBinding(thisEnvFn, key, init) {
  var cacheKey = "binding:" + key;
  var data = thisEnvFn.getData(cacheKey);

  if (!data) {
    var id = thisEnvFn.scope.generateUidIdentifier(key);
    data = id.name;
    thisEnvFn.setData(cacheKey, data);
    thisEnvFn.scope.push({
      id: id,
      init: init(data)
    });
  }

  return data;
}

var getScopeInformationVisitor = (0, _visitors.merge)([{
  ThisExpression: function ThisExpression(child, _ref4) {
    var thisPaths = _ref4.thisPaths;
    thisPaths.push(child);
  },
  JSXIdentifier: function JSXIdentifier(child, _ref5) {
    var thisPaths = _ref5.thisPaths;
    if (child.node.name !== "this") return;

    if (!child.parentPath.isJSXMemberExpression({
      object: child.node
    }) && !child.parentPath.isJSXOpeningElement({
      name: child.node
    })) {
      return;
    }

    thisPaths.push(child);
  },
  CallExpression: function CallExpression(child, _ref6) {
    var superCalls = _ref6.superCalls;
    if (child.get("callee").isSuper()) superCalls.push(child);
  },
  MemberExpression: function MemberExpression(child, _ref7) {
    var superProps = _ref7.superProps;
    if (child.get("object").isSuper()) superProps.push(child);
  },
  Identifier: function Identifier(child, _ref8) {
    var argumentsPaths = _ref8.argumentsPaths;
    if (!child.isReferencedIdentifier({
      name: "arguments"
    })) return;
    var curr = child.scope;

    do {
      if (curr.hasOwnBinding("arguments")) {
        curr.rename("arguments");
        return;
      }

      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
        break;
      }
    } while (curr = curr.parent);

    argumentsPaths.push(child);
  },
  MetaProperty: function MetaProperty(child, _ref9) {
    var newTargetPaths = _ref9.newTargetPaths;
    if (!child.get("meta").isIdentifier({
      name: "new"
    })) return;
    if (!child.get("property").isIdentifier({
      name: "target"
    })) return;
    newTargetPaths.push(child);
  }
}, _helperEnvironmentVisitor["default"]]);

function getScopeInformation(fnPath) {
  var thisPaths = [];
  var argumentsPaths = [];
  var newTargetPaths = [];
  var superProps = [];
  var superCalls = [];
  fnPath.traverse(getScopeInformationVisitor, {
    thisPaths: thisPaths,
    argumentsPaths: argumentsPaths,
    newTargetPaths: newTargetPaths,
    superProps: superProps,
    superCalls: superCalls
  });
  return {
    thisPaths: thisPaths,
    argumentsPaths: argumentsPaths,
    newTargetPaths: newTargetPaths,
    superProps: superProps,
    superCalls: superCalls
  };
}