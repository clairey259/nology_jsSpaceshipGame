"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._replaceWith = _replaceWith;
exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
exports.replaceInline = replaceInline;
exports.replaceWith = replaceWith;
exports.replaceWithMultiple = replaceWithMultiple;
exports.replaceWithSourceString = replaceWithSourceString;

var _codeFrame = require("@babel/code-frame");

var _index = require("../index");

var _index2 = require("./index");

var _cache = require("../cache");

var _parser = require("@babel/parser");

var _t = require("@babel/types");

var _helperHoistVariables = require("@babel/helper-hoist-variables");

var FUNCTION_TYPES = _t.FUNCTION_TYPES,
    arrowFunctionExpression = _t.arrowFunctionExpression,
    assignmentExpression = _t.assignmentExpression,
    awaitExpression = _t.awaitExpression,
    blockStatement = _t.blockStatement,
    callExpression = _t.callExpression,
    cloneNode = _t.cloneNode,
    expressionStatement = _t.expressionStatement,
    identifier = _t.identifier,
    inheritLeadingComments = _t.inheritLeadingComments,
    inheritTrailingComments = _t.inheritTrailingComments,
    inheritsComments = _t.inheritsComments,
    isExpression = _t.isExpression,
    isProgram = _t.isProgram,
    isStatement = _t.isStatement,
    removeComments = _t.removeComments,
    returnStatement = _t.returnStatement,
    toSequenceExpression = _t.toSequenceExpression,
    validate = _t.validate,
    yieldExpression = _t.yieldExpression;

function replaceWithMultiple(nodes) {
  var _pathCache$get;

  this.resync();
  nodes = this._verifyNodeList(nodes);
  inheritLeadingComments(nodes[0], this.node);
  inheritTrailingComments(nodes[nodes.length - 1], this.node);
  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get["delete"](this.node);
  this.node = this.container[this.key] = null;
  var paths = this.insertAfter(nodes);

  if (this.node) {
    this.requeue();
  } else {
    this.remove();
  }

  return paths;
}

function replaceWithSourceString(replacement) {
  this.resync();
  var ast;

  try {
    replacement = "(".concat(replacement, ")");
    ast = (0, _parser.parse)(replacement);
  } catch (err) {
    var loc = err.loc;

    if (loc) {
      err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
        start: {
          line: loc.line,
          column: loc.column + 1
        }
      });
      err.code = "BABEL_REPLACE_SOURCE_ERROR";
    }

    throw err;
  }

  var expressionAST = ast.program.body[0].expression;

  _index["default"].removeProperties(expressionAST);

  return this.replaceWith(expressionAST);
}

function replaceWith(replacementPath) {
  this.resync();

  if (this.removed) {
    throw new Error("You can't replace this node, we've already removed it");
  }

  var replacement = replacementPath instanceof _index2["default"] ? replacementPath.node : replacementPath;

  if (!replacement) {
    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
  }

  if (this.node === replacement) {
    return [this];
  }

  if (this.isProgram() && !isProgram(replacement)) {
    throw new Error("You can only replace a Program root node with another Program node");
  }

  if (Array.isArray(replacement)) {
    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
  }

  if (typeof replacement === "string") {
    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
  }

  var nodePath = "";

  if (this.isNodeType("Statement") && isExpression(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
      replacement = expressionStatement(replacement);
      nodePath = "expression";
    }
  }

  if (this.isNodeType("Expression") && isStatement(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
      return this.replaceExpressionWithStatements([replacement]);
    }
  }

  var oldNode = this.node;

  if (oldNode) {
    inheritsComments(replacement, oldNode);
    removeComments(oldNode);
  }

  this._replaceWith(replacement);

  this.type = replacement.type;
  this.setScope();
  this.requeue();
  return [nodePath ? this.get(nodePath) : this];
}

function _replaceWith(node) {
  var _pathCache$get2;

  if (!this.container) {
    throw new ReferenceError("Container is falsy");
  }

  if (this.inList) {
    validate(this.parent, this.key, [node]);
  } else {
    validate(this.parent, this.key, node);
  }

  this.debug("Replace with ".concat(node == null ? void 0 : node.type));
  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this)["delete"](this.node);
  this.node = this.container[this.key] = node;
}

function replaceExpressionWithStatements(nodes) {
  var _this = this;

  this.resync();
  var nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);

  if (nodesAsSequenceExpression) {
    return this.replaceWith(nodesAsSequenceExpression)[0].get("expressions");
  }

  var functionParent = this.getFunctionParent();
  var isParentAsync = functionParent == null ? void 0 : functionParent.is("async");
  var isParentGenerator = functionParent == null ? void 0 : functionParent.is("generator");
  var container = arrowFunctionExpression([], blockStatement(nodes));
  this.replaceWith(callExpression(container, []));
  var callee = this.get("callee");
  (0, _helperHoistVariables["default"])(callee.get("body"), function (id) {
    _this.scope.push({
      id: id
    });
  }, "var");
  var completionRecords = this.get("callee").getCompletionRecords();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = completionRecords[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var path = _step.value;
      if (!path.isExpressionStatement()) continue;
      var loop = path.findParent(function (path) {
        return path.isLoop();
      });

      if (loop) {
        var uid = loop.getData("expressionReplacementReturnUid");

        if (!uid) {
          uid = callee.scope.generateDeclaredUidIdentifier("ret");
          callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));
          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = identifier(uid.name);
        }

        path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
      } else {
        path.replaceWith(returnStatement(path.node.expression));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  callee.arrowFunctionToExpression();
  var newCallee = callee;

  var needToAwaitFunction = isParentAsync && _index["default"].hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);

  var needToYieldFunction = isParentGenerator && _index["default"].hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);

  if (needToAwaitFunction) {
    newCallee.set("async", true);

    if (!needToYieldFunction) {
      this.replaceWith(awaitExpression(this.node));
    }
  }

  if (needToYieldFunction) {
    newCallee.set("generator", true);
    this.replaceWith(yieldExpression(this.node, true));
  }

  return newCallee.get("body.body");
}

function replaceInline(nodes) {
  this.resync();

  if (Array.isArray(nodes)) {
    if (Array.isArray(this.container)) {
      nodes = this._verifyNodeList(nodes);

      var paths = this._containerInsertAfter(nodes);

      this.remove();
      return paths;
    } else {
      return this.replaceWithMultiple(nodes);
    }
  } else {
    return this.replaceWith(nodes);
  }
}