"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;

var virtualTypes = require("./lib/virtual-types");

var _debug = require("debug");

var _index = require("../index");

var _scope = require("../scope");

var _t = require("@babel/types");

var t = _t;

var _cache = require("../cache");

var _generator = require("@babel/generator");

var NodePath_ancestry = require("./ancestry");

var NodePath_inference = require("./inference");

var NodePath_replacement = require("./replacement");

var NodePath_evaluation = require("./evaluation");

var NodePath_conversion = require("./conversion");

var NodePath_introspection = require("./introspection");

var NodePath_context = require("./context");

var NodePath_removal = require("./removal");

var NodePath_modification = require("./modification");

var NodePath_family = require("./family");

var NodePath_comments = require("./comments");

var NodePath_virtual_types_validator = require("./lib/virtual-types-validator");

var validate = _t.validate;

var _debug2 = _debug("babel");

var REMOVED = 1 << 0;
exports.REMOVED = REMOVED;
var SHOULD_STOP = 1 << 1;
exports.SHOULD_STOP = SHOULD_STOP;
var SHOULD_SKIP = 1 << 2;
exports.SHOULD_SKIP = SHOULD_SKIP;

var NodePath =
/*#__PURE__*/
function () {
  function NodePath(hub, parent) {
    _classCallCheck(this, NodePath);

    this.contexts = [];
    this.state = null;
    this.opts = null;
    this._traverseFlags = 0;
    this.skipKeys = null;
    this.parentPath = null;
    this.container = null;
    this.listKey = null;
    this.key = null;
    this.node = null;
    this.type = null;
    this.parent = parent;
    this.hub = hub;
    this.data = null;
    this.context = null;
    this.scope = null;
  }

  _createClass(NodePath, [{
    key: "getScope",
    value: function getScope(scope) {
      return this.isScope() ? new _scope["default"](this) : scope;
    }
  }, {
    key: "setData",
    value: function setData(key, val) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      return this.data[key] = val;
    }
  }, {
    key: "getData",
    value: function getData(key, def) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      var val = this.data[key];
      if (val === undefined && def !== undefined) val = this.data[key] = def;
      return val;
    }
  }, {
    key: "hasNode",
    value: function hasNode() {
      return this.node != null;
    }
  }, {
    key: "buildCodeFrameError",
    value: function buildCodeFrameError(msg) {
      var Error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SyntaxError;
      return this.hub.buildError(this.node, msg, Error);
    }
  }, {
    key: "traverse",
    value: function traverse(visitor, state) {
      (0, _index["default"])(this.node, visitor, this.scope, state, this);
    }
  }, {
    key: "set",
    value: function set(key, node) {
      validate(this.node, key, node);
      this.node[key] = node;
    }
  }, {
    key: "getPathLocation",
    value: function getPathLocation() {
      var parts = [];
      var path = this;

      do {
        var key = path.key;
        if (path.inList) key = "".concat(path.listKey, "[").concat(key, "]");
        parts.unshift(key);
      } while (path = path.parentPath);

      return parts.join(".");
    }
  }, {
    key: "debug",
    value: function debug(message) {
      if (!_debug2.enabled) return;

      _debug2("".concat(this.getPathLocation(), " ").concat(this.type, ": ").concat(message));
    }
  }, {
    key: "toString",
    value: function toString() {
      return (0, _generator["default"])(this.node).code;
    }
  }, {
    key: "inList",
    get: function get() {
      return !!this.listKey;
    },
    set: function set(inList) {
      if (!inList) {
        this.listKey = null;
      }
    }
  }, {
    key: "parentKey",
    get: function get() {
      return this.listKey || this.key;
    }
  }, {
    key: "shouldSkip",
    get: function get() {
      return !!(this._traverseFlags & SHOULD_SKIP);
    },
    set: function set(v) {
      if (v) {
        this._traverseFlags |= SHOULD_SKIP;
      } else {
        this._traverseFlags &= ~SHOULD_SKIP;
      }
    }
  }, {
    key: "shouldStop",
    get: function get() {
      return !!(this._traverseFlags & SHOULD_STOP);
    },
    set: function set(v) {
      if (v) {
        this._traverseFlags |= SHOULD_STOP;
      } else {
        this._traverseFlags &= ~SHOULD_STOP;
      }
    }
  }, {
    key: "removed",
    get: function get() {
      return !!(this._traverseFlags & REMOVED);
    },
    set: function set(v) {
      if (v) {
        this._traverseFlags |= REMOVED;
      } else {
        this._traverseFlags &= ~REMOVED;
      }
    }
  }], [{
    key: "get",
    value: function get(_ref) {
      var hub = _ref.hub,
          parentPath = _ref.parentPath,
          parent = _ref.parent,
          container = _ref.container,
          listKey = _ref.listKey,
          key = _ref.key;

      if (!hub && parentPath) {
        hub = parentPath.hub;
      }

      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }

      var targetNode = container[key];

      var paths = _cache.path.get(parent);

      if (!paths) {
        paths = new Map();

        _cache.path.set(parent, paths);
      }

      var path = paths.get(targetNode);

      if (!path) {
        path = new NodePath(hub, parent);
        if (targetNode) paths.set(targetNode, path);
      }

      path.setup(parentPath, container, listKey, key);
      return path;
    }
  }]);

  return NodePath;
}();

Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
{
  NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
}
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  var _loop = function _loop() {
    var type = _step.value;
    var typeKey = "is".concat(type);
    var fn = t[typeKey];

    NodePath.prototype[typeKey] = function (opts) {
      return fn(this.node, opts);
    };

    NodePath.prototype["assert".concat(type)] = function (opts) {
      if (!fn(this.node, opts)) {
        throw new TypeError("Expected node path of type ".concat(type));
      }
    };
  };

  for (var _iterator = t.TYPES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    _loop();
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
      _iterator["return"]();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

Object.assign(NodePath.prototype, NodePath_virtual_types_validator);

for (var _i = 0, _Object$keys = Object.keys(virtualTypes); _i < _Object$keys.length; _i++) {
  var type = _Object$keys[_i];
  if (type[0] === "_") continue;
  if (!t.TYPES.includes(type)) t.TYPES.push(type);
}

var _default = NodePath;
exports["default"] = _default;