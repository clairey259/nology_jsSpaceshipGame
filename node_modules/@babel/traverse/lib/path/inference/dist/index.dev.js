"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._getTypeAnnotation = _getTypeAnnotation;
exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
exports.couldBeBaseType = couldBeBaseType;
exports.getTypeAnnotation = getTypeAnnotation;
exports.isBaseType = isBaseType;
exports.isGenericType = isGenericType;

var inferers = require("./inferers");

var _t = require("@babel/types");

var anyTypeAnnotation = _t.anyTypeAnnotation,
    isAnyTypeAnnotation = _t.isAnyTypeAnnotation,
    isArrayTypeAnnotation = _t.isArrayTypeAnnotation,
    isBooleanTypeAnnotation = _t.isBooleanTypeAnnotation,
    isEmptyTypeAnnotation = _t.isEmptyTypeAnnotation,
    isFlowBaseAnnotation = _t.isFlowBaseAnnotation,
    isGenericTypeAnnotation = _t.isGenericTypeAnnotation,
    isIdentifier = _t.isIdentifier,
    isMixedTypeAnnotation = _t.isMixedTypeAnnotation,
    isNumberTypeAnnotation = _t.isNumberTypeAnnotation,
    isStringTypeAnnotation = _t.isStringTypeAnnotation,
    isTSArrayType = _t.isTSArrayType,
    isTSTypeAnnotation = _t.isTSTypeAnnotation,
    isTSTypeReference = _t.isTSTypeReference,
    isTupleTypeAnnotation = _t.isTupleTypeAnnotation,
    isTypeAnnotation = _t.isTypeAnnotation,
    isUnionTypeAnnotation = _t.isUnionTypeAnnotation,
    isVoidTypeAnnotation = _t.isVoidTypeAnnotation,
    stringTypeAnnotation = _t.stringTypeAnnotation,
    voidTypeAnnotation = _t.voidTypeAnnotation;

function getTypeAnnotation() {
  var type = this.getData("typeAnnotation");

  if (type != null) {
    return type;
  }

  type = this._getTypeAnnotation() || anyTypeAnnotation();

  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
    type = type.typeAnnotation;
  }

  this.setData("typeAnnotation", type);
  return type;
}

var typeAnnotationInferringNodes = new WeakSet();

function _getTypeAnnotation() {
  var node = this.node;

  if (!node) {
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      var declar = this.parentPath.parentPath;
      var declarParent = declar.parentPath;

      if (declar.key === "left" && declarParent.isForInStatement()) {
        return stringTypeAnnotation();
      }

      if (declar.key === "left" && declarParent.isForOfStatement()) {
        return anyTypeAnnotation();
      }

      return voidTypeAnnotation();
    } else {
      return;
    }
  }

  if (node.typeAnnotation) {
    return node.typeAnnotation;
  }

  if (typeAnnotationInferringNodes.has(node)) {
    return;
  }

  typeAnnotationInferringNodes.add(node);

  try {
    var _inferer;

    var inferer = inferers[node.type];

    if (inferer) {
      return inferer.call(this, node);
    }

    inferer = inferers[this.parentPath.type];

    if ((_inferer = inferer) != null && _inferer.validParent) {
      return this.parentPath.getTypeAnnotation();
    }
  } finally {
    typeAnnotationInferringNodes["delete"](node);
  }
}

function isBaseType(baseName, soft) {
  return _isBaseType(baseName, this.getTypeAnnotation(), soft);
}

function _isBaseType(baseName, type, soft) {
  if (baseName === "string") {
    return isStringTypeAnnotation(type);
  } else if (baseName === "number") {
    return isNumberTypeAnnotation(type);
  } else if (baseName === "boolean") {
    return isBooleanTypeAnnotation(type);
  } else if (baseName === "any") {
    return isAnyTypeAnnotation(type);
  } else if (baseName === "mixed") {
    return isMixedTypeAnnotation(type);
  } else if (baseName === "empty") {
    return isEmptyTypeAnnotation(type);
  } else if (baseName === "void") {
    return isVoidTypeAnnotation(type);
  } else {
    if (soft) {
      return false;
    } else {
      throw new Error("Unknown base type ".concat(baseName));
    }
  }
}

function couldBeBaseType(name) {
  var type = this.getTypeAnnotation();
  if (isAnyTypeAnnotation(type)) return true;

  if (isUnionTypeAnnotation(type)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = type.types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var type2 = _step.value;

        if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return false;
  } else {
    return _isBaseType(name, type, true);
  }
}

function baseTypeStrictlyMatches(rightArg) {
  var left = this.getTypeAnnotation();
  var right = rightArg.getTypeAnnotation();

  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
    return right.type === left.type;
  }

  return false;
}

function isGenericType(genericName) {
  var type = this.getTypeAnnotation();

  if (genericName === "Array") {
    if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
      return true;
    }
  }

  return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
    name: genericName
  }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
    name: genericName
  });
}