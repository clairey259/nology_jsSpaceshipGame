"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBindingIdentifier = isBindingIdentifier;
exports.isBlockScoped = isBlockScoped;
exports.isExistentialTypeParam = isExistentialTypeParam;
exports.isExpression = isExpression;
exports.isFlow = isFlow;
exports.isForAwaitStatement = isForAwaitStatement;
exports.isGenerated = isGenerated;
exports.isNumericLiteralTypeAnnotation = isNumericLiteralTypeAnnotation;
exports.isPure = isPure;
exports.isReferenced = isReferenced;
exports.isReferencedIdentifier = isReferencedIdentifier;
exports.isReferencedMemberExpression = isReferencedMemberExpression;
exports.isRestProperty = isRestProperty;
exports.isScope = isScope;
exports.isSpreadProperty = isSpreadProperty;
exports.isStatement = isStatement;
exports.isUser = isUser;
exports.isVar = isVar;

var _t = require("@babel/types");

var isBinding = _t.isBinding,
    nodeIsBlockScoped = _t.isBlockScoped,
    isExportDeclaration = _t.isExportDeclaration,
    nodeIsExpression = _t.isExpression,
    nodeIsFlow = _t.isFlow,
    isForStatement = _t.isForStatement,
    isForXStatement = _t.isForXStatement,
    isIdentifier = _t.isIdentifier,
    isImportDeclaration = _t.isImportDeclaration,
    isImportSpecifier = _t.isImportSpecifier,
    isJSXIdentifier = _t.isJSXIdentifier,
    isJSXMemberExpression = _t.isJSXMemberExpression,
    isMemberExpression = _t.isMemberExpression,
    nodeIsRestElement = _t.isRestElement,
    nodeIsReferenced = _t.isReferenced,
    nodeIsScope = _t.isScope,
    nodeIsStatement = _t.isStatement,
    nodeIsVar = _t.isVar,
    isVariableDeclaration = _t.isVariableDeclaration,
    react = _t.react,
    isForOfStatement = _t.isForOfStatement;
var isCompatTag = react.isCompatTag;

function isReferencedIdentifier(opts) {
  var node = this.node,
      parent = this.parent;

  if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
    if (isJSXIdentifier(node, opts)) {
      if (isCompatTag(node.name)) return false;
    } else {
      return false;
    }
  }

  return nodeIsReferenced(node, parent, this.parentPath.parent);
}

function isReferencedMemberExpression() {
  var node = this.node,
      parent = this.parent;
  return isMemberExpression(node) && nodeIsReferenced(node, parent);
}

function isBindingIdentifier() {
  var node = this.node,
      parent = this.parent;
  var grandparent = this.parentPath.parent;
  return isIdentifier(node) && isBinding(node, parent, grandparent);
}

function isStatement() {
  var node = this.node,
      parent = this.parent;

  if (nodeIsStatement(node)) {
    if (isVariableDeclaration(node)) {
      if (isForXStatement(parent, {
        left: node
      })) return false;
      if (isForStatement(parent, {
        init: node
      })) return false;
    }

    return true;
  } else {
    return false;
  }
}

function isExpression() {
  if (this.isIdentifier()) {
    return this.isReferencedIdentifier();
  } else {
    return nodeIsExpression(this.node);
  }
}

function isScope() {
  return nodeIsScope(this.node, this.parent);
}

function isReferenced() {
  return nodeIsReferenced(this.node, this.parent);
}

function isBlockScoped() {
  return nodeIsBlockScoped(this.node);
}

function isVar() {
  return nodeIsVar(this.node);
}

function isUser() {
  return this.node && !!this.node.loc;
}

function isGenerated() {
  return !this.isUser();
}

function isPure(constantsOnly) {
  return this.scope.isPure(this.node, constantsOnly);
}

function isFlow() {
  var node = this.node;

  if (nodeIsFlow(node)) {
    return true;
  } else if (isImportDeclaration(node)) {
    return node.importKind === "type" || node.importKind === "typeof";
  } else if (isExportDeclaration(node)) {
    return node.exportKind === "type";
  } else if (isImportSpecifier(node)) {
    return node.importKind === "type" || node.importKind === "typeof";
  } else {
    return false;
  }
}

function isRestProperty() {
  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();
}

function isSpreadProperty() {
  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();
}

function isForAwaitStatement() {
  return isForOfStatement(this.node, {
    "await": true
  });
}

function isExistentialTypeParam() {
  throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
}

function isNumericLiteralTypeAnnotation() {
  throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
}