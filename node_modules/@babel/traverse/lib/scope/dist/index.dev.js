"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _renamer = require("./lib/renamer");

var _index = require("../index");

var _binding = require("./binding");

var _globals = require("globals");

var _t = require("@babel/types");

var _cache = require("../cache");

var NOT_LOCAL_BINDING = _t.NOT_LOCAL_BINDING,
    callExpression = _t.callExpression,
    cloneNode = _t.cloneNode,
    getBindingIdentifiers = _t.getBindingIdentifiers,
    identifier = _t.identifier,
    isArrayExpression = _t.isArrayExpression,
    isBinary = _t.isBinary,
    isClass = _t.isClass,
    isClassBody = _t.isClassBody,
    isClassDeclaration = _t.isClassDeclaration,
    isExportAllDeclaration = _t.isExportAllDeclaration,
    isExportDefaultDeclaration = _t.isExportDefaultDeclaration,
    isExportNamedDeclaration = _t.isExportNamedDeclaration,
    isFunctionDeclaration = _t.isFunctionDeclaration,
    isIdentifier = _t.isIdentifier,
    isImportDeclaration = _t.isImportDeclaration,
    isLiteral = _t.isLiteral,
    isMethod = _t.isMethod,
    isModuleDeclaration = _t.isModuleDeclaration,
    isModuleSpecifier = _t.isModuleSpecifier,
    isNullLiteral = _t.isNullLiteral,
    isObjectExpression = _t.isObjectExpression,
    isProperty = _t.isProperty,
    isPureish = _t.isPureish,
    isRegExpLiteral = _t.isRegExpLiteral,
    isSuper = _t.isSuper,
    isTaggedTemplateExpression = _t.isTaggedTemplateExpression,
    isTemplateLiteral = _t.isTemplateLiteral,
    isThisExpression = _t.isThisExpression,
    isUnaryExpression = _t.isUnaryExpression,
    isVariableDeclaration = _t.isVariableDeclaration,
    matchesPattern = _t.matchesPattern,
    memberExpression = _t.memberExpression,
    numericLiteral = _t.numericLiteral,
    toIdentifier = _t.toIdentifier,
    unaryExpression = _t.unaryExpression,
    variableDeclaration = _t.variableDeclaration,
    variableDeclarator = _t.variableDeclarator,
    isRecordExpression = _t.isRecordExpression,
    isTupleExpression = _t.isTupleExpression,
    isObjectProperty = _t.isObjectProperty,
    isTopicReference = _t.isTopicReference,
    isMetaProperty = _t.isMetaProperty,
    isPrivateName = _t.isPrivateName;

function gatherNodeParts(node, parts) {
  switch (node == null ? void 0 : node.type) {
    default:
      if (isModuleDeclaration(node)) {
        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
          gatherNodeParts(node.source, parts);
        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = node.specifiers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var e = _step.value;
              gatherNodeParts(e, parts);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
          gatherNodeParts(node.declaration, parts);
        }
      } else if (isModuleSpecifier(node)) {
        gatherNodeParts(node.local, parts);
      } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
        parts.push(node.value);
      }

      break;

    case "MemberExpression":
    case "OptionalMemberExpression":
    case "JSXMemberExpression":
      gatherNodeParts(node.object, parts);
      gatherNodeParts(node.property, parts);
      break;

    case "Identifier":
    case "JSXIdentifier":
      parts.push(node.name);
      break;

    case "CallExpression":
    case "OptionalCallExpression":
    case "NewExpression":
      gatherNodeParts(node.callee, parts);
      break;

    case "ObjectExpression":
    case "ObjectPattern":
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = node.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _e = _step2.value;
          gatherNodeParts(_e, parts);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      break;

    case "SpreadElement":
    case "RestElement":
      gatherNodeParts(node.argument, parts);
      break;

    case "ObjectProperty":
    case "ObjectMethod":
    case "ClassProperty":
    case "ClassMethod":
    case "ClassPrivateProperty":
    case "ClassPrivateMethod":
      gatherNodeParts(node.key, parts);
      break;

    case "ThisExpression":
      parts.push("this");
      break;

    case "Super":
      parts.push("super");
      break;

    case "Import":
      parts.push("import");
      break;

    case "DoExpression":
      parts.push("do");
      break;

    case "YieldExpression":
      parts.push("yield");
      gatherNodeParts(node.argument, parts);
      break;

    case "AwaitExpression":
      parts.push("await");
      gatherNodeParts(node.argument, parts);
      break;

    case "AssignmentExpression":
      gatherNodeParts(node.left, parts);
      break;

    case "VariableDeclarator":
      gatherNodeParts(node.id, parts);
      break;

    case "FunctionExpression":
    case "FunctionDeclaration":
    case "ClassExpression":
    case "ClassDeclaration":
      gatherNodeParts(node.id, parts);
      break;

    case "PrivateName":
      gatherNodeParts(node.id, parts);
      break;

    case "ParenthesizedExpression":
      gatherNodeParts(node.expression, parts);
      break;

    case "UnaryExpression":
    case "UpdateExpression":
      gatherNodeParts(node.argument, parts);
      break;

    case "MetaProperty":
      gatherNodeParts(node.meta, parts);
      gatherNodeParts(node.property, parts);
      break;

    case "JSXElement":
      gatherNodeParts(node.openingElement, parts);
      break;

    case "JSXOpeningElement":
      gatherNodeParts(node.name, parts);
      break;

    case "JSXFragment":
      gatherNodeParts(node.openingFragment, parts);
      break;

    case "JSXOpeningFragment":
      parts.push("Fragment");
      break;

    case "JSXNamespacedName":
      gatherNodeParts(node.namespace, parts);
      gatherNodeParts(node.name, parts);
      break;
  }
}

var collectorVisitor = {
  ForStatement: function ForStatement(path) {
    var declar = path.get("init");

    if (declar.isVar()) {
      var scope = path.scope;
      var parentScope = scope.getFunctionParent() || scope.getProgramParent();
      parentScope.registerBinding("var", declar);
    }
  },
  Declaration: function Declaration(path) {
    if (path.isBlockScoped()) return;
    if (path.isImportDeclaration()) return;
    if (path.isExportDeclaration()) return;
    var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
    parent.registerDeclaration(path);
  },
  ImportDeclaration: function ImportDeclaration(path) {
    var parent = path.scope.getBlockParent();
    parent.registerDeclaration(path);
  },
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    state.references.push(path);
  },
  ForXStatement: function ForXStatement(path, state) {
    var left = path.get("left");

    if (left.isPattern() || left.isIdentifier()) {
      state.constantViolations.push(path);
    } else if (left.isVar()) {
      var scope = path.scope;
      var parentScope = scope.getFunctionParent() || scope.getProgramParent();
      parentScope.registerBinding("var", left);
    }
  },
  ExportDeclaration: {
    exit: function exit(path) {
      var node = path.node,
          scope = path.scope;
      if (isExportAllDeclaration(node)) return;
      var declar = node.declaration;

      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
        var id = declar.id;
        if (!id) return;
        var binding = scope.getBinding(id.name);
        binding == null ? void 0 : binding.reference(path);
      } else if (isVariableDeclaration(declar)) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = declar.declarations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var decl = _step3.value;

            for (var _i = 0, _Object$keys = Object.keys(getBindingIdentifiers(decl)); _i < _Object$keys.length; _i++) {
              var name = _Object$keys[_i];

              var _binding2 = scope.getBinding(name);

              _binding2 == null ? void 0 : _binding2.reference(path);
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    }
  },
  LabeledStatement: function LabeledStatement(path) {
    path.scope.getBlockParent().registerDeclaration(path);
  },
  AssignmentExpression: function AssignmentExpression(path, state) {
    state.assignments.push(path);
  },
  UpdateExpression: function UpdateExpression(path, state) {
    state.constantViolations.push(path);
  },
  UnaryExpression: function UnaryExpression(path, state) {
    if (path.node.operator === "delete") {
      state.constantViolations.push(path);
    }
  },
  BlockScoped: function BlockScoped(path) {
    var scope = path.scope;
    if (scope.path === path) scope = scope.parent;
    var parent = scope.getBlockParent();
    parent.registerDeclaration(path);

    if (path.isClassDeclaration() && path.node.id) {
      var id = path.node.id;
      var name = id.name;
      path.scope.bindings[name] = path.scope.parent.getBinding(name);
    }
  },
  CatchClause: function CatchClause(path) {
    path.scope.registerBinding("let", path);
  },
  Function: function Function(path) {
    var params = path.get("params");
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = params[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var param = _step4.value;
        path.scope.registerBinding("param", param);
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
          _iterator4["return"]();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
      path.scope.registerBinding("local", path.get("id"), path);
    }
  },
  ClassExpression: function ClassExpression(path) {
    if (path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
      path.scope.registerBinding("local", path);
    }
  }
};
var uid = 0;

var Scope =
/*#__PURE__*/
function () {
  function Scope(path) {
    _classCallCheck(this, Scope);

    this.uid = void 0;
    this.path = void 0;
    this.block = void 0;
    this.labels = void 0;
    this.inited = void 0;
    this.bindings = void 0;
    this.references = void 0;
    this.globals = void 0;
    this.uids = void 0;
    this.data = void 0;
    this.crawling = void 0;
    var node = path.node;

    var cached = _cache.scope.get(node);

    if ((cached == null ? void 0 : cached.path) === path) {
      return cached;
    }

    _cache.scope.set(node, this);

    this.uid = uid++;
    this.block = node;
    this.path = path;
    this.labels = new Map();
    this.inited = false;
  }

  _createClass(Scope, [{
    key: "traverse",
    value: function traverse(node, opts, state) {
      (0, _index["default"])(node, opts, this, state, this.path);
    }
  }, {
    key: "generateDeclaredUidIdentifier",
    value: function generateDeclaredUidIdentifier(name) {
      var id = this.generateUidIdentifier(name);
      this.push({
        id: id
      });
      return cloneNode(id);
    }
  }, {
    key: "generateUidIdentifier",
    value: function generateUidIdentifier(name) {
      return identifier(this.generateUid(name));
    }
  }, {
    key: "generateUid",
    value: function generateUid() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";
      name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      var uid;
      var i = 1;

      do {
        uid = this._generateUid(name, i);
        i++;
      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

      var program = this.getProgramParent();
      program.references[uid] = true;
      program.uids[uid] = true;
      return uid;
    }
  }, {
    key: "_generateUid",
    value: function _generateUid(name, i) {
      var id = name;
      if (i > 1) id += i;
      return "_".concat(id);
    }
  }, {
    key: "generateUidBasedOnNode",
    value: function generateUidBasedOnNode(node, defaultName) {
      var parts = [];
      gatherNodeParts(node, parts);
      var id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    }
  }, {
    key: "generateUidIdentifierBasedOnNode",
    value: function generateUidIdentifierBasedOnNode(node, defaultName) {
      return identifier(this.generateUidBasedOnNode(node, defaultName));
    }
  }, {
    key: "isStatic",
    value: function isStatic(node) {
      if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {
        return true;
      }

      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);

        if (binding) {
          return binding.constant;
        } else {
          return this.hasBinding(node.name);
        }
      }

      return false;
    }
  }, {
    key: "maybeGenerateMemoised",
    value: function maybeGenerateMemoised(node, dontPush) {
      if (this.isStatic(node)) {
        return null;
      } else {
        var id = this.generateUidIdentifierBasedOnNode(node);

        if (!dontPush) {
          this.push({
            id: id
          });
          return cloneNode(id);
        }

        return id;
      }
    }
  }, {
    key: "checkBlockScopedCollisions",
    value: function checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param") return;
      if (local.kind === "local") return;
      var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";

      if (duplicate) {
        throw this.hub.buildError(id, "Duplicate declaration \"".concat(name, "\""), TypeError);
      }
    }
  }, {
    key: "rename",
    value: function rename(oldName, newName, block) {
      var binding = this.getBinding(oldName);

      if (binding) {
        newName = newName || this.generateUidIdentifier(oldName).name;
        return new _renamer["default"](binding, oldName, newName).rename(block);
      }
    }
  }, {
    key: "_renameFromMap",
    value: function _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    }
  }, {
    key: "dump",
    value: function dump() {
      var sep = "-".repeat(60);
      console.log(sep);
      var scope = this;

      do {
        console.log("#", scope.block.type);

        for (var _i2 = 0, _Object$keys2 = Object.keys(scope.bindings); _i2 < _Object$keys2.length; _i2++) {
          var name = _Object$keys2[_i2];
          var binding = scope.bindings[name];
          console.log(" -", name, {
            constant: binding.constant,
            references: binding.references,
            violations: binding.constantViolations.length,
            kind: binding.kind
          });
        }
      } while (scope = scope.parent);

      console.log(sep);
    }
  }, {
    key: "toArray",
    value: function toArray(node, i, arrayLikeIsIterable) {
      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);

        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
          return node;
        }
      }

      if (isArrayExpression(node)) {
        return node;
      }

      if (isIdentifier(node, {
        name: "arguments"
      })) {
        return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
      }

      var helperName;
      var args = [node];

      if (i === true) {
        helperName = "toConsumableArray";
      } else if (i) {
        args.push(numericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }

      if (arrayLikeIsIterable) {
        args.unshift(this.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }

      return callExpression(this.hub.addHelper(helperName), args);
    }
  }, {
    key: "hasLabel",
    value: function hasLabel(name) {
      return !!this.getLabel(name);
    }
  }, {
    key: "getLabel",
    value: function getLabel(name) {
      return this.labels.get(name);
    }
  }, {
    key: "registerLabel",
    value: function registerLabel(path) {
      this.labels.set(path.node.label.name, path);
    }
  }, {
    key: "registerDeclaration",
    value: function registerDeclaration(path) {
      if (path.isLabeledStatement()) {
        this.registerLabel(path);
      } else if (path.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path.get("id"), path);
      } else if (path.isVariableDeclaration()) {
        var declarations = path.get("declarations");
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = declarations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var declar = _step5.value;
            this.registerBinding(path.node.kind, declar);
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      } else if (path.isClassDeclaration()) {
        if (path.node.declare) return;
        this.registerBinding("let", path);
      } else if (path.isImportDeclaration()) {
        var specifiers = path.get("specifiers");
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = specifiers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var specifier = _step6.value;
            this.registerBinding("module", specifier);
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      } else if (path.isExportDeclaration()) {
        var _declar = path.get("declaration");

        if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
          this.registerDeclaration(_declar);
        }
      } else {
        this.registerBinding("unknown", path);
      }
    }
  }, {
    key: "buildUndefinedNode",
    value: function buildUndefinedNode() {
      return unaryExpression("void", numericLiteral(0), true);
    }
  }, {
    key: "registerConstantViolation",
    value: function registerConstantViolation(path) {
      var ids = path.getBindingIdentifiers();

      for (var _i3 = 0, _Object$keys3 = Object.keys(ids); _i3 < _Object$keys3.length; _i3++) {
        var name = _Object$keys3[_i3];
        var binding = this.getBinding(name);
        if (binding) binding.reassign(path);
      }
    }
  }, {
    key: "registerBinding",
    value: function registerBinding(kind, path) {
      var bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;
      if (!kind) throw new ReferenceError("no `kind`");

      if (path.isVariableDeclaration()) {
        var declarators = path.get("declarations");
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = declarators[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var declar = _step7.value;
            this.registerBinding(kind, declar);
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
              _iterator7["return"]();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }

        return;
      }

      var parent = this.getProgramParent();
      var ids = path.getOuterBindingIdentifiers(true);

      for (var _i4 = 0, _Object$keys4 = Object.keys(ids); _i4 < _Object$keys4.length; _i4++) {
        var name = _Object$keys4[_i4];
        parent.references[name] = true;
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = ids[name][Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var id = _step8.value;
            var local = this.getOwnBinding(name);

            if (local) {
              if (local.identifier === id) continue;
              this.checkBlockScopedCollisions(local, kind, name, id);
            }

            if (local) {
              this.registerConstantViolation(bindingPath);
            } else {
              this.bindings[name] = new _binding["default"]({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind: kind
              });
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
              _iterator8["return"]();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
    }
  }, {
    key: "addGlobal",
    value: function addGlobal(node) {
      this.globals[node.name] = node;
    }
  }, {
    key: "hasUid",
    value: function hasUid(name) {
      var scope = this;

      do {
        if (scope.uids[name]) return true;
      } while (scope = scope.parent);

      return false;
    }
  }, {
    key: "hasGlobal",
    value: function hasGlobal(name) {
      var scope = this;

      do {
        if (scope.globals[name]) return true;
      } while (scope = scope.parent);

      return false;
    }
  }, {
    key: "hasReference",
    value: function hasReference(name) {
      return !!this.getProgramParent().references[name];
    }
  }, {
    key: "isPure",
    value: function isPure(node, constantsOnly) {
      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);
        if (!binding) return false;
        if (constantsOnly) return binding.constant;
        return true;
      } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {
        return true;
      } else if (isClass(node)) {
        var _node$decorators;

        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
          return false;
        }

        if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {
          return false;
        }

        return this.isPure(node.body, constantsOnly);
      } else if (isClassBody(node)) {
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = node.body[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var method = _step9.value;
            if (!this.isPure(method, constantsOnly)) return false;
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
              _iterator9["return"]();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }

        return true;
      } else if (isBinary(node)) {
        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
      } else if (isArrayExpression(node) || isTupleExpression(node)) {
        var _iteratorNormalCompletion10 = true;
        var _didIteratorError10 = false;
        var _iteratorError10 = undefined;

        try {
          for (var _iterator10 = node.elements[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
            var elem = _step10.value;
            if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
          }
        } catch (err) {
          _didIteratorError10 = true;
          _iteratorError10 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
              _iterator10["return"]();
            }
          } finally {
            if (_didIteratorError10) {
              throw _iteratorError10;
            }
          }
        }

        return true;
      } else if (isObjectExpression(node) || isRecordExpression(node)) {
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = node.properties[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var prop = _step11.value;
            if (!this.isPure(prop, constantsOnly)) return false;
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
              _iterator11["return"]();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }

        return true;
      } else if (isMethod(node)) {
        var _node$decorators2;

        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;

        if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
          return false;
        }

        return true;
      } else if (isProperty(node)) {
        var _node$decorators3;

        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;

        if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
          return false;
        }

        if (isObjectProperty(node) || node["static"]) {
          if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
            return false;
          }
        }

        return true;
      } else if (isUnaryExpression(node)) {
        return this.isPure(node.argument, constantsOnly);
      } else if (isTaggedTemplateExpression(node)) {
        return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
      } else if (isTemplateLiteral(node)) {
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = node.expressions[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var expression = _step12.value;
            if (!this.isPure(expression, constantsOnly)) return false;
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
              _iterator12["return"]();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }

        return true;
      } else {
        return isPureish(node);
      }
    }
  }, {
    key: "setData",
    value: function setData(key, val) {
      return this.data[key] = val;
    }
  }, {
    key: "getData",
    value: function getData(key) {
      var scope = this;

      do {
        var data = scope.data[key];
        if (data != null) return data;
      } while (scope = scope.parent);
    }
  }, {
    key: "removeData",
    value: function removeData(key) {
      var scope = this;

      do {
        var data = scope.data[key];
        if (data != null) scope.data[key] = null;
      } while (scope = scope.parent);
    }
  }, {
    key: "init",
    value: function init() {
      if (!this.inited) {
        this.inited = true;
        this.crawl();
      }
    }
  }, {
    key: "crawl",
    value: function crawl() {
      var path = this.path;
      this.references = Object.create(null);
      this.bindings = Object.create(null);
      this.globals = Object.create(null);
      this.uids = Object.create(null);
      this.data = Object.create(null);
      var programParent = this.getProgramParent();
      if (programParent.crawling) return;
      var state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;

      if (path.type !== "Program" && collectorVisitor._exploded) {
        var _iteratorNormalCompletion13 = true;
        var _didIteratorError13 = false;
        var _iteratorError13 = undefined;

        try {
          for (var _iterator13 = collectorVisitor.enter[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
            var _visit = _step13.value;

            _visit(path, state);
          }
        } catch (err) {
          _didIteratorError13 = true;
          _iteratorError13 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
              _iterator13["return"]();
            }
          } finally {
            if (_didIteratorError13) {
              throw _iteratorError13;
            }
          }
        }

        var typeVisitors = collectorVisitor[path.type];

        if (typeVisitors) {
          var _iteratorNormalCompletion14 = true;
          var _didIteratorError14 = false;
          var _iteratorError14 = undefined;

          try {
            for (var _iterator14 = typeVisitors.enter[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
              var visit = _step14.value;
              visit(path, state);
            }
          } catch (err) {
            _didIteratorError14 = true;
            _iteratorError14 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
                _iterator14["return"]();
              }
            } finally {
              if (_didIteratorError14) {
                throw _iteratorError14;
              }
            }
          }
        }
      }

      path.traverse(collectorVisitor, state);
      this.crawling = false;
      var _iteratorNormalCompletion15 = true;
      var _didIteratorError15 = false;
      var _iteratorError15 = undefined;

      try {
        for (var _iterator15 = state.assignments[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
          var _path = _step15.value;

          var ids = _path.getBindingIdentifiers();

          for (var _i5 = 0, _Object$keys5 = Object.keys(ids); _i5 < _Object$keys5.length; _i5++) {
            var name = _Object$keys5[_i5];
            if (_path.scope.getBinding(name)) continue;
            programParent.addGlobal(ids[name]);
          }

          _path.scope.registerConstantViolation(_path);
        }
      } catch (err) {
        _didIteratorError15 = true;
        _iteratorError15 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
            _iterator15["return"]();
          }
        } finally {
          if (_didIteratorError15) {
            throw _iteratorError15;
          }
        }
      }

      var _iteratorNormalCompletion16 = true;
      var _didIteratorError16 = false;
      var _iteratorError16 = undefined;

      try {
        for (var _iterator16 = state.references[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
          var ref = _step16.value;
          var binding = ref.scope.getBinding(ref.node.name);

          if (binding) {
            binding.reference(ref);
          } else {
            programParent.addGlobal(ref.node);
          }
        }
      } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
            _iterator16["return"]();
          }
        } finally {
          if (_didIteratorError16) {
            throw _iteratorError16;
          }
        }
      }

      var _iteratorNormalCompletion17 = true;
      var _didIteratorError17 = false;
      var _iteratorError17 = undefined;

      try {
        for (var _iterator17 = state.constantViolations[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
          var _path2 = _step17.value;

          _path2.scope.registerConstantViolation(_path2);
        }
      } catch (err) {
        _didIteratorError17 = true;
        _iteratorError17 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
            _iterator17["return"]();
          }
        } finally {
          if (_didIteratorError17) {
            throw _iteratorError17;
          }
        }
      }
    }
  }, {
    key: "push",
    value: function push(opts) {
      var path = this.path;

      if (path.isPattern()) {
        path = this.getPatternParent().path;
      } else if (!path.isBlockStatement() && !path.isProgram()) {
        path = this.getBlockParent().path;
      }

      if (path.isSwitchStatement()) {
        path = (this.getFunctionParent() || this.getProgramParent()).path;
      }

      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
        path.ensureBlock();
        path = path.get("body");
      }

      var unique = opts.unique;
      var kind = opts.kind || "var";
      var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      var dataKey = "declaration:".concat(kind, ":").concat(blockHoist);
      var declarPath = !unique && path.getData(dataKey);

      if (!declarPath) {
        var declar = variableDeclaration(kind, []);
        declar._blockHoist = blockHoist;

        var _path$unshiftContaine = path.unshiftContainer("body", [declar]);

        var _path$unshiftContaine2 = _slicedToArray(_path$unshiftContaine, 1);

        declarPath = _path$unshiftContaine2[0];
        if (!unique) path.setData(dataKey, declarPath);
      }

      var declarator = variableDeclarator(opts.id, opts.init);
      var len = declarPath.node.declarations.push(declarator);
      path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
    }
  }, {
    key: "getProgramParent",
    value: function getProgramParent() {
      var scope = this;

      do {
        if (scope.path.isProgram()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("Couldn't find a Program");
    }
  }, {
    key: "getFunctionParent",
    value: function getFunctionParent() {
      var scope = this;

      do {
        if (scope.path.isFunctionParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      return null;
    }
  }, {
    key: "getBlockParent",
    value: function getBlockParent() {
      var scope = this;

      do {
        if (scope.path.isBlockParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
  }, {
    key: "getPatternParent",
    value: function getPatternParent() {
      var scope = this;

      do {
        if (!scope.path.isPattern()) {
          return scope.getBlockParent();
        }
      } while (scope = scope.parent.parent);

      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
  }, {
    key: "getAllBindings",
    value: function getAllBindings() {
      var ids = Object.create(null);
      var scope = this;

      do {
        for (var _i6 = 0, _Object$keys6 = Object.keys(scope.bindings); _i6 < _Object$keys6.length; _i6++) {
          var key = _Object$keys6[_i6];

          if (key in ids === false) {
            ids[key] = scope.bindings[key];
          }
        }

        scope = scope.parent;
      } while (scope);

      return ids;
    }
  }, {
    key: "getAllBindingsOfKind",
    value: function getAllBindingsOfKind() {
      var ids = Object.create(null);

      for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {
        kinds[_key] = arguments[_key];
      }

      for (var _i7 = 0, _kinds = kinds; _i7 < _kinds.length; _i7++) {
        var kind = _kinds[_i7];
        var scope = this;

        do {
          for (var _i8 = 0, _Object$keys7 = Object.keys(scope.bindings); _i8 < _Object$keys7.length; _i8++) {
            var name = _Object$keys7[_i8];
            var binding = scope.bindings[name];
            if (binding.kind === kind) ids[name] = binding;
          }

          scope = scope.parent;
        } while (scope);
      }

      return ids;
    }
  }, {
    key: "bindingIdentifierEquals",
    value: function bindingIdentifierEquals(name, node) {
      return this.getBindingIdentifier(name) === node;
    }
  }, {
    key: "getBinding",
    value: function getBinding(name) {
      var scope = this;
      var previousPath;

      do {
        var binding = scope.getOwnBinding(name);

        if (binding) {
          var _previousPath;

          if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {} else {
            return binding;
          }
        } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
          break;
        }

        previousPath = scope.path;
      } while (scope = scope.parent);
    }
  }, {
    key: "getOwnBinding",
    value: function getOwnBinding(name) {
      return this.bindings[name];
    }
  }, {
    key: "getBindingIdentifier",
    value: function getBindingIdentifier(name) {
      var _this$getBinding;

      return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;
    }
  }, {
    key: "getOwnBindingIdentifier",
    value: function getOwnBindingIdentifier(name) {
      var binding = this.bindings[name];
      return binding == null ? void 0 : binding.identifier;
    }
  }, {
    key: "hasOwnBinding",
    value: function hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    }
  }, {
    key: "hasBinding",
    value: function hasBinding(name, noGlobals) {
      if (!name) return false;
      if (this.hasOwnBinding(name)) return true;
      if (this.parentHasBinding(name, noGlobals)) return true;
      if (this.hasUid(name)) return true;
      if (!noGlobals && Scope.globals.includes(name)) return true;
      if (!noGlobals && Scope.contextVariables.includes(name)) return true;
      return false;
    }
  }, {
    key: "parentHasBinding",
    value: function parentHasBinding(name, noGlobals) {
      var _this$parent;

      return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);
    }
  }, {
    key: "moveBindingTo",
    value: function moveBindingTo(name, scope) {
      var info = this.getBinding(name);

      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope;
        scope.bindings[name] = info;
      }
    }
  }, {
    key: "removeOwnBinding",
    value: function removeOwnBinding(name) {
      delete this.bindings[name];
    }
  }, {
    key: "removeBinding",
    value: function removeBinding(name) {
      var _this$getBinding2;

      (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);
      var scope = this;

      do {
        if (scope.uids[name]) {
          scope.uids[name] = false;
        }
      } while (scope = scope.parent);
    }
  }, {
    key: "parent",
    get: function get() {
      var _parent;

      var parent,
          path = this.path;

      do {
        var shouldSkip = path.key === "key" || path.listKey === "decorators";
        path = path.parentPath;
        if (shouldSkip && path.isMethod()) path = path.parentPath;
        if (path && path.isScope()) parent = path;
      } while (path && !parent);

      return (_parent = parent) == null ? void 0 : _parent.scope;
    }
  }, {
    key: "parentBlock",
    get: function get() {
      return this.path.parent;
    }
  }, {
    key: "hub",
    get: function get() {
      return this.path.hub;
    }
  }]);

  return Scope;
}();

exports["default"] = Scope;
Scope.globals = Object.keys(_globals.builtin);
Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];