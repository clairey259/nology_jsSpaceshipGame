"use strict";

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n    (function() {\n      throw new Error('\"' + '", "' + '\" is read-only.');\n    })()\n  "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = rewriteLiveReferences;

var _assert = require("assert");

var _t = require("@babel/types");

var _template = require("@babel/template");

var _helperSimpleAccess = require("@babel/helper-simple-access");

var assignmentExpression = _t.assignmentExpression,
    callExpression = _t.callExpression,
    cloneNode = _t.cloneNode,
    expressionStatement = _t.expressionStatement,
    getOuterBindingIdentifiers = _t.getOuterBindingIdentifiers,
    identifier = _t.identifier,
    isMemberExpression = _t.isMemberExpression,
    isVariableDeclaration = _t.isVariableDeclaration,
    jsxIdentifier = _t.jsxIdentifier,
    jsxMemberExpression = _t.jsxMemberExpression,
    memberExpression = _t.memberExpression,
    numericLiteral = _t.numericLiteral,
    sequenceExpression = _t.sequenceExpression,
    stringLiteral = _t.stringLiteral,
    variableDeclaration = _t.variableDeclaration,
    variableDeclarator = _t.variableDeclarator;

function isInType(path) {
  do {
    switch (path.parent.type) {
      case "TSTypeAnnotation":
      case "TSTypeAliasDeclaration":
      case "TSTypeReference":
      case "TypeAnnotation":
      case "TypeAlias":
        return true;

      case "ExportSpecifier":
        return path.parentPath.parent.exportKind === "type";

      default:
        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {
          return false;
        }

    }
  } while (path = path.parentPath);
}

function rewriteLiveReferences(programPath, metadata) {
  var imported = new Map();
  var exported = new Map();

  var requeueInParent = function requeueInParent(path) {
    programPath.requeue(path);
  };

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = metadata.source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2),
          source = _step$value[0],
          data = _step$value[1];

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data.imports[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              localName = _step3$value[0],
              importName = _step3$value[1];

          imported.set(localName, [source, importName, null]);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = data.importsNamespace[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _localName = _step4.value;
          imported.set(_localName, [source, null, _localName]);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = metadata.local[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _exportMeta;

      var _step2$value = _slicedToArray(_step2.value, 2),
          local = _step2$value[0],
          _data = _step2$value[1];

      var exportMeta = exported.get(local);

      if (!exportMeta) {
        exportMeta = [];
        exported.set(local, exportMeta);
      }

      (_exportMeta = exportMeta).push.apply(_exportMeta, _toConsumableArray(_data.names));
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var rewriteBindingInitVisitorState = {
    metadata: metadata,
    requeueInParent: requeueInParent,
    scope: programPath.scope,
    exported: exported
  };
  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
  (0, _helperSimpleAccess["default"])(programPath, new Set([].concat(_toConsumableArray(Array.from(imported.keys())), _toConsumableArray(Array.from(exported.keys())))), false);
  var rewriteReferencesVisitorState = {
    seen: new WeakSet(),
    metadata: metadata,
    requeueInParent: requeueInParent,
    scope: programPath.scope,
    imported: imported,
    exported: exported,
    buildImportReference: function buildImportReference(_ref, identNode) {
      var _ref2 = _slicedToArray(_ref, 3),
          source = _ref2[0],
          importName = _ref2[1],
          localName = _ref2[2];

      var meta = metadata.source.get(source);

      if (localName) {
        if (meta.lazy) {
          identNode = callExpression(identNode, []);
        }

        return identNode;
      }

      var namespace = identifier(meta.name);
      if (meta.lazy) namespace = callExpression(namespace, []);

      if (importName === "default" && meta.interop === "node-default") {
        return namespace;
      }

      var computed = metadata.stringSpecifiers.has(importName);
      return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);
    }
  };
  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
}

var rewriteBindingInitVisitor = {
  Scope: function Scope(path) {
    path.skip();
  },
  ClassDeclaration: function ClassDeclaration(path) {
    var requeueInParent = this.requeueInParent,
        exported = this.exported,
        metadata = this.metadata;
    var id = path.node.id;
    if (!id) throw new Error("Expected class to have a name");
    var localName = id.name;
    var exportNames = exported.get(localName) || [];

    if (exportNames.length > 0) {
      var statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path.scope));
      statement._blockHoist = path.node._blockHoist;
      requeueInParent(path.insertAfter(statement)[0]);
    }
  },
  VariableDeclaration: function VariableDeclaration(path) {
    var requeueInParent = this.requeueInParent,
        exported = this.exported,
        metadata = this.metadata;
    Object.keys(path.getOuterBindingIdentifiers()).forEach(function (localName) {
      var exportNames = exported.get(localName) || [];

      if (exportNames.length > 0) {
        var statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path.scope));
        statement._blockHoist = path.node._blockHoist;
        requeueInParent(path.insertAfter(statement)[0]);
      }
    });
  }
};

var buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr, scope) {
  var exportsObjectName = metadata.exportName;

  for (var currentScope = scope; currentScope != null; currentScope = currentScope.parent) {
    if (currentScope.hasOwnBinding(exportsObjectName)) {
      currentScope.rename(exportsObjectName);
    }
  }

  return (exportNames || []).reduce(function (expr, exportName) {
    var stringSpecifiers = metadata.stringSpecifiers;
    var computed = stringSpecifiers.has(exportName);
    return assignmentExpression("=", memberExpression(identifier(exportsObjectName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);
  }, localExpr);
};

var buildImportThrow = function buildImportThrow(localName) {
  return _template["default"].expression.ast(_templateObject(), localName);
};

var rewriteReferencesVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path) {
    var seen = this.seen,
        buildImportReference = this.buildImportReference,
        scope = this.scope,
        imported = this.imported,
        requeueInParent = this.requeueInParent;
    if (seen.has(path.node)) return;
    seen.add(path.node);
    var localName = path.node.name;
    var importData = imported.get(localName);

    if (importData) {
      if (isInType(path)) {
        throw path.buildCodeFrameError("Cannot transform the imported binding \"".concat(localName, "\" since it's also used in a type annotation. ") + "Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.");
      }

      var localBinding = path.scope.getBinding(localName);
      var rootBinding = scope.getBinding(localName);
      if (rootBinding !== localBinding) return;
      var ref = buildImportReference(importData, path.node);
      ref.loc = path.node.loc;

      if ((path.parentPath.isCallExpression({
        callee: path.node
      }) || path.parentPath.isOptionalCallExpression({
        callee: path.node
      }) || path.parentPath.isTaggedTemplateExpression({
        tag: path.node
      })) && isMemberExpression(ref)) {
        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));
      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {
        var object = ref.object,
            property = ref.property;
        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));
      } else {
        path.replaceWith(ref);
      }

      requeueInParent(path);
      path.skip();
    }
  },
  UpdateExpression: function UpdateExpression(path) {
    var scope = this.scope,
        seen = this.seen,
        imported = this.imported,
        exported = this.exported,
        requeueInParent = this.requeueInParent,
        buildImportReference = this.buildImportReference;
    if (seen.has(path.node)) return;
    seen.add(path.node);
    var arg = path.get("argument");
    if (arg.isMemberExpression()) return;
    var update = path.node;

    if (arg.isIdentifier()) {
      var localName = arg.node.name;

      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
        return;
      }

      var exportedNames = exported.get(localName);
      var importData = imported.get(localName);

      if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
        if (importData) {
          path.replaceWith(assignmentExpression(update.operator[0] + "=", buildImportReference(importData, arg.node), buildImportThrow(localName)));
        } else if (update.prefix) {
          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, cloneNode(update), path.scope));
        } else {
          var ref = scope.generateDeclaredUidIdentifier(localName);
          path.replaceWith(sequenceExpression([assignmentExpression("=", cloneNode(ref), cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path.scope), cloneNode(ref)]));
        }
      }
    }

    requeueInParent(path);
    path.skip();
  },
  AssignmentExpression: {
    exit: function exit(path) {
      var _this = this;

      var scope = this.scope,
          seen = this.seen,
          imported = this.imported,
          exported = this.exported,
          requeueInParent = this.requeueInParent,
          buildImportReference = this.buildImportReference;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      var left = path.get("left");
      if (left.isMemberExpression()) return;

      if (left.isIdentifier()) {
        var localName = left.node.name;

        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
          return;
        }

        var exportedNames = exported.get(localName);
        var importData = imported.get(localName);

        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
          _assert(path.node.operator === "=", "Path was not simplified");

          var assignment = path.node;

          if (importData) {
            assignment.left = buildImportReference(importData, left.node);
            assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);
          }

          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment, path.scope));
          requeueInParent(path);
        }
      } else {
        var ids = left.getOuterBindingIdentifiers();
        var programScopeIds = Object.keys(ids).filter(function (localName) {
          return scope.getBinding(localName) === path.scope.getBinding(localName);
        });
        var id = programScopeIds.find(function (localName) {
          return imported.has(localName);
        });

        if (id) {
          path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);
        }

        var items = [];
        programScopeIds.forEach(function (localName) {
          var exportedNames = exported.get(localName) || [];

          if (exportedNames.length > 0) {
            items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, identifier(localName), path.scope));
          }
        });

        if (items.length > 0) {
          var node = sequenceExpression(items);

          if (path.parentPath.isExpressionStatement()) {
            node = expressionStatement(node);
            node._blockHoist = path.parentPath.node._blockHoist;
          }

          var statement = path.insertAfter(node)[0];
          requeueInParent(statement);
        }
      }
    }
  },
  "ForOfStatement|ForInStatement": function ForOfStatementForInStatement(path) {
    var scope = path.scope,
        node = path.node;
    var left = node.left;
    var exported = this.exported,
        imported = this.imported,
        programScope = this.scope;

    if (!isVariableDeclaration(left)) {
      var didTransformExport = false,
          importConstViolationName;
      var loopBodyScope = path.get("body").scope;

      for (var _i2 = 0, _Object$keys = Object.keys(getOuterBindingIdentifiers(left)); _i2 < _Object$keys.length; _i2++) {
        var name = _Object$keys[_i2];

        if (programScope.getBinding(name) === scope.getBinding(name)) {
          if (exported.has(name)) {
            didTransformExport = true;

            if (loopBodyScope.hasOwnBinding(name)) {
              loopBodyScope.rename(name);
            }
          }

          if (imported.has(name) && !importConstViolationName) {
            importConstViolationName = name;
          }
        }
      }

      if (!didTransformExport && !importConstViolationName) {
        return;
      }

      path.ensureBlock();
      var bodyPath = path.get("body");
      var newLoopId = scope.generateUidIdentifierBasedOnNode(left);
      path.get("left").replaceWith(variableDeclaration("let", [variableDeclarator(cloneNode(newLoopId))]));
      scope.registerDeclaration(path.get("left"));

      if (didTransformExport) {
        bodyPath.unshiftContainer("body", expressionStatement(assignmentExpression("=", left, newLoopId)));
      }

      if (importConstViolationName) {
        bodyPath.unshiftContainer("body", expressionStatement(buildImportThrow(importConstViolationName)));
      }
    }
  }
};