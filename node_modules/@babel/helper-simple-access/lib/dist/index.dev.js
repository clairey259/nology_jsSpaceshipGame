"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = simplifyAccess;

var _t = require("@babel/types");

var LOGICAL_OPERATORS = _t.LOGICAL_OPERATORS,
    assignmentExpression = _t.assignmentExpression,
    binaryExpression = _t.binaryExpression,
    cloneNode = _t.cloneNode,
    identifier = _t.identifier,
    logicalExpression = _t.logicalExpression,
    numericLiteral = _t.numericLiteral,
    sequenceExpression = _t.sequenceExpression,
    unaryExpression = _t.unaryExpression;

function simplifyAccess(path, bindingNames) {
  var includeUpdateExpression = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  path.traverse(simpleAssignmentVisitor, {
    scope: path.scope,
    bindingNames: bindingNames,
    seen: new WeakSet(),
    includeUpdateExpression: includeUpdateExpression
  });
}

var simpleAssignmentVisitor = {
  UpdateExpression: {
    exit: function exit(path) {
      var scope = this.scope,
          bindingNames = this.bindingNames,
          includeUpdateExpression = this.includeUpdateExpression;

      if (!includeUpdateExpression) {
        return;
      }

      var arg = path.get("argument");
      if (!arg.isIdentifier()) return;
      var localName = arg.node.name;
      if (!bindingNames.has(localName)) return;

      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
        return;
      }

      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
        var operator = path.node.operator == "++" ? "+=" : "-=";
        path.replaceWith(assignmentExpression(operator, arg.node, numericLiteral(1)));
      } else if (path.node.prefix) {
        path.replaceWith(assignmentExpression("=", identifier(localName), binaryExpression(path.node.operator[0], unaryExpression("+", arg.node), numericLiteral(1))));
      } else {
        var old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old");
        var varName = old.name;
        path.scope.push({
          id: old
        });
        var binary = binaryExpression(path.node.operator[0], identifier(varName), numericLiteral(1));
        path.replaceWith(sequenceExpression([assignmentExpression("=", identifier(varName), unaryExpression("+", arg.node)), assignmentExpression("=", cloneNode(arg.node), binary), identifier(varName)]));
      }
    }
  },
  AssignmentExpression: {
    exit: function exit(path) {
      var scope = this.scope,
          seen = this.seen,
          bindingNames = this.bindingNames;
      if (path.node.operator === "=") return;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      var left = path.get("left");
      if (!left.isIdentifier()) return;
      var localName = left.node.name;
      if (!bindingNames.has(localName)) return;

      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
        return;
      }

      var operator = path.node.operator.slice(0, -1);

      if (LOGICAL_OPERATORS.includes(operator)) {
        path.replaceWith(logicalExpression(operator, path.node.left, assignmentExpression("=", cloneNode(path.node.left), path.node.right)));
      } else {
        path.node.right = binaryExpression(operator, cloneNode(path.node.left), path.node.right);
        path.node.operator = "=";
      }
    }
  }
};