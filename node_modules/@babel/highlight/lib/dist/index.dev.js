"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = highlight;
exports.getChalk = getChalk;
exports.shouldHighlight = shouldHighlight;

var _jsTokens = require("js-tokens");

var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");

var _chalk = require("chalk");

var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);

function getDefs(chalk) {
  return {
    keyword: chalk.cyan,
    capitalized: chalk.yellow,
    jsxIdentifier: chalk.yellow,
    punctuator: chalk.yellow,
    number: chalk.magenta,
    string: chalk.green,
    regex: chalk.magenta,
    comment: chalk.grey,
    invalid: chalk.white.bgRed.bold
  };
}

var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
var BRACKET = /^[()[\]{}]$/;
var tokenize;
{
  var JSX_TAG = /^[a-z][\w-]*$/i;

  var getTokenType = function getTokenType(token, offset, text) {
    if (token.type === "name") {
      if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
        return "keyword";
      }

      if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
        return "jsxIdentifier";
      }

      if (token.value[0] !== token.value[0].toLowerCase()) {
        return "capitalized";
      }
    }

    if (token.type === "punctuator" && BRACKET.test(token.value)) {
      return "bracket";
    }

    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
      return "punctuator";
    }

    return token.type;
  };

  tokenize =
  /*#__PURE__*/
  regeneratorRuntime.mark(function tokenize(text) {
    var match, token;
    return regeneratorRuntime.wrap(function tokenize$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(match = _jsTokens["default"].exec(text))) {
              _context.next = 6;
              break;
            }

            token = _jsTokens.matchToToken(match);
            _context.next = 4;
            return {
              type: getTokenType(token, match.index, text),
              value: token.value
            };

          case 4:
            _context.next = 0;
            break;

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, tokenize);
  });
}

function highlightTokens(defs, text) {
  var highlighted = "";
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var _step$value = _step.value,
          type = _step$value.type,
          value = _step$value.value;
      var colorize = defs[type];

      if (colorize) {
        highlighted += value.split(NEWLINE).map(function (str) {
          return colorize(str);
        }).join("\n");
      } else {
        highlighted += value;
      }
    };

    for (var _iterator = tokenize(text)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return highlighted;
}

function shouldHighlight(options) {
  return !!_chalk.supportsColor || options.forceColor;
}

function getChalk(options) {
  return options.forceColor ? new _chalk.constructor({
    enabled: true,
    level: 1
  }) : _chalk;
}

function highlight(code) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (code !== "" && shouldHighlight(options)) {
    var chalk = getChalk(options);
    var defs = getDefs(chalk);
    return highlightTokens(defs, code);
  } else {
    return code;
  }
}