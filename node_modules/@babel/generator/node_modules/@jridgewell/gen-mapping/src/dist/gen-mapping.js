"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.GenMapping = exports.allMappings = exports.fromMap = exports.toEncodedMap = exports.toDecodedMap = exports.setSourceContent = exports.maybeAddMapping = exports.maybeAddSegment = exports.addMapping = exports.addSegment = void 0;
var set_array_1 = require("@jridgewell/set-array");
var sourcemap_codec_1 = require("@jridgewell/sourcemap-codec");
var trace_mapping_1 = require("@jridgewell/trace-mapping");
var sourcemap_segment_1 = require("./sourcemap-segment");
var NO_NAME = -1;
// This split declaration is only so that terser can elminiate the static initialization block.
var addSegmentInternal;
/**
 * Provides the state to generate a sourcemap.
 */
var GenMapping = /** @class */ (function () {
    function GenMapping(_a) {
        var _b = _a === void 0 ? {} : _a, file = _b.file, sourceRoot = _b.sourceRoot;
        this._names = new set_array_1.SetArray();
        this._sources = new set_array_1.SetArray();
        this._sourcesContent = [];
        this._mappings = [];
        this.file = file;
        this.sourceRoot = sourceRoot;
    }
    return GenMapping;
}());
exports.GenMapping = GenMapping;
{
    exports.addSegment = function (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    };
    exports.maybeAddSegment = function (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    };
    exports.addMapping = function (map, mapping) {
        return addMappingInternal(false, map, mapping);
    };
    exports.maybeAddMapping = function (map, mapping) {
        return addMappingInternal(true, map, mapping);
    };
    exports.setSourceContent = function (map, source, content) {
        var sources = map._sources, sourcesContent = map._sourcesContent;
        sourcesContent[set_array_1.put(sources, source)] = content;
    };
    exports.toDecodedMap = function (map) {
        var file = map.file, sourceRoot = map.sourceRoot, mappings = map._mappings, sources = map._sources, sourcesContent = map._sourcesContent, names = map._names;
        removeEmptyFinalLines(mappings);
        return {
            version: 3,
            file: file || undefined,
            names: names.array,
            sourceRoot: sourceRoot || undefined,
            sources: sources.array,
            sourcesContent: sourcesContent,
            mappings: mappings
        };
    };
    exports.toEncodedMap = function (map) {
        var decoded = exports.toDecodedMap(map);
        return __assign(__assign({}, decoded), { mappings: sourcemap_codec_1.encode(decoded.mappings) });
    };
    exports.allMappings = function (map) {
        var out = [];
        var mappings = map._mappings, sources = map._sources, names = map._names;
        for (var i = 0; i < mappings.length; i++) {
            var line = mappings[i];
            for (var j = 0; j < line.length; j++) {
                var seg = line[j];
                var generated = { line: i + 1, column: seg[sourcemap_segment_1.COLUMN] };
                var source = undefined;
                var original = undefined;
                var name = undefined;
                if (seg.length !== 1) {
                    source = sources.array[seg[sourcemap_segment_1.SOURCES_INDEX]];
                    original = { line: seg[sourcemap_segment_1.SOURCE_LINE] + 1, column: seg[sourcemap_segment_1.SOURCE_COLUMN] };
                    if (seg.length === 5)
                        name = names.array[seg[sourcemap_segment_1.NAMES_INDEX]];
                }
                out.push({ generated: generated, source: source, original: original, name: name });
            }
        }
        return out;
    };
    exports.fromMap = function (input) {
        var map = new trace_mapping_1.TraceMap(input);
        var gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(gen._names, map.names);
        putAll(gen._sources, map.sources);
        gen._sourcesContent = map.sourcesContent || map.sources.map(function () { return null; });
        gen._mappings = trace_mapping_1.decodedMappings(map);
        return gen;
    };
    // Internal helpers
    addSegmentInternal = function (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        var mappings = map._mappings, sources = map._sources, sourcesContent = map._sourcesContent, names = map._names;
        var line = getLine(mappings, genLine);
        var index = getColumnIndex(line, genColumn);
        if (!source) {
            if (skipable && skipSourceless(line, index))
                return;
            return insert(line, index, [genColumn]);
        }
        // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source
        // isn't nullish.
        assert(sourceLine);
        assert(sourceColumn);
        var sourcesIndex = set_array_1.put(sources, source);
        var namesIndex = name ? set_array_1.put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
            sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
            return;
        }
        return insert(line, index, name
            ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]
            : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
    };
}
function assert(_val) {
    // noop.
}
function getLine(mappings, index) {
    for (var i = mappings.length; i <= index; i++) {
        mappings[i] = [];
    }
    return mappings[index];
}
function getColumnIndex(line, genColumn) {
    var index = line.length;
    for (var i = index - 1; i >= 0; index = i--) {
        var current = line[i];
        if (genColumn >= current[sourcemap_segment_1.COLUMN])
            break;
    }
    return index;
}
function insert(array, index, value) {
    for (var i = array.length; i > index; i--) {
        array[i] = array[i - 1];
    }
    array[index] = value;
}
function removeEmptyFinalLines(mappings) {
    var length = mappings.length;
    var len = length;
    for (var i = len - 1; i >= 0; len = i, i--) {
        if (mappings[i].length > 0)
            break;
    }
    if (len < length)
        mappings.length = len;
}
function putAll(strarr, array) {
    for (var i = 0; i < array.length; i++)
        set_array_1.put(strarr, array[i]);
}
function skipSourceless(line, index) {
    // The start of a line is already sourceless, so adding a sourceless segment to the beginning
    // doesn't generate any useful information.
    if (index === 0)
        return true;
    var prev = line[index - 1];
    // If the previous segment is also sourceless, then adding another sourceless segment doesn't
    // genrate any new information. Else, this segment will end the source/named segment and point to
    // a sourceless position, which is useful.
    return prev.length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
    // A source/named segment at the start of a line gives position at that genColumn
    if (index === 0)
        return false;
    var prev = line[index - 1];
    // If the previous segment is sourceless, then we're transitioning to a source.
    if (prev.length === 1)
        return false;
    // If the previous segment maps to the exact same source position, then this segment doesn't
    // provide any new position information.
    return (sourcesIndex === prev[sourcemap_segment_1.SOURCES_INDEX] &&
        sourceLine === prev[sourcemap_segment_1.SOURCE_LINE] &&
        sourceColumn === prev[sourcemap_segment_1.SOURCE_COLUMN] &&
        namesIndex === (prev.length === 5 ? prev[sourcemap_segment_1.NAMES_INDEX] : NO_NAME));
}
function addMappingInternal(skipable, map, mapping) {
    var generated = mapping.generated, source = mapping.source, original = mapping.original, name = mapping.name, content = mapping.content;
    if (!source) {
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
    }
    var s = source;
    assert(original);
    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);
}
