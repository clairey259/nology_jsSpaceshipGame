"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function SourcePos() {
  return {
    identifierName: undefined,
    line: undefined,
    column: undefined,
    filename: undefined
  };
}

var Buffer =
/*#__PURE__*/
function () {
  function Buffer(map) {
    _classCallCheck(this, Buffer);

    this._map = null;
    this._buf = "";
    this._str = "";
    this._appendCount = 0;
    this._last = 0;
    this._queue = [];
    this._queueCursor = 0;
    this._position = {
      line: 1,
      column: 0
    };
    this._sourcePosition = SourcePos();
    this._disallowedPop = {
      identifierName: undefined,
      line: undefined,
      column: undefined,
      filename: undefined,
      objectReusable: true
    };
    this._map = map;

    this._allocQueue();
  }

  _createClass(Buffer, [{
    key: "_allocQueue",
    value: function _allocQueue() {
      var queue = this._queue;

      for (var i = 0; i < 16; i++) {
        queue.push({
          "char": 0,
          repeat: 1,
          line: undefined,
          column: undefined,
          identifierName: undefined,
          filename: ""
        });
      }
    }
  }, {
    key: "_pushQueue",
    value: function _pushQueue(_char, repeat, line, column, identifierName, filename) {
      var cursor = this._queueCursor;

      if (cursor === this._queue.length) {
        this._allocQueue();
      }

      var item = this._queue[cursor];
      item["char"] = _char;
      item.repeat = repeat;
      item.line = line;
      item.column = column;
      item.identifierName = identifierName;
      item.filename = filename;
      this._queueCursor++;
    }
  }, {
    key: "_popQueue",
    value: function _popQueue() {
      if (this._queueCursor === 0) {
        throw new Error("Cannot pop from empty queue");
      }

      return this._queue[--this._queueCursor];
    }
  }, {
    key: "get",
    value: function get() {
      this._flush();

      var map = this._map;
      var result = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: map == null ? void 0 : map.getDecoded(),

        get map() {
          var resultMap = map ? map.get() : null;
          result.map = resultMap;
          return resultMap;
        },

        set map(value) {
          Object.defineProperty(result, "map", {
            value: value,
            writable: true
          });
        },

        get rawMappings() {
          var mappings = map == null ? void 0 : map.getRawMappings();
          result.rawMappings = mappings;
          return mappings;
        },

        set rawMappings(value) {
          Object.defineProperty(result, "rawMappings", {
            value: value,
            writable: true
          });
        }

      };
      return result;
    }
  }, {
    key: "append",
    value: function append(str, maybeNewline) {
      this._flush();

      this._append(str, this._sourcePosition, maybeNewline);
    }
  }, {
    key: "appendChar",
    value: function appendChar(_char2) {
      this._flush();

      this._appendChar(_char2, 1, this._sourcePosition);
    }
  }, {
    key: "queue",
    value: function queue(_char3) {
      if (_char3 === 10) {
        while (this._queueCursor !== 0) {
          var _char4 = this._queue[this._queueCursor - 1]["char"];

          if (_char4 !== 32 && _char4 !== 9) {
            break;
          }

          this._queueCursor--;
        }
      }

      var sourcePosition = this._sourcePosition;

      this._pushQueue(_char3, 1, sourcePosition.line, sourcePosition.column, sourcePosition.identifierName, sourcePosition.filename);
    }
  }, {
    key: "queueIndentation",
    value: function queueIndentation(_char5, repeat) {
      this._pushQueue(_char5, repeat, undefined, undefined, undefined, undefined);
    }
  }, {
    key: "_flush",
    value: function _flush() {
      var queueCursor = this._queueCursor;
      var queue = this._queue;

      for (var i = 0; i < queueCursor; i++) {
        var item = queue[i];

        this._appendChar(item["char"], item.repeat, item);
      }

      this._queueCursor = 0;
    }
  }, {
    key: "_appendChar",
    value: function _appendChar(_char6, repeat, sourcePos) {
      this._last = _char6;
      this._str += repeat > 1 ? String.fromCharCode(_char6).repeat(repeat) : String.fromCharCode(_char6);

      if (_char6 !== 10) {
        this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.filename);

        this._position.column += repeat;
      } else {
        this._position.line++;
        this._position.column = 0;
      }
    }
  }, {
    key: "_append",
    value: function _append(str, sourcePos, maybeNewline) {
      var len = str.length;
      this._last = str.charCodeAt(len - 1);

      if (++this._appendCount > 4096) {
        +this._str;
        this._buf += this._str;
        this._str = str;
        this._appendCount = 0;
      } else {
        this._str += str;
      }

      if (!maybeNewline && !this._map) {
        this._position.column += len;
        return;
      }

      var column = sourcePos.column,
          identifierName = sourcePos.identifierName,
          filename = sourcePos.filename;
      var line = sourcePos.line;
      var i = str.indexOf("\n");
      var last = 0;

      if (i !== 0) {
        this._mark(line, column, identifierName, filename);
      }

      while (i !== -1) {
        this._position.line++;
        this._position.column = 0;
        last = i + 1;

        if (last < str.length) {
          this._mark(++line, 0, identifierName, filename);
        }

        i = str.indexOf("\n", last);
      }

      this._position.column += str.length - last;
    }
  }, {
    key: "_mark",
    value: function _mark(line, column, identifierName, filename) {
      var _this$_map;

      (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, filename);
    }
  }, {
    key: "removeTrailingNewline",
    value: function removeTrailingNewline() {
      var queueCursor = this._queueCursor;

      if (queueCursor !== 0 && this._queue[queueCursor - 1]["char"] === 10) {
        this._queueCursor--;
      }
    }
  }, {
    key: "removeLastSemicolon",
    value: function removeLastSemicolon() {
      var queueCursor = this._queueCursor;

      if (queueCursor !== 0 && this._queue[queueCursor - 1]["char"] === 59) {
        this._queueCursor--;
      }
    }
  }, {
    key: "getLastChar",
    value: function getLastChar() {
      var queueCursor = this._queueCursor;
      return queueCursor !== 0 ? this._queue[queueCursor - 1]["char"] : this._last;
    }
  }, {
    key: "endsWithCharAndNewline",
    value: function endsWithCharAndNewline() {
      var queue = this._queue;
      var queueCursor = this._queueCursor;

      if (queueCursor !== 0) {
        var lastCp = queue[queueCursor - 1]["char"];
        if (lastCp !== 10) return;

        if (queueCursor > 1) {
          return queue[queueCursor - 2]["char"];
        } else {
          return this._last;
        }
      }
    }
  }, {
    key: "hasContent",
    value: function hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
  }, {
    key: "exactSource",
    value: function exactSource(loc, cb) {
      if (!this._map) return cb();
      this.source("start", loc);
      cb();
      this.source("end", loc);

      this._disallowPop("start", loc);
    }
  }, {
    key: "source",
    value: function source(prop, loc) {
      if (!loc) return;

      this._normalizePosition(prop, loc, this._sourcePosition);
    }
  }, {
    key: "withSource",
    value: function withSource(prop, loc, cb) {
      if (!this._map) return cb();
      var originalLine = this._sourcePosition.line;
      var originalColumn = this._sourcePosition.column;
      var originalFilename = this._sourcePosition.filename;
      var originalIdentifierName = this._sourcePosition.identifierName;
      this.source(prop, loc);
      cb();

      if (this._disallowedPop.objectReusable || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename) {
        this._sourcePosition.line = originalLine;
        this._sourcePosition.column = originalColumn;
        this._sourcePosition.filename = originalFilename;
        this._sourcePosition.identifierName = originalIdentifierName;
        this._disallowedPop.objectReusable = true;
      }
    }
  }, {
    key: "_disallowPop",
    value: function _disallowPop(prop, loc) {
      if (!loc) return;
      var disallowedPop = this._disallowedPop;

      this._normalizePosition(prop, loc, disallowedPop);

      disallowedPop.objectReusable = false;
    }
  }, {
    key: "_normalizePosition",
    value: function _normalizePosition(prop, loc, targetObj) {
      var pos = loc[prop];
      targetObj.identifierName = prop === "start" && loc.identifierName || undefined;

      if (pos) {
        targetObj.line = pos.line;
        targetObj.column = pos.column;
        targetObj.filename = loc.filename;
      } else {
        targetObj.line = null;
        targetObj.column = null;
        targetObj.filename = null;
      }
    }
  }, {
    key: "getCurrentColumn",
    value: function getCurrentColumn() {
      var queue = this._queue;
      var lastIndex = -1;
      var len = 0;

      for (var i = 0; i < this._queueCursor; i++) {
        var item = queue[i];

        if (item["char"] === 10) {
          lastIndex = i;
          len += item.repeat;
        }
      }

      return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
    }
  }, {
    key: "getCurrentLine",
    value: function getCurrentLine() {
      var count = 0;
      var queue = this._queue;

      for (var i = 0; i < this._queueCursor; i++) {
        if (queue[i]["char"] === 10) {
          count++;
        }
      }

      return this._position.line + count;
    }
  }]);

  return Buffer;
}();

exports["default"] = Buffer;