"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
exports.ensure = ensure;
exports.get = get;
exports.getDependencies = getDependencies;
exports.list = void 0;
exports.minVersion = minVersion;

var _traverse = require("@babel/traverse");

var _t = require("@babel/types");

var _helpers = require("./helpers");

var assignmentExpression = _t.assignmentExpression,
    cloneNode = _t.cloneNode,
    expressionStatement = _t.expressionStatement,
    file = _t.file,
    identifier = _t.identifier;

function makePath(path) {
  var parts = [];

  for (; path.parentPath; path = path.parentPath) {
    parts.push(path.key);
    if (path.inList) parts.push(path.listKey);
  }

  return parts.reverse().join(".");
}

var FileClass = undefined;

function getHelperMetadata(file) {
  var globals = new Set();
  var localBindingNames = new Set();
  var dependencies = new Map();
  var exportName;
  var exportPath;
  var exportBindingAssignments = [];
  var importPaths = [];
  var importBindingsReferences = [];
  var dependencyVisitor = {
    ImportDeclaration: function ImportDeclaration(child) {
      var name = child.node.source.value;

      if (!_helpers["default"][name]) {
        throw child.buildCodeFrameError("Unknown helper ".concat(name));
      }

      if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier()) {
        throw child.buildCodeFrameError("Helpers can only import a default value");
      }

      var bindingIdentifier = child.node.specifiers[0].local;
      dependencies.set(bindingIdentifier, name);
      importPaths.push(makePath(child));
    },
    ExportDefaultDeclaration: function ExportDefaultDeclaration(child) {
      var decl = child.get("declaration");

      if (!decl.isFunctionDeclaration() || !decl.node.id) {
        throw decl.buildCodeFrameError("Helpers can only export named function declarations");
      }

      exportName = decl.node.id.name;
      exportPath = makePath(child);
    },
    ExportAllDeclaration: function ExportAllDeclaration(child) {
      throw child.buildCodeFrameError("Helpers can only export default");
    },
    ExportNamedDeclaration: function ExportNamedDeclaration(child) {
      throw child.buildCodeFrameError("Helpers can only export default");
    },
    Statement: function Statement(child) {
      if (child.isModuleDeclaration()) return;
      child.skip();
    }
  };
  var referenceVisitor = {
    Program: function Program(path) {
      var bindings = path.scope.getAllBindings();
      Object.keys(bindings).forEach(function (name) {
        if (name === exportName) return;
        if (dependencies.has(bindings[name].identifier)) return;
        localBindingNames.add(name);
      });
    },
    ReferencedIdentifier: function ReferencedIdentifier(child) {
      var name = child.node.name;
      var binding = child.scope.getBinding(name);

      if (!binding) {
        globals.add(name);
      } else if (dependencies.has(binding.identifier)) {
        importBindingsReferences.push(makePath(child));
      }
    },
    AssignmentExpression: function AssignmentExpression(child) {
      var left = child.get("left");
      if (!(exportName in left.getBindingIdentifiers())) return;

      if (!left.isIdentifier()) {
        throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
      }

      var binding = child.scope.getBinding(exportName);

      if (binding != null && binding.scope.path.isProgram()) {
        exportBindingAssignments.push(makePath(child));
      }
    }
  };
  (0, _traverse["default"])(file.ast, dependencyVisitor, file.scope);
  (0, _traverse["default"])(file.ast, referenceVisitor, file.scope);
  if (!exportPath) throw new Error("Helpers must have a default export.");
  exportBindingAssignments.reverse();
  return {
    globals: Array.from(globals),
    localBindingNames: Array.from(localBindingNames),
    dependencies: dependencies,
    exportBindingAssignments: exportBindingAssignments,
    exportPath: exportPath,
    exportName: exportName,
    importBindingsReferences: importBindingsReferences,
    importPaths: importPaths
  };
}

function permuteHelperAST(file, metadata, id, localBindings, getDependency) {
  if (localBindings && !id) {
    throw new Error("Unexpected local bindings for module-based helpers.");
  }

  if (!id) return;
  var localBindingNames = metadata.localBindingNames,
      dependencies = metadata.dependencies,
      exportBindingAssignments = metadata.exportBindingAssignments,
      exportPath = metadata.exportPath,
      exportName = metadata.exportName,
      importBindingsReferences = metadata.importBindingsReferences,
      importPaths = metadata.importPaths;
  var dependenciesRefs = {};
  dependencies.forEach(function (name, id) {
    dependenciesRefs[id.name] = typeof getDependency === "function" && getDependency(name) || id;
  });
  var toRename = {};
  var bindings = new Set(localBindings || []);
  localBindingNames.forEach(function (name) {
    var newName = name;

    while (bindings.has(newName)) {
      newName = "_" + newName;
    }

    if (newName !== name) toRename[name] = newName;
  });

  if (id.type === "Identifier" && exportName !== id.name) {
    toRename[exportName] = id.name;
  }

  var path = file.path;
  var exp = path.get(exportPath);
  var imps = importPaths.map(function (p) {
    return path.get(p);
  });
  var impsBindingRefs = importBindingsReferences.map(function (p) {
    return path.get(p);
  });
  var decl = exp.get("declaration");

  if (id.type === "Identifier") {
    exp.replaceWith(decl);
  } else if (id.type === "MemberExpression") {
    exportBindingAssignments.forEach(function (assignPath) {
      var assign = path.get(assignPath);
      assign.replaceWith(assignmentExpression("=", id, assign.node));
    });
    exp.replaceWith(decl);
    path.pushContainer("body", expressionStatement(assignmentExpression("=", id, identifier(exportName))));
  } else {
    throw new Error("Unexpected helper format.");
  }

  Object.keys(toRename).forEach(function (name) {
    path.scope.rename(name, toRename[name]);
  });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = imps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _path = _step.value;

      _path.remove();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = impsBindingRefs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _path2 = _step2.value;
      var node = cloneNode(dependenciesRefs[_path2.node.name]);

      _path2.replaceWith(node);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

var helperData = Object.create(null);

function loadHelper(name) {
  if (!helperData[name]) {
    var helper = _helpers["default"][name];

    if (!helper) {
      throw Object.assign(new ReferenceError("Unknown helper ".concat(name)), {
        code: "BABEL_HELPER_UNKNOWN",
        helper: name
      });
    }

    var fn = function fn() {
      {
        if (!FileClass) {
          var fakeFile = {
            ast: file(helper.ast()),
            path: null
          };
          (0, _traverse["default"])(fakeFile.ast, {
            Program: function Program(path) {
              return (fakeFile.path = path).stop();
            }
          });
          return fakeFile;
        }
      }
      return new FileClass({
        filename: "babel-helper://".concat(name)
      }, {
        ast: file(helper.ast()),
        code: "[internal Babel helper code]",
        inputMap: null
      });
    };

    var metadata = null;
    helperData[name] = {
      minVersion: helper.minVersion,
      build: function build(getDependency, id, localBindings) {
        var file = fn();
        metadata || (metadata = getHelperMetadata(file));
        permuteHelperAST(file, metadata, id, localBindings, getDependency);
        return {
          nodes: file.ast.program.body,
          globals: metadata.globals
        };
      },
      getDependencies: function getDependencies() {
        metadata || (metadata = getHelperMetadata(fn()));
        return Array.from(metadata.dependencies.values());
      }
    };
  }

  return helperData[name];
}

function get(name, getDependency, id, localBindings) {
  return loadHelper(name).build(getDependency, id, localBindings);
}

function minVersion(name) {
  return loadHelper(name).minVersion;
}

function getDependencies(name) {
  return loadHelper(name).getDependencies();
}

function ensure(name, newFileClass) {
  FileClass || (FileClass = newFileClass);
  loadHelper(name);
}

var list = Object.keys(_helpers["default"]).map(function (name) {
  return name.replace(/^_/, "");
});
exports.list = list;
var _default = get;
exports["default"] = _default;