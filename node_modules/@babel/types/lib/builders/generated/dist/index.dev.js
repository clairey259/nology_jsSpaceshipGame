"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.anyTypeAnnotation = anyTypeAnnotation;
exports.argumentPlaceholder = argumentPlaceholder;
exports.arrayExpression = arrayExpression;
exports.arrayPattern = arrayPattern;
exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.arrowFunctionExpression = arrowFunctionExpression;
exports.assignmentExpression = assignmentExpression;
exports.assignmentPattern = assignmentPattern;
exports.awaitExpression = awaitExpression;
exports.bigIntLiteral = bigIntLiteral;
exports.binaryExpression = binaryExpression;
exports.bindExpression = bindExpression;
exports.blockStatement = blockStatement;
exports.booleanLiteral = booleanLiteral;
exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.breakStatement = breakStatement;
exports.callExpression = callExpression;
exports.catchClause = catchClause;
exports.classAccessorProperty = classAccessorProperty;
exports.classBody = classBody;
exports.classDeclaration = classDeclaration;
exports.classExpression = classExpression;
exports.classImplements = classImplements;
exports.classMethod = classMethod;
exports.classPrivateMethod = classPrivateMethod;
exports.classPrivateProperty = classPrivateProperty;
exports.classProperty = classProperty;
exports.conditionalExpression = conditionalExpression;
exports.continueStatement = continueStatement;
exports.debuggerStatement = debuggerStatement;
exports.decimalLiteral = decimalLiteral;
exports.declareClass = declareClass;
exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.declareExportDeclaration = declareExportDeclaration;
exports.declareFunction = declareFunction;
exports.declareInterface = declareInterface;
exports.declareModule = declareModule;
exports.declareModuleExports = declareModuleExports;
exports.declareOpaqueType = declareOpaqueType;
exports.declareTypeAlias = declareTypeAlias;
exports.declareVariable = declareVariable;
exports.declaredPredicate = declaredPredicate;
exports.decorator = decorator;
exports.directive = directive;
exports.directiveLiteral = directiveLiteral;
exports.doExpression = doExpression;
exports.doWhileStatement = doWhileStatement;
exports.emptyStatement = emptyStatement;
exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.enumBooleanBody = enumBooleanBody;
exports.enumBooleanMember = enumBooleanMember;
exports.enumDeclaration = enumDeclaration;
exports.enumDefaultedMember = enumDefaultedMember;
exports.enumNumberBody = enumNumberBody;
exports.enumNumberMember = enumNumberMember;
exports.enumStringBody = enumStringBody;
exports.enumStringMember = enumStringMember;
exports.enumSymbolBody = enumSymbolBody;
exports.existsTypeAnnotation = existsTypeAnnotation;
exports.exportAllDeclaration = exportAllDeclaration;
exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.exportNamedDeclaration = exportNamedDeclaration;
exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.exportSpecifier = exportSpecifier;
exports.expressionStatement = expressionStatement;
exports.file = file;
exports.forInStatement = forInStatement;
exports.forOfStatement = forOfStatement;
exports.forStatement = forStatement;
exports.functionDeclaration = functionDeclaration;
exports.functionExpression = functionExpression;
exports.functionTypeAnnotation = functionTypeAnnotation;
exports.functionTypeParam = functionTypeParam;
exports.genericTypeAnnotation = genericTypeAnnotation;
exports.identifier = identifier;
exports.ifStatement = ifStatement;
exports["import"] = _import;
exports.importAttribute = importAttribute;
exports.importDeclaration = importDeclaration;
exports.importDefaultSpecifier = importDefaultSpecifier;
exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.importSpecifier = importSpecifier;
exports.indexedAccessType = indexedAccessType;
exports.inferredPredicate = inferredPredicate;
exports.interfaceDeclaration = interfaceDeclaration;
exports.interfaceExtends = interfaceExtends;
exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.interpreterDirective = interpreterDirective;
exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.jSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXText = exports.jsxText = jsxText;
exports.labeledStatement = labeledStatement;
exports.logicalExpression = logicalExpression;
exports.memberExpression = memberExpression;
exports.metaProperty = metaProperty;
exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.moduleExpression = moduleExpression;
exports.newExpression = newExpression;
exports.noop = noop;
exports.nullLiteral = nullLiteral;
exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.numberLiteral = NumberLiteral;
exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.numberTypeAnnotation = numberTypeAnnotation;
exports.numericLiteral = numericLiteral;
exports.objectExpression = objectExpression;
exports.objectMethod = objectMethod;
exports.objectPattern = objectPattern;
exports.objectProperty = objectProperty;
exports.objectTypeAnnotation = objectTypeAnnotation;
exports.objectTypeCallProperty = objectTypeCallProperty;
exports.objectTypeIndexer = objectTypeIndexer;
exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.objectTypeProperty = objectTypeProperty;
exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.opaqueType = opaqueType;
exports.optionalCallExpression = optionalCallExpression;
exports.optionalIndexedAccessType = optionalIndexedAccessType;
exports.optionalMemberExpression = optionalMemberExpression;
exports.parenthesizedExpression = parenthesizedExpression;
exports.pipelineBareFunction = pipelineBareFunction;
exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.pipelineTopicExpression = pipelineTopicExpression;
exports.placeholder = placeholder;
exports.privateName = privateName;
exports.program = program;
exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.recordExpression = recordExpression;
exports.regExpLiteral = regExpLiteral;
exports.regexLiteral = RegexLiteral;
exports.restElement = restElement;
exports.restProperty = RestProperty;
exports.returnStatement = returnStatement;
exports.sequenceExpression = sequenceExpression;
exports.spreadElement = spreadElement;
exports.spreadProperty = SpreadProperty;
exports.staticBlock = staticBlock;
exports.stringLiteral = stringLiteral;
exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.stringTypeAnnotation = stringTypeAnnotation;
exports["super"] = _super;
exports.switchCase = switchCase;
exports.switchStatement = switchStatement;
exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.taggedTemplateExpression = taggedTemplateExpression;
exports.templateElement = templateElement;
exports.templateLiteral = templateLiteral;
exports.thisExpression = thisExpression;
exports.thisTypeAnnotation = thisTypeAnnotation;
exports.throwStatement = throwStatement;
exports.topicReference = topicReference;
exports.tryStatement = tryStatement;
exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSArrayType = exports.tsArrayType = tsArrayType;
exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSImportType = exports.tsImportType = tsImportType;
exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSInferType = exports.tsInferType = tsInferType;
exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSMappedType = exports.tsMappedType = tsMappedType;
exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSRestType = exports.tsRestType = tsRestType;
exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSThisType = exports.tsThisType = tsThisType;
exports.tSTupleType = exports.tsTupleType = tsTupleType;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnionType = exports.tsUnionType = tsUnionType;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tupleExpression = tupleExpression;
exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.typeAlias = typeAlias;
exports.typeAnnotation = typeAnnotation;
exports.typeCastExpression = typeCastExpression;
exports.typeParameter = typeParameter;
exports.typeParameterDeclaration = typeParameterDeclaration;
exports.typeParameterInstantiation = typeParameterInstantiation;
exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.unaryExpression = unaryExpression;
exports.unionTypeAnnotation = unionTypeAnnotation;
exports.updateExpression = updateExpression;
exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.variableDeclaration = variableDeclaration;
exports.variableDeclarator = variableDeclarator;
exports.variance = variance;
exports.voidTypeAnnotation = voidTypeAnnotation;
exports.whileStatement = whileStatement;
exports.withStatement = withStatement;
exports.yieldExpression = yieldExpression;

var _validateNode = require("../validateNode");

function arrayExpression() {
  var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return (0, _validateNode["default"])({
    type: "ArrayExpression",
    elements: elements
  });
}

function assignmentExpression(operator, left, right) {
  return (0, _validateNode["default"])({
    type: "AssignmentExpression",
    operator: operator,
    left: left,
    right: right
  });
}

function binaryExpression(operator, left, right) {
  return (0, _validateNode["default"])({
    type: "BinaryExpression",
    operator: operator,
    left: left,
    right: right
  });
}

function interpreterDirective(value) {
  return (0, _validateNode["default"])({
    type: "InterpreterDirective",
    value: value
  });
}

function directive(value) {
  return (0, _validateNode["default"])({
    type: "Directive",
    value: value
  });
}

function directiveLiteral(value) {
  return (0, _validateNode["default"])({
    type: "DirectiveLiteral",
    value: value
  });
}

function blockStatement(body) {
  var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return (0, _validateNode["default"])({
    type: "BlockStatement",
    body: body,
    directives: directives
  });
}

function breakStatement() {
  var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return (0, _validateNode["default"])({
    type: "BreakStatement",
    label: label
  });
}

function callExpression(callee, _arguments) {
  return (0, _validateNode["default"])({
    type: "CallExpression",
    callee: callee,
    arguments: _arguments
  });
}

function catchClause() {
  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var body = arguments.length > 1 ? arguments[1] : undefined;
  return (0, _validateNode["default"])({
    type: "CatchClause",
    param: param,
    body: body
  });
}

function conditionalExpression(test, consequent, alternate) {
  return (0, _validateNode["default"])({
    type: "ConditionalExpression",
    test: test,
    consequent: consequent,
    alternate: alternate
  });
}

function continueStatement() {
  var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return (0, _validateNode["default"])({
    type: "ContinueStatement",
    label: label
  });
}

function debuggerStatement() {
  return {
    type: "DebuggerStatement"
  };
}

function doWhileStatement(test, body) {
  return (0, _validateNode["default"])({
    type: "DoWhileStatement",
    test: test,
    body: body
  });
}

function emptyStatement() {
  return {
    type: "EmptyStatement"
  };
}

function expressionStatement(expression) {
  return (0, _validateNode["default"])({
    type: "ExpressionStatement",
    expression: expression
  });
}

function file(program) {
  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var tokens = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "File",
    program: program,
    comments: comments,
    tokens: tokens
  });
}

function forInStatement(left, right, body) {
  return (0, _validateNode["default"])({
    type: "ForInStatement",
    left: left,
    right: right,
    body: body
  });
}

function forStatement() {
  var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var test = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var body = arguments.length > 3 ? arguments[3] : undefined;
  return (0, _validateNode["default"])({
    type: "ForStatement",
    init: init,
    test: test,
    update: update,
    body: body
  });
}

function functionDeclaration() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var params = arguments.length > 1 ? arguments[1] : undefined;
  var body = arguments.length > 2 ? arguments[2] : undefined;
  var generator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  return (0, _validateNode["default"])({
    type: "FunctionDeclaration",
    id: id,
    params: params,
    body: body,
    generator: generator,
    async: async
  });
}

function functionExpression() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var params = arguments.length > 1 ? arguments[1] : undefined;
  var body = arguments.length > 2 ? arguments[2] : undefined;
  var generator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  return (0, _validateNode["default"])({
    type: "FunctionExpression",
    id: id,
    params: params,
    body: body,
    generator: generator,
    async: async
  });
}

function identifier(name) {
  return (0, _validateNode["default"])({
    type: "Identifier",
    name: name
  });
}

function ifStatement(test, consequent) {
  var alternate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "IfStatement",
    test: test,
    consequent: consequent,
    alternate: alternate
  });
}

function labeledStatement(label, body) {
  return (0, _validateNode["default"])({
    type: "LabeledStatement",
    label: label,
    body: body
  });
}

function stringLiteral(value) {
  return (0, _validateNode["default"])({
    type: "StringLiteral",
    value: value
  });
}

function numericLiteral(value) {
  return (0, _validateNode["default"])({
    type: "NumericLiteral",
    value: value
  });
}

function nullLiteral() {
  return {
    type: "NullLiteral"
  };
}

function booleanLiteral(value) {
  return (0, _validateNode["default"])({
    type: "BooleanLiteral",
    value: value
  });
}

function regExpLiteral(pattern) {
  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  return (0, _validateNode["default"])({
    type: "RegExpLiteral",
    pattern: pattern,
    flags: flags
  });
}

function logicalExpression(operator, left, right) {
  return (0, _validateNode["default"])({
    type: "LogicalExpression",
    operator: operator,
    left: left,
    right: right
  });
}

function memberExpression(object, property) {
  var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var optional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return (0, _validateNode["default"])({
    type: "MemberExpression",
    object: object,
    property: property,
    computed: computed,
    optional: optional
  });
}

function newExpression(callee, _arguments) {
  return (0, _validateNode["default"])({
    type: "NewExpression",
    callee: callee,
    arguments: _arguments
  });
}

function program(body) {
  var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var sourceType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "script";
  var interpreter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return (0, _validateNode["default"])({
    type: "Program",
    body: body,
    directives: directives,
    sourceType: sourceType,
    interpreter: interpreter,
    sourceFile: null
  });
}

function objectExpression(properties) {
  return (0, _validateNode["default"])({
    type: "ObjectExpression",
    properties: properties
  });
}

function objectMethod() {
  var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "method";
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var params = arguments.length > 2 ? arguments[2] : undefined;
  var body = arguments.length > 3 ? arguments[3] : undefined;
  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var generator = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var async = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  return (0, _validateNode["default"])({
    type: "ObjectMethod",
    kind: kind,
    key: key,
    params: params,
    body: body,
    computed: computed,
    generator: generator,
    async: async
  });
}

function objectProperty(key, value) {
  var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var shorthand = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var decorators = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  return (0, _validateNode["default"])({
    type: "ObjectProperty",
    key: key,
    value: value,
    computed: computed,
    shorthand: shorthand,
    decorators: decorators
  });
}

function restElement(argument) {
  return (0, _validateNode["default"])({
    type: "RestElement",
    argument: argument
  });
}

function returnStatement() {
  var argument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return (0, _validateNode["default"])({
    type: "ReturnStatement",
    argument: argument
  });
}

function sequenceExpression(expressions) {
  return (0, _validateNode["default"])({
    type: "SequenceExpression",
    expressions: expressions
  });
}

function parenthesizedExpression(expression) {
  return (0, _validateNode["default"])({
    type: "ParenthesizedExpression",
    expression: expression
  });
}

function switchCase() {
  var test = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var consequent = arguments.length > 1 ? arguments[1] : undefined;
  return (0, _validateNode["default"])({
    type: "SwitchCase",
    test: test,
    consequent: consequent
  });
}

function switchStatement(discriminant, cases) {
  return (0, _validateNode["default"])({
    type: "SwitchStatement",
    discriminant: discriminant,
    cases: cases
  });
}

function thisExpression() {
  return {
    type: "ThisExpression"
  };
}

function throwStatement(argument) {
  return (0, _validateNode["default"])({
    type: "ThrowStatement",
    argument: argument
  });
}

function tryStatement(block) {
  var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var finalizer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "TryStatement",
    block: block,
    handler: handler,
    finalizer: finalizer
  });
}

function unaryExpression(operator, argument) {
  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return (0, _validateNode["default"])({
    type: "UnaryExpression",
    operator: operator,
    argument: argument,
    prefix: prefix
  });
}

function updateExpression(operator, argument) {
  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return (0, _validateNode["default"])({
    type: "UpdateExpression",
    operator: operator,
    argument: argument,
    prefix: prefix
  });
}

function variableDeclaration(kind, declarations) {
  return (0, _validateNode["default"])({
    type: "VariableDeclaration",
    kind: kind,
    declarations: declarations
  });
}

function variableDeclarator(id) {
  var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "VariableDeclarator",
    id: id,
    init: init
  });
}

function whileStatement(test, body) {
  return (0, _validateNode["default"])({
    type: "WhileStatement",
    test: test,
    body: body
  });
}

function withStatement(object, body) {
  return (0, _validateNode["default"])({
    type: "WithStatement",
    object: object,
    body: body
  });
}

function assignmentPattern(left, right) {
  return (0, _validateNode["default"])({
    type: "AssignmentPattern",
    left: left,
    right: right
  });
}

function arrayPattern(elements) {
  return (0, _validateNode["default"])({
    type: "ArrayPattern",
    elements: elements
  });
}

function arrowFunctionExpression(params, body) {
  var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return (0, _validateNode["default"])({
    type: "ArrowFunctionExpression",
    params: params,
    body: body,
    async: async,
    expression: null
  });
}

function classBody(body) {
  return (0, _validateNode["default"])({
    type: "ClassBody",
    body: body
  });
}

function classExpression() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var body = arguments.length > 2 ? arguments[2] : undefined;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return (0, _validateNode["default"])({
    type: "ClassExpression",
    id: id,
    superClass: superClass,
    body: body,
    decorators: decorators
  });
}

function classDeclaration(id) {
  var superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var body = arguments.length > 2 ? arguments[2] : undefined;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return (0, _validateNode["default"])({
    type: "ClassDeclaration",
    id: id,
    superClass: superClass,
    body: body,
    decorators: decorators
  });
}

function exportAllDeclaration(source) {
  return (0, _validateNode["default"])({
    type: "ExportAllDeclaration",
    source: source
  });
}

function exportDefaultDeclaration(declaration) {
  return (0, _validateNode["default"])({
    type: "ExportDefaultDeclaration",
    declaration: declaration
  });
}

function exportNamedDeclaration() {
  var declaration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var specifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "ExportNamedDeclaration",
    declaration: declaration,
    specifiers: specifiers,
    source: source
  });
}

function exportSpecifier(local, exported) {
  return (0, _validateNode["default"])({
    type: "ExportSpecifier",
    local: local,
    exported: exported
  });
}

function forOfStatement(left, right, body) {
  var _await = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  return (0, _validateNode["default"])({
    type: "ForOfStatement",
    left: left,
    right: right,
    body: body,
    "await": _await
  });
}

function importDeclaration(specifiers, source) {
  return (0, _validateNode["default"])({
    type: "ImportDeclaration",
    specifiers: specifiers,
    source: source
  });
}

function importDefaultSpecifier(local) {
  return (0, _validateNode["default"])({
    type: "ImportDefaultSpecifier",
    local: local
  });
}

function importNamespaceSpecifier(local) {
  return (0, _validateNode["default"])({
    type: "ImportNamespaceSpecifier",
    local: local
  });
}

function importSpecifier(local, imported) {
  return (0, _validateNode["default"])({
    type: "ImportSpecifier",
    local: local,
    imported: imported
  });
}

function metaProperty(meta, property) {
  return (0, _validateNode["default"])({
    type: "MetaProperty",
    meta: meta,
    property: property
  });
}

function classMethod() {
  var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "method";
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var params = arguments.length > 2 ? arguments[2] : undefined;
  var body = arguments.length > 3 ? arguments[3] : undefined;
  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  var generator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var async = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  return (0, _validateNode["default"])({
    type: "ClassMethod",
    kind: kind,
    key: key,
    params: params,
    body: body,
    computed: computed,
    "static": _static,
    generator: generator,
    async: async
  });
}

function objectPattern(properties) {
  return (0, _validateNode["default"])({
    type: "ObjectPattern",
    properties: properties
  });
}

function spreadElement(argument) {
  return (0, _validateNode["default"])({
    type: "SpreadElement",
    argument: argument
  });
}

function _super() {
  return {
    type: "Super"
  };
}

function taggedTemplateExpression(tag, quasi) {
  return (0, _validateNode["default"])({
    type: "TaggedTemplateExpression",
    tag: tag,
    quasi: quasi
  });
}

function templateElement(value) {
  var tail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return (0, _validateNode["default"])({
    type: "TemplateElement",
    value: value,
    tail: tail
  });
}

function templateLiteral(quasis, expressions) {
  return (0, _validateNode["default"])({
    type: "TemplateLiteral",
    quasis: quasis,
    expressions: expressions
  });
}

function yieldExpression() {
  var argument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return (0, _validateNode["default"])({
    type: "YieldExpression",
    argument: argument,
    delegate: delegate
  });
}

function awaitExpression(argument) {
  return (0, _validateNode["default"])({
    type: "AwaitExpression",
    argument: argument
  });
}

function _import() {
  return {
    type: "Import"
  };
}

function bigIntLiteral(value) {
  return (0, _validateNode["default"])({
    type: "BigIntLiteral",
    value: value
  });
}

function exportNamespaceSpecifier(exported) {
  return (0, _validateNode["default"])({
    type: "ExportNamespaceSpecifier",
    exported: exported
  });
}

function optionalMemberExpression(object, property) {
  var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var optional = arguments.length > 3 ? arguments[3] : undefined;
  return (0, _validateNode["default"])({
    type: "OptionalMemberExpression",
    object: object,
    property: property,
    computed: computed,
    optional: optional
  });
}

function optionalCallExpression(callee, _arguments, optional) {
  return (0, _validateNode["default"])({
    type: "OptionalCallExpression",
    callee: callee,
    arguments: _arguments,
    optional: optional
  });
}

function classProperty(key) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  return (0, _validateNode["default"])({
    type: "ClassProperty",
    key: key,
    value: value,
    typeAnnotation: typeAnnotation,
    decorators: decorators,
    computed: computed,
    "static": _static
  });
}

function classAccessorProperty(key) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  return (0, _validateNode["default"])({
    type: "ClassAccessorProperty",
    key: key,
    value: value,
    typeAnnotation: typeAnnotation,
    decorators: decorators,
    computed: computed,
    "static": _static
  });
}

function classPrivateProperty(key) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var decorators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var _static = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  return (0, _validateNode["default"])({
    type: "ClassPrivateProperty",
    key: key,
    value: value,
    decorators: decorators,
    "static": _static
  });
}

function classPrivateMethod() {
  var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "method";
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var params = arguments.length > 2 ? arguments[2] : undefined;
  var body = arguments.length > 3 ? arguments[3] : undefined;

  var _static = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  return (0, _validateNode["default"])({
    type: "ClassPrivateMethod",
    kind: kind,
    key: key,
    params: params,
    body: body,
    "static": _static
  });
}

function privateName(id) {
  return (0, _validateNode["default"])({
    type: "PrivateName",
    id: id
  });
}

function staticBlock(body) {
  return (0, _validateNode["default"])({
    type: "StaticBlock",
    body: body
  });
}

function anyTypeAnnotation() {
  return {
    type: "AnyTypeAnnotation"
  };
}

function arrayTypeAnnotation(elementType) {
  return (0, _validateNode["default"])({
    type: "ArrayTypeAnnotation",
    elementType: elementType
  });
}

function booleanTypeAnnotation() {
  return {
    type: "BooleanTypeAnnotation"
  };
}

function booleanLiteralTypeAnnotation(value) {
  return (0, _validateNode["default"])({
    type: "BooleanLiteralTypeAnnotation",
    value: value
  });
}

function nullLiteralTypeAnnotation() {
  return {
    type: "NullLiteralTypeAnnotation"
  };
}

function classImplements(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "ClassImplements",
    id: id,
    typeParameters: typeParameters
  });
}

function declareClass(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var body = arguments.length > 3 ? arguments[3] : undefined;
  return (0, _validateNode["default"])({
    type: "DeclareClass",
    id: id,
    typeParameters: typeParameters,
    "extends": _extends,
    body: body
  });
}

function declareFunction(id) {
  return (0, _validateNode["default"])({
    type: "DeclareFunction",
    id: id
  });
}

function declareInterface(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var body = arguments.length > 3 ? arguments[3] : undefined;
  return (0, _validateNode["default"])({
    type: "DeclareInterface",
    id: id,
    typeParameters: typeParameters,
    "extends": _extends,
    body: body
  });
}

function declareModule(id, body) {
  var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "DeclareModule",
    id: id,
    body: body,
    kind: kind
  });
}

function declareModuleExports(typeAnnotation) {
  return (0, _validateNode["default"])({
    type: "DeclareModuleExports",
    typeAnnotation: typeAnnotation
  });
}

function declareTypeAlias(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var right = arguments.length > 2 ? arguments[2] : undefined;
  return (0, _validateNode["default"])({
    type: "DeclareTypeAlias",
    id: id,
    typeParameters: typeParameters,
    right: right
  });
}

function declareOpaqueType(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var supertype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "DeclareOpaqueType",
    id: id,
    typeParameters: typeParameters,
    supertype: supertype
  });
}

function declareVariable(id) {
  return (0, _validateNode["default"])({
    type: "DeclareVariable",
    id: id
  });
}

function declareExportDeclaration() {
  var declaration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var specifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "DeclareExportDeclaration",
    declaration: declaration,
    specifiers: specifiers,
    source: source
  });
}

function declareExportAllDeclaration(source) {
  return (0, _validateNode["default"])({
    type: "DeclareExportAllDeclaration",
    source: source
  });
}

function declaredPredicate(value) {
  return (0, _validateNode["default"])({
    type: "DeclaredPredicate",
    value: value
  });
}

function existsTypeAnnotation() {
  return {
    type: "ExistsTypeAnnotation"
  };
}

function functionTypeAnnotation() {
  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var params = arguments.length > 1 ? arguments[1] : undefined;
  var rest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var returnType = arguments.length > 3 ? arguments[3] : undefined;
  return (0, _validateNode["default"])({
    type: "FunctionTypeAnnotation",
    typeParameters: typeParameters,
    params: params,
    rest: rest,
    returnType: returnType
  });
}

function functionTypeParam() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var typeAnnotation = arguments.length > 1 ? arguments[1] : undefined;
  return (0, _validateNode["default"])({
    type: "FunctionTypeParam",
    name: name,
    typeAnnotation: typeAnnotation
  });
}

function genericTypeAnnotation(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "GenericTypeAnnotation",
    id: id,
    typeParameters: typeParameters
  });
}

function inferredPredicate() {
  return {
    type: "InferredPredicate"
  };
}

function interfaceExtends(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "InterfaceExtends",
    id: id,
    typeParameters: typeParameters
  });
}

function interfaceDeclaration(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var body = arguments.length > 3 ? arguments[3] : undefined;
  return (0, _validateNode["default"])({
    type: "InterfaceDeclaration",
    id: id,
    typeParameters: typeParameters,
    "extends": _extends,
    body: body
  });
}

function interfaceTypeAnnotation() {
  var _extends = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  var body = arguments.length > 1 ? arguments[1] : undefined;
  return (0, _validateNode["default"])({
    type: "InterfaceTypeAnnotation",
    "extends": _extends,
    body: body
  });
}

function intersectionTypeAnnotation(types) {
  return (0, _validateNode["default"])({
    type: "IntersectionTypeAnnotation",
    types: types
  });
}

function mixedTypeAnnotation() {
  return {
    type: "MixedTypeAnnotation"
  };
}

function emptyTypeAnnotation() {
  return {
    type: "EmptyTypeAnnotation"
  };
}

function nullableTypeAnnotation(typeAnnotation) {
  return (0, _validateNode["default"])({
    type: "NullableTypeAnnotation",
    typeAnnotation: typeAnnotation
  });
}

function numberLiteralTypeAnnotation(value) {
  return (0, _validateNode["default"])({
    type: "NumberLiteralTypeAnnotation",
    value: value
  });
}

function numberTypeAnnotation() {
  return {
    type: "NumberTypeAnnotation"
  };
}

function objectTypeAnnotation(properties) {
  var indexers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var callProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var internalSlots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var exact = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  return (0, _validateNode["default"])({
    type: "ObjectTypeAnnotation",
    properties: properties,
    indexers: indexers,
    callProperties: callProperties,
    internalSlots: internalSlots,
    exact: exact
  });
}

function objectTypeInternalSlot(id, value, optional, _static, method) {
  return (0, _validateNode["default"])({
    type: "ObjectTypeInternalSlot",
    id: id,
    value: value,
    optional: optional,
    "static": _static,
    method: method
  });
}

function objectTypeCallProperty(value) {
  return (0, _validateNode["default"])({
    type: "ObjectTypeCallProperty",
    value: value,
    "static": null
  });
}

function objectTypeIndexer() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var value = arguments.length > 2 ? arguments[2] : undefined;
  var variance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return (0, _validateNode["default"])({
    type: "ObjectTypeIndexer",
    id: id,
    key: key,
    value: value,
    variance: variance,
    "static": null
  });
}

function objectTypeProperty(key, value) {
  var variance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "ObjectTypeProperty",
    key: key,
    value: value,
    variance: variance,
    kind: null,
    method: null,
    optional: null,
    proto: null,
    "static": null
  });
}

function objectTypeSpreadProperty(argument) {
  return (0, _validateNode["default"])({
    type: "ObjectTypeSpreadProperty",
    argument: argument
  });
}

function opaqueType(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var supertype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var impltype = arguments.length > 3 ? arguments[3] : undefined;
  return (0, _validateNode["default"])({
    type: "OpaqueType",
    id: id,
    typeParameters: typeParameters,
    supertype: supertype,
    impltype: impltype
  });
}

function qualifiedTypeIdentifier(id, qualification) {
  return (0, _validateNode["default"])({
    type: "QualifiedTypeIdentifier",
    id: id,
    qualification: qualification
  });
}

function stringLiteralTypeAnnotation(value) {
  return (0, _validateNode["default"])({
    type: "StringLiteralTypeAnnotation",
    value: value
  });
}

function stringTypeAnnotation() {
  return {
    type: "StringTypeAnnotation"
  };
}

function symbolTypeAnnotation() {
  return {
    type: "SymbolTypeAnnotation"
  };
}

function thisTypeAnnotation() {
  return {
    type: "ThisTypeAnnotation"
  };
}

function tupleTypeAnnotation(types) {
  return (0, _validateNode["default"])({
    type: "TupleTypeAnnotation",
    types: types
  });
}

function typeofTypeAnnotation(argument) {
  return (0, _validateNode["default"])({
    type: "TypeofTypeAnnotation",
    argument: argument
  });
}

function typeAlias(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var right = arguments.length > 2 ? arguments[2] : undefined;
  return (0, _validateNode["default"])({
    type: "TypeAlias",
    id: id,
    typeParameters: typeParameters,
    right: right
  });
}

function typeAnnotation(typeAnnotation) {
  return (0, _validateNode["default"])({
    type: "TypeAnnotation",
    typeAnnotation: typeAnnotation
  });
}

function typeCastExpression(expression, typeAnnotation) {
  return (0, _validateNode["default"])({
    type: "TypeCastExpression",
    expression: expression,
    typeAnnotation: typeAnnotation
  });
}

function typeParameter() {
  var bound = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  var _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var variance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "TypeParameter",
    bound: bound,
    "default": _default,
    variance: variance,
    name: null
  });
}

function typeParameterDeclaration(params) {
  return (0, _validateNode["default"])({
    type: "TypeParameterDeclaration",
    params: params
  });
}

function typeParameterInstantiation(params) {
  return (0, _validateNode["default"])({
    type: "TypeParameterInstantiation",
    params: params
  });
}

function unionTypeAnnotation(types) {
  return (0, _validateNode["default"])({
    type: "UnionTypeAnnotation",
    types: types
  });
}

function variance(kind) {
  return (0, _validateNode["default"])({
    type: "Variance",
    kind: kind
  });
}

function voidTypeAnnotation() {
  return {
    type: "VoidTypeAnnotation"
  };
}

function enumDeclaration(id, body) {
  return (0, _validateNode["default"])({
    type: "EnumDeclaration",
    id: id,
    body: body
  });
}

function enumBooleanBody(members) {
  return (0, _validateNode["default"])({
    type: "EnumBooleanBody",
    members: members,
    explicitType: null,
    hasUnknownMembers: null
  });
}

function enumNumberBody(members) {
  return (0, _validateNode["default"])({
    type: "EnumNumberBody",
    members: members,
    explicitType: null,
    hasUnknownMembers: null
  });
}

function enumStringBody(members) {
  return (0, _validateNode["default"])({
    type: "EnumStringBody",
    members: members,
    explicitType: null,
    hasUnknownMembers: null
  });
}

function enumSymbolBody(members) {
  return (0, _validateNode["default"])({
    type: "EnumSymbolBody",
    members: members,
    hasUnknownMembers: null
  });
}

function enumBooleanMember(id) {
  return (0, _validateNode["default"])({
    type: "EnumBooleanMember",
    id: id,
    init: null
  });
}

function enumNumberMember(id, init) {
  return (0, _validateNode["default"])({
    type: "EnumNumberMember",
    id: id,
    init: init
  });
}

function enumStringMember(id, init) {
  return (0, _validateNode["default"])({
    type: "EnumStringMember",
    id: id,
    init: init
  });
}

function enumDefaultedMember(id) {
  return (0, _validateNode["default"])({
    type: "EnumDefaultedMember",
    id: id
  });
}

function indexedAccessType(objectType, indexType) {
  return (0, _validateNode["default"])({
    type: "IndexedAccessType",
    objectType: objectType,
    indexType: indexType
  });
}

function optionalIndexedAccessType(objectType, indexType) {
  return (0, _validateNode["default"])({
    type: "OptionalIndexedAccessType",
    objectType: objectType,
    indexType: indexType,
    optional: null
  });
}

function jsxAttribute(name) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "JSXAttribute",
    name: name,
    value: value
  });
}

function jsxClosingElement(name) {
  return (0, _validateNode["default"])({
    type: "JSXClosingElement",
    name: name
  });
}

function jsxElement(openingElement) {
  var closingElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var children = arguments.length > 2 ? arguments[2] : undefined;
  var selfClosing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return (0, _validateNode["default"])({
    type: "JSXElement",
    openingElement: openingElement,
    closingElement: closingElement,
    children: children,
    selfClosing: selfClosing
  });
}

function jsxEmptyExpression() {
  return {
    type: "JSXEmptyExpression"
  };
}

function jsxExpressionContainer(expression) {
  return (0, _validateNode["default"])({
    type: "JSXExpressionContainer",
    expression: expression
  });
}

function jsxSpreadChild(expression) {
  return (0, _validateNode["default"])({
    type: "JSXSpreadChild",
    expression: expression
  });
}

function jsxIdentifier(name) {
  return (0, _validateNode["default"])({
    type: "JSXIdentifier",
    name: name
  });
}

function jsxMemberExpression(object, property) {
  return (0, _validateNode["default"])({
    type: "JSXMemberExpression",
    object: object,
    property: property
  });
}

function jsxNamespacedName(namespace, name) {
  return (0, _validateNode["default"])({
    type: "JSXNamespacedName",
    namespace: namespace,
    name: name
  });
}

function jsxOpeningElement(name, attributes) {
  var selfClosing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return (0, _validateNode["default"])({
    type: "JSXOpeningElement",
    name: name,
    attributes: attributes,
    selfClosing: selfClosing
  });
}

function jsxSpreadAttribute(argument) {
  return (0, _validateNode["default"])({
    type: "JSXSpreadAttribute",
    argument: argument
  });
}

function jsxText(value) {
  return (0, _validateNode["default"])({
    type: "JSXText",
    value: value
  });
}

function jsxFragment(openingFragment, closingFragment, children) {
  return (0, _validateNode["default"])({
    type: "JSXFragment",
    openingFragment: openingFragment,
    closingFragment: closingFragment,
    children: children
  });
}

function jsxOpeningFragment() {
  return {
    type: "JSXOpeningFragment"
  };
}

function jsxClosingFragment() {
  return {
    type: "JSXClosingFragment"
  };
}

function noop() {
  return {
    type: "Noop"
  };
}

function placeholder(expectedNode, name) {
  return (0, _validateNode["default"])({
    type: "Placeholder",
    expectedNode: expectedNode,
    name: name
  });
}

function v8IntrinsicIdentifier(name) {
  return (0, _validateNode["default"])({
    type: "V8IntrinsicIdentifier",
    name: name
  });
}

function argumentPlaceholder() {
  return {
    type: "ArgumentPlaceholder"
  };
}

function bindExpression(object, callee) {
  return (0, _validateNode["default"])({
    type: "BindExpression",
    object: object,
    callee: callee
  });
}

function importAttribute(key, value) {
  return (0, _validateNode["default"])({
    type: "ImportAttribute",
    key: key,
    value: value
  });
}

function decorator(expression) {
  return (0, _validateNode["default"])({
    type: "Decorator",
    expression: expression
  });
}

function doExpression(body) {
  var async = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return (0, _validateNode["default"])({
    type: "DoExpression",
    body: body,
    async: async
  });
}

function exportDefaultSpecifier(exported) {
  return (0, _validateNode["default"])({
    type: "ExportDefaultSpecifier",
    exported: exported
  });
}

function recordExpression(properties) {
  return (0, _validateNode["default"])({
    type: "RecordExpression",
    properties: properties
  });
}

function tupleExpression() {
  var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return (0, _validateNode["default"])({
    type: "TupleExpression",
    elements: elements
  });
}

function decimalLiteral(value) {
  return (0, _validateNode["default"])({
    type: "DecimalLiteral",
    value: value
  });
}

function moduleExpression(body) {
  return (0, _validateNode["default"])({
    type: "ModuleExpression",
    body: body
  });
}

function topicReference() {
  return {
    type: "TopicReference"
  };
}

function pipelineTopicExpression(expression) {
  return (0, _validateNode["default"])({
    type: "PipelineTopicExpression",
    expression: expression
  });
}

function pipelineBareFunction(callee) {
  return (0, _validateNode["default"])({
    type: "PipelineBareFunction",
    callee: callee
  });
}

function pipelinePrimaryTopicReference() {
  return {
    type: "PipelinePrimaryTopicReference"
  };
}

function tsParameterProperty(parameter) {
  return (0, _validateNode["default"])({
    type: "TSParameterProperty",
    parameter: parameter
  });
}

function tsDeclareFunction() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var params = arguments.length > 2 ? arguments[2] : undefined;
  var returnType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return (0, _validateNode["default"])({
    type: "TSDeclareFunction",
    id: id,
    typeParameters: typeParameters,
    params: params,
    returnType: returnType
  });
}

function tsDeclareMethod() {
  var decorators = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var typeParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var params = arguments.length > 3 ? arguments[3] : undefined;
  var returnType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  return (0, _validateNode["default"])({
    type: "TSDeclareMethod",
    decorators: decorators,
    key: key,
    typeParameters: typeParameters,
    params: params,
    returnType: returnType
  });
}

function tsQualifiedName(left, right) {
  return (0, _validateNode["default"])({
    type: "TSQualifiedName",
    left: left,
    right: right
  });
}

function tsCallSignatureDeclaration() {
  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var parameters = arguments.length > 1 ? arguments[1] : undefined;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "TSCallSignatureDeclaration",
    typeParameters: typeParameters,
    parameters: parameters,
    typeAnnotation: typeAnnotation
  });
}

function tsConstructSignatureDeclaration() {
  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var parameters = arguments.length > 1 ? arguments[1] : undefined;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "TSConstructSignatureDeclaration",
    typeParameters: typeParameters,
    parameters: parameters,
    typeAnnotation: typeAnnotation
  });
}

function tsPropertySignature(key) {
  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var initializer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "TSPropertySignature",
    key: key,
    typeAnnotation: typeAnnotation,
    initializer: initializer,
    kind: null
  });
}

function tsMethodSignature(key) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var parameters = arguments.length > 2 ? arguments[2] : undefined;
  var typeAnnotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return (0, _validateNode["default"])({
    type: "TSMethodSignature",
    key: key,
    typeParameters: typeParameters,
    parameters: parameters,
    typeAnnotation: typeAnnotation,
    kind: null
  });
}

function tsIndexSignature(parameters) {
  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "TSIndexSignature",
    parameters: parameters,
    typeAnnotation: typeAnnotation
  });
}

function tsAnyKeyword() {
  return {
    type: "TSAnyKeyword"
  };
}

function tsBooleanKeyword() {
  return {
    type: "TSBooleanKeyword"
  };
}

function tsBigIntKeyword() {
  return {
    type: "TSBigIntKeyword"
  };
}

function tsIntrinsicKeyword() {
  return {
    type: "TSIntrinsicKeyword"
  };
}

function tsNeverKeyword() {
  return {
    type: "TSNeverKeyword"
  };
}

function tsNullKeyword() {
  return {
    type: "TSNullKeyword"
  };
}

function tsNumberKeyword() {
  return {
    type: "TSNumberKeyword"
  };
}

function tsObjectKeyword() {
  return {
    type: "TSObjectKeyword"
  };
}

function tsStringKeyword() {
  return {
    type: "TSStringKeyword"
  };
}

function tsSymbolKeyword() {
  return {
    type: "TSSymbolKeyword"
  };
}

function tsUndefinedKeyword() {
  return {
    type: "TSUndefinedKeyword"
  };
}

function tsUnknownKeyword() {
  return {
    type: "TSUnknownKeyword"
  };
}

function tsVoidKeyword() {
  return {
    type: "TSVoidKeyword"
  };
}

function tsThisType() {
  return {
    type: "TSThisType"
  };
}

function tsFunctionType() {
  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var parameters = arguments.length > 1 ? arguments[1] : undefined;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "TSFunctionType",
    typeParameters: typeParameters,
    parameters: parameters,
    typeAnnotation: typeAnnotation
  });
}

function tsConstructorType() {
  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var parameters = arguments.length > 1 ? arguments[1] : undefined;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "TSConstructorType",
    typeParameters: typeParameters,
    parameters: parameters,
    typeAnnotation: typeAnnotation
  });
}

function tsTypeReference(typeName) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "TSTypeReference",
    typeName: typeName,
    typeParameters: typeParameters
  });
}

function tsTypePredicate(parameterName) {
  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var asserts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "TSTypePredicate",
    parameterName: parameterName,
    typeAnnotation: typeAnnotation,
    asserts: asserts
  });
}

function tsTypeQuery(exprName) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "TSTypeQuery",
    exprName: exprName,
    typeParameters: typeParameters
  });
}

function tsTypeLiteral(members) {
  return (0, _validateNode["default"])({
    type: "TSTypeLiteral",
    members: members
  });
}

function tsArrayType(elementType) {
  return (0, _validateNode["default"])({
    type: "TSArrayType",
    elementType: elementType
  });
}

function tsTupleType(elementTypes) {
  return (0, _validateNode["default"])({
    type: "TSTupleType",
    elementTypes: elementTypes
  });
}

function tsOptionalType(typeAnnotation) {
  return (0, _validateNode["default"])({
    type: "TSOptionalType",
    typeAnnotation: typeAnnotation
  });
}

function tsRestType(typeAnnotation) {
  return (0, _validateNode["default"])({
    type: "TSRestType",
    typeAnnotation: typeAnnotation
  });
}

function tsNamedTupleMember(label, elementType) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return (0, _validateNode["default"])({
    type: "TSNamedTupleMember",
    label: label,
    elementType: elementType,
    optional: optional
  });
}

function tsUnionType(types) {
  return (0, _validateNode["default"])({
    type: "TSUnionType",
    types: types
  });
}

function tsIntersectionType(types) {
  return (0, _validateNode["default"])({
    type: "TSIntersectionType",
    types: types
  });
}

function tsConditionalType(checkType, extendsType, trueType, falseType) {
  return (0, _validateNode["default"])({
    type: "TSConditionalType",
    checkType: checkType,
    extendsType: extendsType,
    trueType: trueType,
    falseType: falseType
  });
}

function tsInferType(typeParameter) {
  return (0, _validateNode["default"])({
    type: "TSInferType",
    typeParameter: typeParameter
  });
}

function tsParenthesizedType(typeAnnotation) {
  return (0, _validateNode["default"])({
    type: "TSParenthesizedType",
    typeAnnotation: typeAnnotation
  });
}

function tsTypeOperator(typeAnnotation) {
  return (0, _validateNode["default"])({
    type: "TSTypeOperator",
    typeAnnotation: typeAnnotation,
    operator: null
  });
}

function tsIndexedAccessType(objectType, indexType) {
  return (0, _validateNode["default"])({
    type: "TSIndexedAccessType",
    objectType: objectType,
    indexType: indexType
  });
}

function tsMappedType(typeParameter) {
  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var nameType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "TSMappedType",
    typeParameter: typeParameter,
    typeAnnotation: typeAnnotation,
    nameType: nameType
  });
}

function tsLiteralType(literal) {
  return (0, _validateNode["default"])({
    type: "TSLiteralType",
    literal: literal
  });
}

function tsExpressionWithTypeArguments(expression) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "TSExpressionWithTypeArguments",
    expression: expression,
    typeParameters: typeParameters
  });
}

function tsInterfaceDeclaration(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var body = arguments.length > 3 ? arguments[3] : undefined;
  return (0, _validateNode["default"])({
    type: "TSInterfaceDeclaration",
    id: id,
    typeParameters: typeParameters,
    "extends": _extends,
    body: body
  });
}

function tsInterfaceBody(body) {
  return (0, _validateNode["default"])({
    type: "TSInterfaceBody",
    body: body
  });
}

function tsTypeAliasDeclaration(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var typeAnnotation = arguments.length > 2 ? arguments[2] : undefined;
  return (0, _validateNode["default"])({
    type: "TSTypeAliasDeclaration",
    id: id,
    typeParameters: typeParameters,
    typeAnnotation: typeAnnotation
  });
}

function tsInstantiationExpression(expression) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "TSInstantiationExpression",
    expression: expression,
    typeParameters: typeParameters
  });
}

function tsAsExpression(expression, typeAnnotation) {
  return (0, _validateNode["default"])({
    type: "TSAsExpression",
    expression: expression,
    typeAnnotation: typeAnnotation
  });
}

function tsTypeAssertion(typeAnnotation, expression) {
  return (0, _validateNode["default"])({
    type: "TSTypeAssertion",
    typeAnnotation: typeAnnotation,
    expression: expression
  });
}

function tsEnumDeclaration(id, members) {
  return (0, _validateNode["default"])({
    type: "TSEnumDeclaration",
    id: id,
    members: members
  });
}

function tsEnumMember(id) {
  var initializer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return (0, _validateNode["default"])({
    type: "TSEnumMember",
    id: id,
    initializer: initializer
  });
}

function tsModuleDeclaration(id, body) {
  return (0, _validateNode["default"])({
    type: "TSModuleDeclaration",
    id: id,
    body: body
  });
}

function tsModuleBlock(body) {
  return (0, _validateNode["default"])({
    type: "TSModuleBlock",
    body: body
  });
}

function tsImportType(argument) {
  var qualifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var typeParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (0, _validateNode["default"])({
    type: "TSImportType",
    argument: argument,
    qualifier: qualifier,
    typeParameters: typeParameters
  });
}

function tsImportEqualsDeclaration(id, moduleReference) {
  return (0, _validateNode["default"])({
    type: "TSImportEqualsDeclaration",
    id: id,
    moduleReference: moduleReference,
    isExport: null
  });
}

function tsExternalModuleReference(expression) {
  return (0, _validateNode["default"])({
    type: "TSExternalModuleReference",
    expression: expression
  });
}

function tsNonNullExpression(expression) {
  return (0, _validateNode["default"])({
    type: "TSNonNullExpression",
    expression: expression
  });
}

function tsExportAssignment(expression) {
  return (0, _validateNode["default"])({
    type: "TSExportAssignment",
    expression: expression
  });
}

function tsNamespaceExportDeclaration(id) {
  return (0, _validateNode["default"])({
    type: "TSNamespaceExportDeclaration",
    id: id
  });
}

function tsTypeAnnotation(typeAnnotation) {
  return (0, _validateNode["default"])({
    type: "TSTypeAnnotation",
    typeAnnotation: typeAnnotation
  });
}

function tsTypeParameterInstantiation(params) {
  return (0, _validateNode["default"])({
    type: "TSTypeParameterInstantiation",
    params: params
  });
}

function tsTypeParameterDeclaration(params) {
  return (0, _validateNode["default"])({
    type: "TSTypeParameterDeclaration",
    params: params
  });
}

function tsTypeParameter() {
  var constraint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  var _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var name = arguments.length > 2 ? arguments[2] : undefined;
  return (0, _validateNode["default"])({
    type: "TSTypeParameter",
    constraint: constraint,
    "default": _default,
    name: name
  });
}

function NumberLiteral(value) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  return numericLiteral(value);
}

function RegexLiteral(pattern) {
  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  return regExpLiteral(pattern, flags);
}

function RestProperty(argument) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  return restElement(argument);
}

function SpreadProperty(argument) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  return spreadElement(argument);
}