"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = generateBuilders;

var _index = require("../../lib/index.js");

var _formatBuilderName = _interopRequireDefault(require("../utils/formatBuilderName.js"));

var _lowerFirst = _interopRequireDefault(require("../utils/lowerFirst.js"));

var _stringifyValidator = _interopRequireDefault(require("../utils/stringifyValidator.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function areAllRemainingFieldsNullable(fieldName, fieldNames, fields) {
  var index = fieldNames.indexOf(fieldName);
  return fieldNames.slice(index).every(function (_) {
    return isNullable(fields[_]);
  });
}

function hasDefault(field) {
  return field["default"] != null;
}

function isNullable(field) {
  return field.optional || hasDefault(field);
}

function sortFieldNames(fields, type) {
  return fields.sort(function (fieldA, fieldB) {
    var indexA = _index.BUILDER_KEYS[type].indexOf(fieldA);

    var indexB = _index.BUILDER_KEYS[type].indexOf(fieldB);

    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
}

function generateBuilderArgs(type) {
  var fields = _index.NODE_FIELDS[type];
  var fieldNames = sortFieldNames(Object.keys(_index.NODE_FIELDS[type]), type);
  var builderNames = _index.BUILDER_KEYS[type];
  var args = [];
  fieldNames.forEach(function (fieldName) {
    var field = fields[fieldName]; // Future / annoying TODO:
    // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:
    // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,
    // - declare an alias type for valid keys, detect the case and reuse it here,
    // - declare a disjoint union with, for example, ObjectPropertyBase,
    //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty
    //   as "ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)"

    var typeAnnotation = (0, _stringifyValidator["default"])(field.validate, "t.");

    if (isNullable(field) && !hasDefault(field)) {
      typeAnnotation += " | null";
    }

    if (builderNames.includes(fieldName)) {
      var _field = _index.NODE_FIELDS[type][fieldName];
      var def = JSON.stringify(_field["default"]);
      var bindingIdentifierName = (0, _index.toBindingIdentifierName)(fieldName);
      var arg;

      if (areAllRemainingFieldsNullable(fieldName, builderNames, fields)) {
        arg = "".concat(bindingIdentifierName).concat(isNullable(_field) && !def ? "?:" : ":", " ").concat(typeAnnotation);
      } else {
        arg = "".concat(bindingIdentifierName, ": ").concat(typeAnnotation).concat(isNullable(_field) ? " | undefined" : "");
      }

      if (def !== "null" || isNullable(_field)) {
        arg += "= ".concat(def);
      }

      args.push(arg);
    }
  });
  return args;
}

function generateBuilders(kind) {
  return kind === "uppercase.js" ? generateUppercaseBuilders() : generateLowercaseBuilders();
}

function generateLowercaseBuilders() {
  var output = "/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport validateNode from \"../validateNode\";\nimport type * as t from \"../..\";\n";
  var reservedNames = new Set(["super", "import"]);
  Object.keys(_index.BUILDER_KEYS).forEach(function (type) {
    var defArgs = generateBuilderArgs(type);
    var formatedBuilderName = (0, _formatBuilderName["default"])(type);
    var formatedBuilderNameLocal = reservedNames.has(formatedBuilderName) ? "_".concat(formatedBuilderName) : formatedBuilderName;
    var fieldNames = sortFieldNames(Object.keys(_index.NODE_FIELDS[type]), type);
    var builderNames = _index.BUILDER_KEYS[type];
    var objectFields = [["type", JSON.stringify(type)]];
    fieldNames.forEach(function (fieldName) {
      var field = _index.NODE_FIELDS[type][fieldName];

      if (builderNames.includes(fieldName)) {
        var bindingIdentifierName = (0, _index.toBindingIdentifierName)(fieldName);
        objectFields.push([fieldName, bindingIdentifierName]);
      } else if (!field.optional) {
        var def = JSON.stringify(field["default"]);
        objectFields.push([fieldName, def]);
      }
    });
    output += "".concat(formatedBuilderNameLocal === formatedBuilderName ? "export " : "", "function ").concat(formatedBuilderNameLocal, "(").concat(defArgs.join(", "), "): t.").concat(type, " {");
    var nodeObjectExpression = "{\n".concat(objectFields.map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return k === v ? "    ".concat(k, ",") : "    ".concat(k, ": ").concat(v, ",");
    }).join("\n"), "\n  }");

    if (builderNames.length > 0) {
      output += "\n  return validateNode<t.".concat(type, ">(").concat(nodeObjectExpression, ");");
    } else {
      output += "\n  return ".concat(nodeObjectExpression, ";");
    }

    output += "\n}\n";

    if (formatedBuilderNameLocal !== formatedBuilderName) {
      output += "export { ".concat(formatedBuilderNameLocal, " as ").concat(formatedBuilderName, " };\n");
    } // This is needed for backwards compatibility.
    // It should be removed in the next major version.
    // JSXIdentifier -> jSXIdentifier


    if (/^[A-Z]{2}/.test(type)) {
      output += "export { ".concat(formatedBuilderNameLocal, " as ").concat((0, _lowerFirst["default"])(type), " }\n");
    }
  });
  Object.keys(_index.DEPRECATED_KEYS).forEach(function (type) {
    var newType = _index.DEPRECATED_KEYS[type];
    var formatedBuilderName = (0, _formatBuilderName["default"])(type);
    var formatedNewBuilderName = (0, _formatBuilderName["default"])(newType);
    output += "/** @deprecated */\nfunction ".concat(type, "(").concat(generateBuilderArgs(newType).join(", "), ") {\n  console.trace(\"The node type ").concat(type, " has been renamed to ").concat(newType, "\");\n  return ").concat(formatedNewBuilderName, "(").concat(_index.BUILDER_KEYS[newType].join(", "), ");\n}\nexport { ").concat(type, " as ").concat(formatedBuilderName, " };\n"); // This is needed for backwards compatibility.
    // It should be removed in the next major version.
    // JSXIdentifier -> jSXIdentifier

    if (/^[A-Z]{2}/.test(type)) {
      output += "export { ".concat(type, " as ").concat((0, _lowerFirst["default"])(type), " }\n");
    }
  });
  return output;
}

function generateUppercaseBuilders() {
  var output = "/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\n/**\n * This file is written in JavaScript and not TypeScript because uppercase builders\n * conflict with AST types. TypeScript reads the uppercase.d.ts file instead.\n */\n\n export {\n";
  Object.keys(_index.BUILDER_KEYS).forEach(function (type) {
    var formatedBuilderName = (0, _formatBuilderName["default"])(type);
    output += "  ".concat(formatedBuilderName, " as ").concat(type, ",\n");
  });
  Object.keys(_index.DEPRECATED_KEYS).forEach(function (type) {
    var formatedBuilderName = (0, _formatBuilderName["default"])(type);
    output += "  ".concat(formatedBuilderName, " as ").concat(type, ",\n");
  });
  output += " } from './index';\n";
  return output;
}