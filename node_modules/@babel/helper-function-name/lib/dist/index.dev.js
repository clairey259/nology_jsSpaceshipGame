"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _template = require("@babel/template");

var _t = require("@babel/types");

var NOT_LOCAL_BINDING = _t.NOT_LOCAL_BINDING,
    cloneNode = _t.cloneNode,
    identifier = _t.identifier,
    isAssignmentExpression = _t.isAssignmentExpression,
    isAssignmentPattern = _t.isAssignmentPattern,
    isFunction = _t.isFunction,
    isIdentifier = _t.isIdentifier,
    isLiteral = _t.isLiteral,
    isNullLiteral = _t.isNullLiteral,
    isObjectMethod = _t.isObjectMethod,
    isObjectProperty = _t.isObjectProperty,
    isRegExpLiteral = _t.isRegExpLiteral,
    isRestElement = _t.isRestElement,
    isTemplateLiteral = _t.isTemplateLiteral,
    isVariableDeclarator = _t.isVariableDeclarator,
    toBindingIdentifierName = _t.toBindingIdentifierName;

function getFunctionArity(node) {
  var count = node.params.findIndex(function (param) {
    return isAssignmentPattern(param) || isRestElement(param);
  });
  return count === -1 ? node.params.length : count;
}

var buildPropertyMethodAssignmentWrapper = _template["default"].statement("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");

var buildGeneratorPropertyMethodAssignmentWrapper = _template["default"].statement("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");

var visitor = {
  "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
    if (path.node.name !== state.name) return;
    var localDeclar = path.scope.getBindingIdentifier(state.name);
    if (localDeclar !== state.outerDeclar) return;
    state.selfReference = true;
    path.stop();
  }
};

function getNameFromLiteralId(id) {
  if (isNullLiteral(id)) {
    return "null";
  }

  if (isRegExpLiteral(id)) {
    return "_".concat(id.pattern, "_").concat(id.flags);
  }

  if (isTemplateLiteral(id)) {
    return id.quasis.map(function (quasi) {
      return quasi.value.raw;
    }).join("");
  }

  if (id.value !== undefined) {
    return id.value + "";
  }

  return "";
}

function wrap(state, method, id, scope) {
  if (state.selfReference) {
    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
      scope.rename(id.name);
    } else {
      if (!isFunction(method)) return;
      var build = buildPropertyMethodAssignmentWrapper;

      if (method.generator) {
        build = buildGeneratorPropertyMethodAssignmentWrapper;
      }

      var template = build({
        FUNCTION: method,
        FUNCTION_ID: id,
        FUNCTION_KEY: scope.generateUidIdentifier(id.name)
      }).expression;
      var params = template.callee.body.body[0].params;

      for (var i = 0, len = getFunctionArity(method); i < len; i++) {
        params.push(scope.generateUidIdentifier("x"));
      }

      return template;
    }
  }

  method.id = id;
  scope.getProgramParent().references[id.name] = true;
}

function visit(node, name, scope) {
  var state = {
    selfAssignment: false,
    selfReference: false,
    outerDeclar: scope.getBindingIdentifier(name),
    name: name
  };
  var binding = scope.getOwnBinding(name);

  if (binding) {
    if (binding.kind === "param") {
      state.selfReference = true;
    } else {}
  } else if (state.outerDeclar || scope.hasGlobal(name)) {
    scope.traverse(node, visitor, state);
  }

  return state;
}

function _default(_ref) {
  var node = _ref.node,
      parent = _ref.parent,
      scope = _ref.scope,
      id = _ref.id;
  var localBinding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var supportUnicodeId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (node.id) return;

  if ((isObjectProperty(parent) || isObjectMethod(parent, {
    kind: "method"
  })) && (!parent.computed || isLiteral(parent.key))) {
    id = parent.key;
  } else if (isVariableDeclarator(parent)) {
    id = parent.id;

    if (isIdentifier(id) && !localBinding) {
      var binding = scope.parent.getBinding(id.name);

      if (binding && binding.constant && scope.getBinding(id.name) === binding) {
        node.id = cloneNode(id);
        node.id[NOT_LOCAL_BINDING] = true;
        return;
      }
    }
  } else if (isAssignmentExpression(parent, {
    operator: "="
  })) {
    id = parent.left;
  } else if (!id) {
    return;
  }

  var name;

  if (id && isLiteral(id)) {
    name = getNameFromLiteralId(id);
  } else if (id && isIdentifier(id)) {
    name = id.name;
  }

  if (name === undefined) {
    return;
  }

  if (!supportUnicodeId && isFunction(node) && /[\uD800-\uDFFF]/.test(name)) {
    return;
  }

  name = toBindingIdentifierName(name);
  var newId = identifier(name);
  newId[NOT_LOCAL_BINDING] = true;
  var state = visit(node, name, scope);
  return wrap(state, node, newId, scope) || node;
}