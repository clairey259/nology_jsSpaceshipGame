"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(normalizeFile);

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = normalizeFile;

function _fs() {
  var data = require("fs");

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _path() {
  var data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _debug() {
  var data = require("debug");

  _debug = function _debug() {
    return data;
  };

  return data;
}

function _t() {
  var data = require("@babel/types");

  _t = function _t() {
    return data;
  };

  return data;
}

function _convertSourceMap() {
  var data = require("convert-source-map");

  _convertSourceMap = function _convertSourceMap() {
    return data;
  };

  return data;
}

var _file = require("./file/file");

var _parser = require("../parser");

var _cloneDeep = require("./util/clone-deep");

var _t2 = _t(),
    file = _t2.file,
    traverseFast = _t2.traverseFast;

var debug = _debug()("babel:transform:file");

var LARGE_INPUT_SOURCEMAP_THRESHOLD = 3000000;

function normalizeFile(pluginPasses, options, code, ast) {
  var inputMap, lastComment, _lastComment, match, inputMapContent;

  return regeneratorRuntime.wrap(function normalizeFile$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          code = "".concat(code || "");

          if (!ast) {
            _context.next = 11;
            break;
          }

          if (!(ast.type === "Program")) {
            _context.next = 6;
            break;
          }

          ast = file(ast, [], []);
          _context.next = 8;
          break;

        case 6:
          if (!(ast.type !== "File")) {
            _context.next = 8;
            break;
          }

          throw new Error("AST root must be a Program or File node");

        case 8:
          if (options.cloneInputAst) {
            ast = (0, _cloneDeep["default"])(ast);
          }

          _context.next = 13;
          break;

        case 11:
          return _context.delegateYield((0, _parser["default"])(pluginPasses, options, code), "t0", 12);

        case 12:
          ast = _context.t0;

        case 13:
          inputMap = null;

          if (options.inputSourceMap !== false) {
            if (_typeof(options.inputSourceMap) === "object") {
              inputMap = _convertSourceMap().fromObject(options.inputSourceMap);
            }

            if (!inputMap) {
              lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);

              if (lastComment) {
                try {
                  inputMap = _convertSourceMap().fromComment(lastComment);
                } catch (err) {
                  debug("discarding unknown inline input sourcemap", err);
                }
              }
            }

            if (!inputMap) {
              _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);

              if (typeof options.filename === "string" && _lastComment) {
                try {
                  match = EXTERNAL_SOURCEMAP_REGEX.exec(_lastComment);
                  inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]));

                  if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {
                    debug("skip merging input map > 1 MB");
                  } else {
                    inputMap = _convertSourceMap().fromJSON(inputMapContent);
                  }
                } catch (err) {
                  debug("discarding unknown file input sourcemap", err);
                }
              } else if (_lastComment) {
                debug("discarding un-loadable file input sourcemap");
              }
            }
          }

          return _context.abrupt("return", new _file["default"](options, {
            code: code,
            ast: ast,
            inputMap: inputMap
          }));

        case 16:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

var INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
var EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;

function extractCommentsFromList(regex, comments, lastComment) {
  if (comments) {
    comments = comments.filter(function (_ref) {
      var value = _ref.value;

      if (regex.test(value)) {
        lastComment = value;
        return false;
      }

      return true;
    });
  }

  return [comments, lastComment];
}

function extractComments(regex, ast) {
  var lastComment = null;
  traverseFast(ast, function (node) {
    var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);

    var _extractCommentsFromL2 = _slicedToArray(_extractCommentsFromL, 2);

    node.leadingComments = _extractCommentsFromL2[0];
    lastComment = _extractCommentsFromL2[1];

    var _extractCommentsFromL3 = extractCommentsFromList(regex, node.innerComments, lastComment);

    var _extractCommentsFromL4 = _slicedToArray(_extractCommentsFromL3, 2);

    node.innerComments = _extractCommentsFromL4[0];
    lastComment = _extractCommentsFromL4[1];

    var _extractCommentsFromL5 = extractCommentsFromList(regex, node.trailingComments, lastComment);

    var _extractCommentsFromL6 = _slicedToArray(_extractCommentsFromL5, 2);

    node.trailingComments = _extractCommentsFromL6[0];
    lastComment = _extractCommentsFromL6[1];
  });
  return lastComment;
}

0 && 0;