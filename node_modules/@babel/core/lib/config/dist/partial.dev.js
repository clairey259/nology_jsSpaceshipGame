"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(loadPrivatePartialConfig);

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = loadPrivatePartialConfig;
exports.loadPartialConfig = void 0;

function _path() {
  var data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _gensync() {
  var data = require("gensync");

  _gensync = function _gensync() {
    return data;
  };

  return data;
}

var _plugin = require("./plugin");

var _util = require("./util");

var _item = require("./item");

var _configChain = require("./config-chain");

var _environment = require("./helpers/environment");

var _options = require("./validation/options");

var _files = require("./files");

var _resolveTargets = require("./resolve-targets");

var _excluded = ["showIgnoredFiles"];

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function resolveRootMode(rootDir, rootMode) {
  switch (rootMode) {
    case "root":
      return rootDir;

    case "upward-optional":
      {
        var upwardRootDir = (0, _files.findConfigUpwards)(rootDir);
        return upwardRootDir === null ? rootDir : upwardRootDir;
      }

    case "upward":
      {
        var _upwardRootDir = (0, _files.findConfigUpwards)(rootDir);

        if (_upwardRootDir !== null) return _upwardRootDir;
        throw Object.assign(new Error("Babel was run with rootMode:\"upward\" but a root could not " + "be found when searching upward from \"".concat(rootDir, "\".\n") + "One of the following config files must be in the directory tree: " + "\"".concat(_files.ROOT_CONFIG_FILENAMES.join(", "), "\".")), {
          code: "BABEL_ROOT_NOT_FOUND",
          dirname: rootDir
        });
      }

    default:
      throw new Error("Assertion failure - unknown rootMode value.");
  }
}

function loadPrivatePartialConfig(inputOpts) {
  var args, _args$envName, envName, _args$cwd, cwd, _args$root, rootDir, _args$rootMode, rootMode, caller, _args$cloneInputAst, cloneInputAst, absoluteCwd, absoluteRootDir, filename, showConfigPath, context, configChain, merged, options;

  return regeneratorRuntime.wrap(function loadPrivatePartialConfig$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(inputOpts != null && (_typeof(inputOpts) !== "object" || Array.isArray(inputOpts)))) {
            _context.next = 2;
            break;
          }

          throw new Error("Babel options must be an object, null, or undefined");

        case 2:
          args = inputOpts ? (0, _options.validate)("arguments", inputOpts) : {};
          _args$envName = args.envName, envName = _args$envName === void 0 ? (0, _environment.getEnv)() : _args$envName, _args$cwd = args.cwd, cwd = _args$cwd === void 0 ? "." : _args$cwd, _args$root = args.root, rootDir = _args$root === void 0 ? "." : _args$root, _args$rootMode = args.rootMode, rootMode = _args$rootMode === void 0 ? "root" : _args$rootMode, caller = args.caller, _args$cloneInputAst = args.cloneInputAst, cloneInputAst = _args$cloneInputAst === void 0 ? true : _args$cloneInputAst;
          absoluteCwd = _path().resolve(cwd);
          absoluteRootDir = resolveRootMode(_path().resolve(absoluteCwd, rootDir), rootMode);
          filename = typeof args.filename === "string" ? _path().resolve(cwd, args.filename) : undefined;
          return _context.delegateYield((0, _files.resolveShowConfigPath)(absoluteCwd), "t0", 8);

        case 8:
          showConfigPath = _context.t0;
          context = {
            filename: filename,
            cwd: absoluteCwd,
            root: absoluteRootDir,
            envName: envName,
            caller: caller,
            showConfig: showConfigPath === filename
          };
          return _context.delegateYield((0, _configChain.buildRootChain)(args, context), "t1", 11);

        case 11:
          configChain = _context.t1;

          if (configChain) {
            _context.next = 14;
            break;
          }

          return _context.abrupt("return", null);

        case 14:
          merged = {
            assumptions: {}
          };
          configChain.options.forEach(function (opts) {
            (0, _util.mergeOptions)(merged, opts);
          });
          options = Object.assign({}, merged, {
            targets: (0, _resolveTargets.resolveTargets)(merged, absoluteRootDir),
            cloneInputAst: cloneInputAst,
            babelrc: false,
            configFile: false,
            browserslistConfigFile: false,
            passPerPreset: false,
            envName: context.envName,
            cwd: context.cwd,
            root: context.root,
            rootMode: "root",
            filename: typeof context.filename === "string" ? context.filename : undefined,
            plugins: configChain.plugins.map(function (descriptor) {
              return (0, _item.createItemFromDescriptor)(descriptor);
            }),
            presets: configChain.presets.map(function (descriptor) {
              return (0, _item.createItemFromDescriptor)(descriptor);
            })
          });
          return _context.abrupt("return", {
            options: options,
            context: context,
            fileHandling: configChain.fileHandling,
            ignore: configChain.ignore,
            babelrc: configChain.babelrc,
            config: configChain.config,
            files: configChain.files
          });

        case 18:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

var loadPartialConfig = _gensync()(
/*#__PURE__*/
regeneratorRuntime.mark(function _callee(opts) {
  var showIgnoredFiles, _opts, result, options, babelrc, ignore, config, fileHandling, files;

  return regeneratorRuntime.wrap(function _callee$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          showIgnoredFiles = false;

          if (_typeof(opts) === "object" && opts !== null && !Array.isArray(opts)) {
            _opts = opts;
            showIgnoredFiles = _opts.showIgnoredFiles;
            opts = _objectWithoutPropertiesLoose(_opts, _excluded);
            _opts;
          }

          return _context2.delegateYield(loadPrivatePartialConfig(opts), "t0", 3);

        case 3:
          result = _context2.t0;

          if (result) {
            _context2.next = 6;
            break;
          }

          return _context2.abrupt("return", null);

        case 6:
          options = result.options, babelrc = result.babelrc, ignore = result.ignore, config = result.config, fileHandling = result.fileHandling, files = result.files;

          if (!(fileHandling === "ignored" && !showIgnoredFiles)) {
            _context2.next = 9;
            break;
          }

          return _context2.abrupt("return", null);

        case 9:
          (options.plugins || []).forEach(function (item) {
            if (item.value instanceof _plugin["default"]) {
              throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
            }
          });
          return _context2.abrupt("return", new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined, fileHandling, files));

        case 11:
        case "end":
          return _context2.stop();
      }
    }
  }, _callee);
}));

exports.loadPartialConfig = loadPartialConfig;

var PartialConfig =
/*#__PURE__*/
function () {
  function PartialConfig(options, babelrc, ignore, config, fileHandling, files) {
    _classCallCheck(this, PartialConfig);

    this.options = void 0;
    this.babelrc = void 0;
    this.babelignore = void 0;
    this.config = void 0;
    this.fileHandling = void 0;
    this.files = void 0;
    this.options = options;
    this.babelignore = ignore;
    this.babelrc = babelrc;
    this.config = config;
    this.fileHandling = fileHandling;
    this.files = files;
    Object.freeze(this);
  }

  _createClass(PartialConfig, [{
    key: "hasFilesystemConfig",
    value: function hasFilesystemConfig() {
      return this.babelrc !== undefined || this.config !== undefined;
    }
  }]);

  return PartialConfig;
}();

Object.freeze(PartialConfig.prototype);
0 && 0;