"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.moduleResolve = moduleResolve;
exports.resolve = resolve;

function _url() {
  var data = require("url");

  _url = function _url() {
    return data;
  };

  return data;
}

function _fs() {
  var data = _interopRequireWildcard(require("fs"), true);

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _path() {
  var data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _assert() {
  var data = require("assert");

  _assert = function _assert() {
    return data;
  };

  return data;
}

function _util() {
  var data = require("util");

  _util = function _util() {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var re$3 = {
  exports: {}
};
var SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH$2 = 256;
var MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
var MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH
};
var debug$1 = (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () {
  var _console;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
} : function () {};
var debug_1 = debug$1;

(function (module, exports) {
  var MAX_SAFE_COMPONENT_LENGTH = constants.MAX_SAFE_COMPONENT_LENGTH;
  var debug = debug_1;
  exports = module.exports = {};
  var re = exports.re = [];
  var src = exports.src = [];
  var t = exports.t = {};
  var R = 0;

  var createToken = function createToken(name, value, isGlobal) {
    var index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
  };

  createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
  createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');
  createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');
  createToken('MAINVERSION', "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")"));
  createToken('MAINVERSIONLOOSE', "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")"));
  createToken('PRERELEASEIDENTIFIER', "(?:".concat(src[t.NUMERICIDENTIFIER], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
  createToken('PRERELEASEIDENTIFIERLOOSE', "(?:".concat(src[t.NUMERICIDENTIFIERLOOSE], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
  createToken('PRERELEASE', "(?:-(".concat(src[t.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIER], ")*))"));
  createToken('PRERELEASELOOSE', "(?:-?(".concat(src[t.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIERLOOSE], ")*))"));
  createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');
  createToken('BUILD', "(?:\\+(".concat(src[t.BUILDIDENTIFIER], "(?:\\.").concat(src[t.BUILDIDENTIFIER], ")*))"));
  createToken('FULLPLAIN', "v?".concat(src[t.MAINVERSION]).concat(src[t.PRERELEASE], "?").concat(src[t.BUILD], "?"));
  createToken('FULL', "^".concat(src[t.FULLPLAIN], "$"));
  createToken('LOOSEPLAIN', "[v=\\s]*".concat(src[t.MAINVERSIONLOOSE]).concat(src[t.PRERELEASELOOSE], "?").concat(src[t.BUILD], "?"));
  createToken('LOOSE', "^".concat(src[t.LOOSEPLAIN], "$"));
  createToken('GTLT', '((?:<|>)?=?)');
  createToken('XRANGEIDENTIFIERLOOSE', "".concat(src[t.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
  createToken('XRANGEIDENTIFIER', "".concat(src[t.NUMERICIDENTIFIER], "|x|X|\\*"));
  createToken('XRANGEPLAIN', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:".concat(src[t.PRERELEASE], ")?").concat(src[t.BUILD], "?") + ")?)?");
  createToken('XRANGEPLAINLOOSE', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(src[t.PRERELEASELOOSE], ")?").concat(src[t.BUILD], "?") + ")?)?");
  createToken('XRANGE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAIN], "$"));
  createToken('XRANGELOOSE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAINLOOSE], "$"));
  createToken('COERCE', "".concat('(^|[^\\d])' + '(\\d{1,').concat(MAX_SAFE_COMPONENT_LENGTH, "})") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:$|[^\\d])");
  createToken('COERCERTL', src[t.COERCE], true);
  createToken('LONETILDE', '(?:~>?)');
  createToken('TILDETRIM', "(\\s*)".concat(src[t.LONETILDE], "\\s+"), true);
  exports.tildeTrimReplace = '$1~';
  createToken('TILDE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAIN], "$"));
  createToken('TILDELOOSE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAINLOOSE], "$"));
  createToken('LONECARET', '(?:\\^)');
  createToken('CARETTRIM', "(\\s*)".concat(src[t.LONECARET], "\\s+"), true);
  exports.caretTrimReplace = '$1^';
  createToken('CARET', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAIN], "$"));
  createToken('CARETLOOSE', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAINLOOSE], "$"));
  createToken('COMPARATORLOOSE', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], ")$|^$"));
  createToken('COMPARATOR', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.FULLPLAIN], ")$|^$"));
  createToken('COMPARATORTRIM', "(\\s*)".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], "|").concat(src[t.XRANGEPLAIN], ")"), true);
  exports.comparatorTrimReplace = '$1$2$3';
  createToken('HYPHENRANGE', "^\\s*(".concat(src[t.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAIN], ")") + "\\s*$");
  createToken('HYPHENRANGELOOSE', "^\\s*(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s*$");
  createToken('STAR', '(<|>)?=?\\s*\\*');
  createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
  createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
})(re$3, re$3.exports);

var opts = ['includePrerelease', 'loose', 'rtl'];

var parseOptions$2 = function parseOptions$2(options) {
  return !options ? {} : _typeof(options) !== 'object' ? {
    loose: true
  } : opts.filter(function (k) {
    return options[k];
  }).reduce(function (o, k) {
    o[k] = true;
    return o;
  }, {});
};

var parseOptions_1 = parseOptions$2;
var numeric = /^[0-9]+$/;

var compareIdentifiers$1 = function compareIdentifiers$1(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};

var rcompareIdentifiers = function rcompareIdentifiers(a, b) {
  return compareIdentifiers$1(b, a);
};

var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers: rcompareIdentifiers
};
var debug = debug_1;
var MAX_LENGTH$1 = constants.MAX_LENGTH,
    MAX_SAFE_INTEGER = constants.MAX_SAFE_INTEGER;
var _re$3$exports = re$3.exports,
    re$2 = _re$3$exports.re,
    t$2 = _re$3$exports.t;
var parseOptions$1 = parseOptions_1;
var compareIdentifiers = identifiers.compareIdentifiers;

var SemVer$c =
/*#__PURE__*/
function () {
  function SemVer$c(version, options) {
    _classCallCheck(this, SemVer$c);

    options = parseOptions$1(options);

    if (version instanceof SemVer$c) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError("Invalid Version: ".concat(version));
    }

    if (version.length > MAX_LENGTH$1) {
      throw new TypeError("version is longer than ".concat(MAX_LENGTH$1, " characters"));
    }

    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    var m = version.trim().match(options.loose ? re$2[t$2.LOOSE] : re$2[t$2.FULL]);

    if (!m) {
      throw new TypeError("Invalid Version: ".concat(version));
    }

    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    }

    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;

          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }

        return id;
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  _createClass(SemVer$c, [{
    key: "format",
    value: function format() {
      this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);

      if (this.prerelease.length) {
        this.version += "-".concat(this.prerelease.join('.'));
      }

      return this.version;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.version;
    }
  }, {
    key: "compare",
    value: function compare(other) {
      debug('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer$c)) {
        if (typeof other === 'string' && other === this.version) {
          return 0;
        }

        other = new SemVer$c(other, this.options);
      }

      if (other.version === this.version) {
        return 0;
      }

      return this.compareMain(other) || this.comparePre(other);
    }
  }, {
    key: "compareMain",
    value: function compareMain(other) {
      if (!(other instanceof SemVer$c)) {
        other = new SemVer$c(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
  }, {
    key: "comparePre",
    value: function comparePre(other) {
      if (!(other instanceof SemVer$c)) {
        other = new SemVer$c(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
  }, {
    key: "compareBuild",
    value: function compareBuild(other) {
      if (!(other instanceof SemVer$c)) {
        other = new SemVer$c(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
  }, {
    key: "inc",
    value: function inc(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error("invalid increment argument: ".concat(release));
      }

      this.format();
      this.raw = this.version;
      return this;
    }
  }]);

  return SemVer$c;
}();

var semver$2 = SemVer$c;
var MAX_LENGTH = constants.MAX_LENGTH;
var _re$3$exports2 = re$3.exports,
    re$1 = _re$3$exports2.re,
    t$1 = _re$3$exports2.t;
var SemVer$b = semver$2;
var parseOptions = parseOptions_1;

var parse$5 = function parse$5(version, options) {
  options = parseOptions(options);

  if (version instanceof SemVer$b) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  if (version.length > MAX_LENGTH) {
    return null;
  }

  var r = options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL];

  if (!r.test(version)) {
    return null;
  }

  try {
    return new SemVer$b(version, options);
  } catch (er) {
    return null;
  }
};

var parse_1 = parse$5;
var parse$4 = parse_1;

var valid$1 = function valid$1(version, options) {
  var v = parse$4(version, options);
  return v ? v.version : null;
};

var valid_1 = valid$1;
var parse$3 = parse_1;

var clean = function clean(version, options) {
  var s = parse$3(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
};

var clean_1 = clean;
var SemVer$a = semver$2;

var inc = function inc(version, release, options, identifier) {
  if (typeof options === 'string') {
    identifier = options;
    options = undefined;
  }

  try {
    return new SemVer$a(version instanceof SemVer$a ? version.version : version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};

var inc_1 = inc;
var SemVer$9 = semver$2;

var compare$a = function compare$a(a, b, loose) {
  return new SemVer$9(a, loose).compare(new SemVer$9(b, loose));
};

var compare_1 = compare$a;
var compare$9 = compare_1;

var eq$2 = function eq$2(a, b, loose) {
  return compare$9(a, b, loose) === 0;
};

var eq_1 = eq$2;
var parse$2 = parse_1;
var eq$1 = eq_1;

var diff = function diff(version1, version2) {
  if (eq$1(version1, version2)) {
    return null;
  } else {
    var v1 = parse$2(version1);
    var v2 = parse$2(version2);
    var hasPre = v1.prerelease.length || v2.prerelease.length;
    var prefix = hasPre ? 'pre' : '';
    var defaultResult = hasPre ? 'prerelease' : '';

    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }

    return defaultResult;
  }
};

var diff_1 = diff;
var SemVer$8 = semver$2;

var major = function major(a, loose) {
  return new SemVer$8(a, loose).major;
};

var major_1 = major;
var SemVer$7 = semver$2;

var minor = function minor(a, loose) {
  return new SemVer$7(a, loose).minor;
};

var minor_1 = minor;
var SemVer$6 = semver$2;

var patch = function patch(a, loose) {
  return new SemVer$6(a, loose).patch;
};

var patch_1 = patch;
var parse$1 = parse_1;

var prerelease = function prerelease(version, options) {
  var parsed = parse$1(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};

var prerelease_1 = prerelease;
var compare$8 = compare_1;

var rcompare = function rcompare(a, b, loose) {
  return compare$8(b, a, loose);
};

var rcompare_1 = rcompare;
var compare$7 = compare_1;

var compareLoose = function compareLoose(a, b) {
  return compare$7(a, b, true);
};

var compareLoose_1 = compareLoose;
var SemVer$5 = semver$2;

var compareBuild$2 = function compareBuild$2(a, b, loose) {
  var versionA = new SemVer$5(a, loose);
  var versionB = new SemVer$5(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};

var compareBuild_1 = compareBuild$2;
var compareBuild$1 = compareBuild_1;

var sort = function sort(list, loose) {
  return list.sort(function (a, b) {
    return compareBuild$1(a, b, loose);
  });
};

var sort_1 = sort;
var compareBuild = compareBuild_1;

var rsort = function rsort(list, loose) {
  return list.sort(function (a, b) {
    return compareBuild(b, a, loose);
  });
};

var rsort_1 = rsort;
var compare$6 = compare_1;

var gt$3 = function gt$3(a, b, loose) {
  return compare$6(a, b, loose) > 0;
};

var gt_1 = gt$3;
var compare$5 = compare_1;

var lt$2 = function lt$2(a, b, loose) {
  return compare$5(a, b, loose) < 0;
};

var lt_1 = lt$2;
var compare$4 = compare_1;

var neq$1 = function neq$1(a, b, loose) {
  return compare$4(a, b, loose) !== 0;
};

var neq_1 = neq$1;
var compare$3 = compare_1;

var gte$2 = function gte$2(a, b, loose) {
  return compare$3(a, b, loose) >= 0;
};

var gte_1 = gte$2;
var compare$2 = compare_1;

var lte$2 = function lte$2(a, b, loose) {
  return compare$2(a, b, loose) <= 0;
};

var lte_1 = lte$2;
var eq = eq_1;
var neq = neq_1;
var gt$2 = gt_1;
var gte$1 = gte_1;
var lt$1 = lt_1;
var lte$1 = lte_1;

var cmp = function cmp(a, op, b, loose) {
  switch (op) {
    case '===':
      if (_typeof(a) === 'object') {
        a = a.version;
      }

      if (_typeof(b) === 'object') {
        b = b.version;
      }

      return a === b;

    case '!==':
      if (_typeof(a) === 'object') {
        a = a.version;
      }

      if (_typeof(b) === 'object') {
        b = b.version;
      }

      return a !== b;

    case '':
    case '=':
    case '==':
      return eq(a, b, loose);

    case '!=':
      return neq(a, b, loose);

    case '>':
      return gt$2(a, b, loose);

    case '>=':
      return gte$1(a, b, loose);

    case '<':
      return lt$1(a, b, loose);

    case '<=':
      return lte$1(a, b, loose);

    default:
      throw new TypeError("Invalid operator: ".concat(op));
  }
};

var cmp_1 = cmp;
var SemVer$4 = semver$2;
var parse = parse_1;
var _re$3$exports3 = re$3.exports,
    re = _re$3$exports3.re,
    t = _re$3$exports3.t;

var coerce = function coerce(version, options) {
  if (version instanceof SemVer$4) {
    return version;
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null;
  }

  options = options || {};
  var match = null;

  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    var next;

    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }

      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }

    re[t.COERCERTL].lastIndex = -1;
  }

  if (match === null) {
    return null;
  }

  return parse("".concat(match[2], ".").concat(match[3] || '0', ".").concat(match[4] || '0'), options);
};

var coerce_1 = coerce;
var iterator;
var hasRequiredIterator;

function requireIterator() {
  if (hasRequiredIterator) return iterator;
  hasRequiredIterator = 1;

  iterator = function iterator(Yallist) {
    Yallist.prototype[Symbol.iterator] =
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee() {
      var walker;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              walker = this.head;

            case 1:
              if (!walker) {
                _context.next = 7;
                break;
              }

              _context.next = 4;
              return walker.value;

            case 4:
              walker = walker.next;
              _context.next = 1;
              break;

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    });
  };

  return iterator;
}

var yallist;
var hasRequiredYallist;

function requireYallist() {
  if (hasRequiredYallist) return yallist;
  hasRequiredYallist = 1;
  yallist = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;

  function Yallist(list) {
    var self = this;

    if (!(self instanceof Yallist)) {
      self = new Yallist();
    }

    self.tail = null;
    self.head = null;
    self.length = 0;

    if (list && typeof list.forEach === 'function') {
      list.forEach(function (item) {
        self.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self.push(arguments[i]);
      }
    }

    return self;
  }

  Yallist.prototype.removeNode = function (node) {
    if (node.list !== this) {
      throw new Error('removing node which does not belong to this list');
    }

    var next = node.next;
    var prev = node.prev;

    if (next) {
      next.prev = prev;
    }

    if (prev) {
      prev.next = next;
    }

    if (node === this.head) {
      this.head = next;
    }

    if (node === this.tail) {
      this.tail = prev;
    }

    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };

  Yallist.prototype.unshiftNode = function (node) {
    if (node === this.head) {
      return;
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    var head = this.head;
    node.list = this;
    node.next = head;

    if (head) {
      head.prev = node;
    }

    this.head = node;

    if (!this.tail) {
      this.tail = node;
    }

    this.length++;
  };

  Yallist.prototype.pushNode = function (node) {
    if (node === this.tail) {
      return;
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    var tail = this.tail;
    node.list = this;
    node.prev = tail;

    if (tail) {
      tail.next = node;
    }

    this.tail = node;

    if (!this.head) {
      this.head = node;
    }

    this.length++;
  };

  Yallist.prototype.push = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }

    return this.length;
  };

  Yallist.prototype.unshift = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }

    return this.length;
  };

  Yallist.prototype.pop = function () {
    if (!this.tail) {
      return undefined;
    }

    var res = this.tail.value;
    this.tail = this.tail.prev;

    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }

    this.length--;
    return res;
  };

  Yallist.prototype.shift = function () {
    if (!this.head) {
      return undefined;
    }

    var res = this.head.value;
    this.head = this.head.next;

    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }

    this.length--;
    return res;
  };

  Yallist.prototype.forEach = function (fn, thisp) {
    thisp = thisp || this;

    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };

  Yallist.prototype.forEachReverse = function (fn, thisp) {
    thisp = thisp || this;

    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };

  Yallist.prototype.get = function (n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }

    if (i === n && walker !== null) {
      return walker.value;
    }
  };

  Yallist.prototype.getReverse = function (n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }

    if (i === n && walker !== null) {
      return walker.value;
    }
  };

  Yallist.prototype.map = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();

    for (var walker = this.head; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }

    return res;
  };

  Yallist.prototype.mapReverse = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();

    for (var walker = this.tail; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }

    return res;
  };

  Yallist.prototype.reduce = function (fn, initial) {
    var acc;
    var walker = this.head;

    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value');
    }

    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }

    return acc;
  };

  Yallist.prototype.reduceReverse = function (fn, initial) {
    var acc;
    var walker = this.tail;

    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value');
    }

    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }

    return acc;
  };

  Yallist.prototype.toArray = function () {
    var arr = new Array(this.length);

    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }

    return arr;
  };

  Yallist.prototype.toArrayReverse = function () {
    var arr = new Array(this.length);

    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }

    return arr;
  };

  Yallist.prototype.slice = function (from, to) {
    to = to || this.length;

    if (to < 0) {
      to += this.length;
    }

    from = from || 0;

    if (from < 0) {
      from += this.length;
    }

    var ret = new Yallist();

    if (to < from || to < 0) {
      return ret;
    }

    if (from < 0) {
      from = 0;
    }

    if (to > this.length) {
      to = this.length;
    }

    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }

    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }

    return ret;
  };

  Yallist.prototype.sliceReverse = function (from, to) {
    to = to || this.length;

    if (to < 0) {
      to += this.length;
    }

    from = from || 0;

    if (from < 0) {
      from += this.length;
    }

    var ret = new Yallist();

    if (to < from || to < 0) {
      return ret;
    }

    if (from < 0) {
      from = 0;
    }

    if (to > this.length) {
      to = this.length;
    }

    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }

    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }

    return ret;
  };

  Yallist.prototype.splice = function (start, deleteCount) {
    if (start > this.length) {
      start = this.length - 1;
    }

    if (start < 0) {
      start = this.length + start;
    }

    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }

    var ret = [];

    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }

    if (walker === null) {
      walker = this.tail;
    }

    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }

    for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
      walker = insert(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);
    }

    return ret;
  };

  Yallist.prototype.reverse = function () {
    var head = this.head;
    var tail = this.tail;

    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }

    this.head = tail;
    this.tail = head;
    return this;
  };

  function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

    if (inserted.next === null) {
      self.tail = inserted;
    }

    if (inserted.prev === null) {
      self.head = inserted;
    }

    self.length++;
    return inserted;
  }

  function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);

    if (!self.head) {
      self.head = self.tail;
    }

    self.length++;
  }

  function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);

    if (!self.tail) {
      self.tail = self.head;
    }

    self.length++;
  }

  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }

    this.list = list;
    this.value = value;

    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }

    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }

  try {
    requireIterator()(Yallist);
  } catch (er) {}

  return yallist;
}

var lruCache;
var hasRequiredLruCache;

function requireLruCache() {
  if (hasRequiredLruCache) return lruCache;
  hasRequiredLruCache = 1;
  var Yallist = requireYallist();
  var MAX = Symbol('max');
  var LENGTH = Symbol('length');
  var LENGTH_CALCULATOR = Symbol('lengthCalculator');
  var ALLOW_STALE = Symbol('allowStale');
  var MAX_AGE = Symbol('maxAge');
  var DISPOSE = Symbol('dispose');
  var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
  var LRU_LIST = Symbol('lruList');
  var CACHE = Symbol('cache');
  var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

  var naiveLength = function naiveLength() {
    return 1;
  };

  var LRUCache =
  /*#__PURE__*/
  function () {
    function LRUCache(options) {
      _classCallCheck(this, LRUCache);

      if (typeof options === 'number') options = {
        max: options
      };
      if (!options) options = {};
      if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number');
      this[MAX] = options.max || Infinity;
      var lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }

    _createClass(LRUCache, [{
      key: "rforEach",
      value: function rforEach(fn, thisp) {
        thisp = thisp || this;

        for (var walker = this[LRU_LIST].tail; walker !== null;) {
          var prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
    }, {
      key: "forEach",
      value: function forEach(fn, thisp) {
        thisp = thisp || this;

        for (var walker = this[LRU_LIST].head; walker !== null;) {
          var next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
    }, {
      key: "keys",
      value: function keys() {
        return this[LRU_LIST].toArray().map(function (k) {
          return k.key;
        });
      }
    }, {
      key: "values",
      value: function values() {
        return this[LRU_LIST].toArray().map(function (k) {
          return k.value;
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        var _this = this;

        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach(function (hit) {
            return _this[DISPOSE](hit.key, hit.value);
          });
        }

        this[CACHE] = new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
    }, {
      key: "dump",
      value: function dump() {
        var _this2 = this;

        return this[LRU_LIST].map(function (hit) {
          return isStale(_this2, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          };
        }).toArray().filter(function (h) {
          return h;
        });
      }
    }, {
      key: "dumpLru",
      value: function dumpLru() {
        return this[LRU_LIST];
      }
    }, {
      key: "set",
      value: function set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
        var now = maxAge ? Date.now() : 0;
        var len = this[LENGTH_CALCULATOR](value, key);

        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            _del(this, this[CACHE].get(key));

            return false;
          }

          var node = this[CACHE].get(key);
          var item = node.value;

          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
          }

          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }

        var hit = new Entry(key, value, len, now, maxAge);

        if (hit.length > this[MAX]) {
          if (this[DISPOSE]) this[DISPOSE](key, value);
          return false;
        }

        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
    }, {
      key: "has",
      value: function has(key) {
        if (!this[CACHE].has(key)) return false;
        var hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
    }, {
      key: "get",
      value: function get(key) {
        return _get(this, key, true);
      }
    }, {
      key: "peek",
      value: function peek(key) {
        return _get(this, key, false);
      }
    }, {
      key: "pop",
      value: function pop() {
        var node = this[LRU_LIST].tail;
        if (!node) return null;

        _del(this, node);

        return node.value;
      }
    }, {
      key: "del",
      value: function del(key) {
        _del(this, this[CACHE].get(key));
      }
    }, {
      key: "load",
      value: function load(arr) {
        this.reset();
        var now = Date.now();

        for (var l = arr.length - 1; l >= 0; l--) {
          var hit = arr[l];
          var expiresAt = hit.e || 0;
          if (expiresAt === 0) this.set(hit.k, hit.v);else {
            var maxAge = expiresAt - now;

            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
    }, {
      key: "prune",
      value: function prune() {
        var _this3 = this;

        this[CACHE].forEach(function (value, key) {
          return _get(_this3, key, false);
        });
      }
    }, {
      key: "max",
      set: function set(mL) {
        if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
        this[MAX] = mL || Infinity;
        trim(this);
      },
      get: function get() {
        return this[MAX];
      }
    }, {
      key: "allowStale",
      set: function set(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      },
      get: function get() {
        return this[ALLOW_STALE];
      }
    }, {
      key: "maxAge",
      set: function set(mA) {
        if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
        this[MAX_AGE] = mA;
        trim(this);
      },
      get: function get() {
        return this[MAX_AGE];
      }
    }, {
      key: "lengthCalculator",
      set: function set(lC) {
        var _this4 = this;

        if (typeof lC !== 'function') lC = naiveLength;

        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach(function (hit) {
            hit.length = _this4[LENGTH_CALCULATOR](hit.value, hit.key);
            _this4[LENGTH] += hit.length;
          });
        }

        trim(this);
      },
      get: function get() {
        return this[LENGTH_CALCULATOR];
      }
    }, {
      key: "length",
      get: function get() {
        return this[LENGTH];
      }
    }, {
      key: "itemCount",
      get: function get() {
        return this[LRU_LIST].length;
      }
    }]);

    return LRUCache;
  }();

  var _get = function _get(self, key, doUse) {
    var node = self[CACHE].get(key);

    if (node) {
      var hit = node.value;

      if (isStale(self, hit)) {
        _del(self, node);

        if (!self[ALLOW_STALE]) return undefined;
      } else {
        if (doUse) {
          if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
          self[LRU_LIST].unshiftNode(node);
        }
      }

      return hit.value;
    }
  };

  var isStale = function isStale(self, hit) {
    if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
    var diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
  };

  var trim = function trim(self) {
    if (self[LENGTH] > self[MAX]) {
      for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
        var prev = walker.prev;

        _del(self, walker);

        walker = prev;
      }
    }
  };

  var _del = function _del(self, node) {
    if (node) {
      var hit = node.value;
      if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
      self[LENGTH] -= hit.length;
      self[CACHE]["delete"](hit.key);
      self[LRU_LIST].removeNode(node);
    }
  };

  var Entry = function Entry(key, value, length, now, maxAge) {
    _classCallCheck(this, Entry);

    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  };

  var forEachStep = function forEachStep(self, fn, node, thisp) {
    var hit = node.value;

    if (isStale(self, hit)) {
      _del(self, node);

      if (!self[ALLOW_STALE]) hit = undefined;
    }

    if (hit) fn.call(thisp, hit.value, hit.key, self);
  };

  lruCache = LRUCache;
  return lruCache;
}

var range;
var hasRequiredRange;

function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;

  var Range =
  /*#__PURE__*/
  function () {
    function Range(range, options) {
      var _this5 = this;

      _classCallCheck(this, Range);

      options = parseOptions(options);

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split('||').map(function (r) {
        return _this5.parseRange(r.trim());
      }).filter(function (c) {
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: ".concat(range));
      }

      if (this.set.length > 1) {
        var first = this.set[0];
        this.set = this.set.filter(function (c) {
          return !isNullSet(c[0]);
        });

        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var c = _step.value;

              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }

      this.format();
    }

    _createClass(Range, [{
      key: "format",
      value: function format() {
        this.range = this.set.map(function (comps) {
          return comps.join(' ').trim();
        }).join('||').trim();
        return this.range;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.range;
      }
    }, {
      key: "parseRange",
      value: function parseRange(range) {
        var _this6 = this;

        range = range.trim();
        var memoOpts = Object.keys(this.options).join(',');
        var memoKey = "parseRange:".concat(memoOpts, ":").concat(range);
        var cached = cache.get(memoKey);

        if (cached) {
          return cached;
        }

        var loose = this.options.loose;
        var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug('hyphen replace', range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug('comparator trim', range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(' ');
        var rangeList = range.split(' ').map(function (comp) {
          return parseComparator(comp, _this6.options);
        }).join(' ').split(/\s+/).map(function (comp) {
          return replaceGTE0(comp, _this6.options);
        });

        if (loose) {
          rangeList = rangeList.filter(function (comp) {
            debug('loose invalid filter', comp, _this6.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }

        debug('range list', rangeList);
        var rangeMap = new Map();
        var comparators = rangeList.map(function (comp) {
          return new Comparator(comp, _this6.options);
        });
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = comparators[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var comp = _step2.value;

            if (isNullSet(comp)) {
              return [comp];
            }

            rangeMap.set(comp.value, comp);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (rangeMap.size > 1 && rangeMap.has('')) {
          rangeMap["delete"]('');
        }

        var result = _toConsumableArray(rangeMap.values());

        cache.set(memoKey, result);
        return result;
      }
    }, {
      key: "intersects",
      value: function intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError('a Range is required');
        }

        return this.set.some(function (thisComparators) {
          return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
            return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
              return rangeComparators.every(function (rangeComparator) {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
    }, {
      key: "test",
      value: function test(version) {
        if (!version) {
          return false;
        }

        if (typeof version === 'string') {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }

        for (var i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }

        return false;
      }
    }]);

    return Range;
  }();

  range = Range;
  var LRU = requireLruCache();
  var cache = new LRU({
    max: 1000
  });
  var parseOptions = parseOptions_1;
  var Comparator = requireComparator();
  var debug = debug_1;
  var SemVer = semver$2;
  var _re$3$exports4 = re$3.exports,
      re = _re$3$exports4.re,
      t = _re$3$exports4.t,
      comparatorTrimReplace = _re$3$exports4.comparatorTrimReplace,
      tildeTrimReplace = _re$3$exports4.tildeTrimReplace,
      caretTrimReplace = _re$3$exports4.caretTrimReplace;

  var isNullSet = function isNullSet(c) {
    return c.value === '<0.0.0-0';
  };

  var isAny = function isAny(c) {
    return c.value === '';
  };

  var isSatisfiable = function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();

    while (result && remainingComparators.length) {
      result = remainingComparators.every(function (otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }

    return result;
  };

  var parseComparator = function parseComparator(comp, options) {
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
  };

  var isX = function isX(id) {
    return !id || id.toLowerCase() === 'x' || id === '*';
  };

  var replaceTildes = function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function (c) {
      return replaceTilde(c, options);
    }).join(' ');
  };

  var replaceTilde = function replaceTilde(comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('tilde', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = ">=".concat(M, ".0.0 <").concat(+M + 1, ".0.0-0");
      } else if (isX(p)) {
        ret = ">=".concat(M, ".").concat(m, ".0 <").concat(M, ".").concat(+m + 1, ".0-0");
      } else if (pr) {
        debug('replaceTilde pr', pr);
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
      } else {
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(M, ".").concat(+m + 1, ".0-0");
      }

      debug('tilde return', ret);
      return ret;
    });
  };

  var replaceCarets = function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function (c) {
      return replaceCaret(c, options);
    }).join(' ');
  };

  var replaceCaret = function replaceCaret(comp, options) {
    debug('caret', comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    var z = options.includePrerelease ? '-0' : '';
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('caret', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = ">=".concat(M, ".0.0").concat(z, " <").concat(+M + 1, ".0.0-0");
      } else if (isX(p)) {
        if (M === '0') {
          ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
        } else {
          ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(+M + 1, ".0.0-0");
        }
      } else if (pr) {
        debug('replaceCaret pr', pr);

        if (M === '0') {
          if (m === '0') {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
          } else {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
          }
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(+M + 1, ".0.0-0");
        }
      } else {
        debug('no pr');

        if (M === '0') {
          if (m === '0') {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
          } else {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
          }
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(+M + 1, ".0.0-0");
        }
      }

      debug('caret return', ret);
      return ret;
    });
  };

  var replaceXRanges = function replaceXRanges(comp, options) {
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map(function (c) {
      return replaceXRange(c, options);
    }).join(' ');
  };

  var replaceXRange = function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug('xRange', comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;

      if (gtlt === '=' && anyX) {
        gtlt = '';
      }

      pr = options.includePrerelease ? '-0' : '';

      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          ret = '<0.0.0-0';
        } else {
          ret = '*';
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }

        p = 0;

        if (gtlt === '>') {
          gtlt = '>=';

          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === '<=') {
          gtlt = '<';

          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }

        if (gtlt === '<') {
          pr = '-0';
        }

        ret = "".concat(gtlt + M, ".").concat(m, ".").concat(p).concat(pr);
      } else if (xm) {
        ret = ">=".concat(M, ".0.0").concat(pr, " <").concat(+M + 1, ".0.0-0");
      } else if (xp) {
        ret = ">=".concat(M, ".").concat(m, ".0").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
      }

      debug('xRange return', ret);
      return ret;
    });
  };

  var replaceStars = function replaceStars(comp, options) {
    debug('replaceStars', comp, options);
    return comp.trim().replace(re[t.STAR], '');
  };

  var replaceGTE0 = function replaceGTE0(comp, options) {
    debug('replaceGTE0', comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
  };

  var hyphenReplace = function hyphenReplace(incPr) {
    return function ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = ">=".concat(fM, ".0.0").concat(incPr ? '-0' : '');
      } else if (isX(fp)) {
        from = ">=".concat(fM, ".").concat(fm, ".0").concat(incPr ? '-0' : '');
      } else if (fpr) {
        from = ">=".concat(from);
      } else {
        from = ">=".concat(from).concat(incPr ? '-0' : '');
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = "<".concat(+tM + 1, ".0.0-0");
      } else if (isX(tp)) {
        to = "<".concat(tM, ".").concat(+tm + 1, ".0-0");
      } else if (tpr) {
        to = "<=".concat(tM, ".").concat(tm, ".").concat(tp, "-").concat(tpr);
      } else if (incPr) {
        to = "<".concat(tM, ".").concat(tm, ".").concat(+tp + 1, "-0");
      } else {
        to = "<=".concat(to);
      }

      return "".concat(from, " ").concat(to).trim();
    };
  };

  var testSet = function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }

    if (version.prerelease.length && !options.includePrerelease) {
      for (var _i = 0; _i < set.length; _i++) {
        debug(set[_i].semver);

        if (set[_i].semver === Comparator.ANY) {
          continue;
        }

        if (set[_i].semver.prerelease.length > 0) {
          var allowed = set[_i].semver;

          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }

      return false;
    }

    return true;
  };

  return range;
}

var comparator;
var hasRequiredComparator;

function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  var ANY = Symbol('SemVer ANY');

  var Comparator =
  /*#__PURE__*/
  function () {
    _createClass(Comparator, null, [{
      key: "ANY",
      get: function get() {
        return ANY;
      }
    }]);

    function Comparator(comp, options) {
      _classCallCheck(this, Comparator);

      options = parseOptions(options);

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      debug('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug('comp', this);
    }

    _createClass(Comparator, [{
      key: "parse",
      value: function parse(comp) {
        var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        var m = comp.match(r);

        if (!m) {
          throw new TypeError("Invalid comparator: ".concat(comp));
        }

        this.operator = m[1] !== undefined ? m[1] : '';

        if (this.operator === '=') {
          this.operator = '';
        }

        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.value;
      }
    }, {
      key: "test",
      value: function test(version) {
        debug('Comparator.test', version, this.options.loose);

        if (this.semver === ANY || version === ANY) {
          return true;
        }

        if (typeof version === 'string') {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }

        return cmp(version, this.operator, this.semver, this.options);
      }
    }, {
      key: "intersects",
      value: function intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError('a Comparator is required');
        }

        if (!options || _typeof(options) !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }

        if (this.operator === '') {
          if (this.value === '') {
            return true;
          }

          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === '') {
          if (comp.value === '') {
            return true;
          }

          return new Range(this.value, options).test(comp.semver);
        }

        var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
        var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
        var sameSemVer = this.semver.version === comp.semver.version;
        var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
        var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
        var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    }]);

    return Comparator;
  }();

  comparator = Comparator;
  var parseOptions = parseOptions_1;
  var _re$3$exports5 = re$3.exports,
      re = _re$3$exports5.re,
      t = _re$3$exports5.t;
  var cmp = cmp_1;
  var debug = debug_1;
  var SemVer = semver$2;
  var Range = requireRange();
  return comparator;
}

var Range$8 = requireRange();

var satisfies$3 = function satisfies$3(version, range, options) {
  try {
    range = new Range$8(range, options);
  } catch (er) {
    return false;
  }

  return range.test(version);
};

var satisfies_1 = satisfies$3;
var Range$7 = requireRange();

var toComparators = function toComparators(range, options) {
  return new Range$7(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
};

var toComparators_1 = toComparators;
var SemVer$3 = semver$2;
var Range$6 = requireRange();

var maxSatisfying = function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;
  var rangeObj = null;

  try {
    rangeObj = new Range$6(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$3(max, options);
      }
    }
  });
  return max;
};

var maxSatisfying_1 = maxSatisfying;
var SemVer$2 = semver$2;
var Range$5 = requireRange();

var minSatisfying = function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;
  var rangeObj = null;

  try {
    rangeObj = new Range$5(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$2(min, options);
      }
    }
  });
  return min;
};

var minSatisfying_1 = minSatisfying;
var SemVer$1 = semver$2;
var Range$4 = requireRange();
var gt$1 = gt_1;

var minVersion = function minVersion(range, loose) {
  range = new Range$4(range, loose);
  var minver = new SemVer$1('0.0.0');

  if (range.test(minver)) {
    return minver;
  }

  minver = new SemVer$1('0.0.0-0');

  if (range.test(minver)) {
    return minver;
  }

  minver = null;

  var _loop = function _loop(i) {
    var comparators = range.set[i];
    var setMin = null;
    comparators.forEach(function (comparator) {
      var compver = new SemVer$1(comparator.semver.version);

      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }

          compver.raw = compver.format();

        case '':
        case '>=':
          if (!setMin || gt$1(compver, setMin)) {
            setMin = compver;
          }

          break;

        case '<':
        case '<=':
          break;

        default:
          throw new Error("Unexpected operation: ".concat(comparator.operator));
      }
    });

    if (setMin && (!minver || gt$1(minver, setMin))) {
      minver = setMin;
    }
  };

  for (var i = 0; i < range.set.length; ++i) {
    _loop(i);
  }

  if (minver && range.test(minver)) {
    return minver;
  }

  return null;
};

var minVersion_1 = minVersion;
var Range$3 = requireRange();

var validRange = function validRange(range, options) {
  try {
    return new Range$3(range, options).range || '*';
  } catch (er) {
    return null;
  }
};

var valid = validRange;
var SemVer = semver$2;
var Comparator$1 = requireComparator();
var ANY$1 = Comparator$1.ANY;
var Range$2 = requireRange();
var satisfies$2 = satisfies_1;
var gt = gt_1;
var lt = lt_1;
var lte = lte_1;
var gte = gte_1;

var outside$2 = function outside$2(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range$2(range, options);
  var gtfn, ltefn, ltfn, comp, ecomp;

  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;

    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;

    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  if (satisfies$2(version, range, options)) {
    return false;
  }

  var _loop2 = function _loop2(i) {
    var comparators = range.set[i];
    var high = null;
    var low = null;
    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY$1) {
        comparator = new Comparator$1('>=0.0.0');
      }

      high = high || comparator;
      low = low || comparator;

      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    });

    if (high.operator === comp || high.operator === ecomp) {
      return {
        v: false
      };
    }

    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return {
        v: false
      };
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return {
        v: false
      };
    }
  };

  for (var i = 0; i < range.set.length; ++i) {
    var _ret = _loop2(i);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return true;
};

var outside_1 = outside$2;
var outside$1 = outside_1;

var gtr = function gtr(version, range, options) {
  return outside$1(version, range, '>', options);
};

var gtr_1 = gtr;
var outside = outside_1;

var ltr = function ltr(version, range, options) {
  return outside(version, range, '<', options);
};

var ltr_1 = ltr;
var Range$1 = requireRange();

var intersects = function intersects(r1, r2, options) {
  r1 = new Range$1(r1, options);
  r2 = new Range$1(r2, options);
  return r1.intersects(r2);
};

var intersects_1 = intersects;
var satisfies$1 = satisfies_1;
var compare$1 = compare_1;

var simplify = function simplify(versions, range, options) {
  var set = [];
  var first = null;
  var prev = null;
  var v = versions.sort(function (a, b) {
    return compare$1(a, b, options);
  });
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = v[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var version = _step3.value;
      var included = satisfies$1(version, range, options);

      if (included) {
        prev = version;

        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }

        prev = null;
        first = null;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (first) {
    set.push([first, null]);
  }

  var ranges = [];

  for (var _i2 = 0, _set = set; _i2 < _set.length; _i2++) {
    var _set$_i = _slicedToArray(_set[_i2], 2),
        min = _set$_i[0],
        max = _set$_i[1];

    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v[0]) {
      ranges.push('*');
    } else if (!max) {
      ranges.push(">=".concat(min));
    } else if (min === v[0]) {
      ranges.push("<=".concat(max));
    } else {
      ranges.push("".concat(min, " - ").concat(max));
    }
  }

  var simplified = ranges.join(' || ');
  var original = typeof range.raw === 'string' ? range.raw : String(range);
  return simplified.length < original.length ? simplified : range;
};

var Range = requireRange();
var Comparator = requireComparator();
var ANY = Comparator.ANY;
var satisfies = satisfies_1;
var compare = compare_1;

var subset = function subset(sub, dom) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (sub === dom) {
    return true;
  }

  sub = new Range(sub, options);
  dom = new Range(dom, options);
  var sawNonNull = false;
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    OUTER: for (var _iterator4 = sub.set[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var simpleSub = _step4.value;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = dom.set[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var simpleDom = _step5.value;
          var isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;

          if (isSub) {
            continue OUTER;
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      if (sawNonNull) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return true;
};

var simpleSubset = function simpleSubset(sub, dom, options) {
  if (sub === dom) {
    return true;
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = [new Comparator('>=0.0.0-0')];
    } else {
      sub = [new Comparator('>=0.0.0')];
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = [new Comparator('>=0.0.0')];
    }
  }

  var eqSet = new Set();
  var gt, lt;
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = sub[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var c = _step6.value;

      if (c.operator === '>' || c.operator === '>=') {
        gt = higherGT(gt, c, options);
      } else if (c.operator === '<' || c.operator === '<=') {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
        _iterator6["return"]();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  if (eqSet.size > 1) {
    return null;
  }

  var gtltComp;

  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options);

    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null;
    }
  }

  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = eqSet[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      var _eq = _step7.value;

      if (gt && !satisfies(_eq, String(gt), options)) {
        return null;
      }

      if (lt && !satisfies(_eq, String(lt), options)) {
        return null;
      }

      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = dom[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var _c = _step9.value;

          if (!satisfies(_eq, String(_c), options)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      return true;
    }
  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
        _iterator7["return"]();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  var higher, lower;
  var hasDomLT, hasDomGT;
  var needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
  var needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;

  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }

  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = dom[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var _c2 = _step8.value;
      hasDomGT = hasDomGT || _c2.operator === '>' || _c2.operator === '>=';
      hasDomLT = hasDomLT || _c2.operator === '<' || _c2.operator === '<=';

      if (gt) {
        if (needDomGTPre) {
          if (_c2.semver.prerelease && _c2.semver.prerelease.length && _c2.semver.major === needDomGTPre.major && _c2.semver.minor === needDomGTPre.minor && _c2.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }

        if (_c2.operator === '>' || _c2.operator === '>=') {
          higher = higherGT(gt, _c2, options);

          if (higher === _c2 && higher !== gt) {
            return false;
          }
        } else if (gt.operator === '>=' && !satisfies(gt.semver, String(_c2), options)) {
          return false;
        }
      }

      if (lt) {
        if (needDomLTPre) {
          if (_c2.semver.prerelease && _c2.semver.prerelease.length && _c2.semver.major === needDomLTPre.major && _c2.semver.minor === needDomLTPre.minor && _c2.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }

        if (_c2.operator === '<' || _c2.operator === '<=') {
          lower = lowerLT(lt, _c2, options);

          if (lower === _c2 && lower !== lt) {
            return false;
          }
        } else if (lt.operator === '<=' && !satisfies(lt.semver, String(_c2), options)) {
          return false;
        }
      }

      if (!_c2.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
        _iterator8["return"]();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false;
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false;
  }

  if (needDomGTPre || needDomLTPre) {
    return false;
  }

  return true;
};

var higherGT = function higherGT(a, b, options) {
  if (!a) {
    return b;
  }

  var comp = compare(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
};

var lowerLT = function lowerLT(a, b, options) {
  if (!a) {
    return b;
  }

  var comp = compare(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
};

var subset_1 = subset;
var internalRe = re$3.exports;
var semver$1 = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver$2,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: requireComparator(),
  Range: requireRange(),
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
  simplifyRange: simplify,
  subset: subset_1
};
var semver = semver$1;

var builtins = function builtins() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$version = _ref.version,
      version = _ref$version === void 0 ? process.version : _ref$version,
      _ref$experimental = _ref.experimental,
      experimental = _ref$experimental === void 0 ? false : _ref$experimental;

  var coreModules = ['assert', 'buffer', 'child_process', 'cluster', 'console', 'constants', 'crypto', 'dgram', 'dns', 'domain', 'events', 'fs', 'http', 'https', 'module', 'net', 'os', 'path', 'punycode', 'querystring', 'readline', 'repl', 'stream', 'string_decoder', 'sys', 'timers', 'tls', 'tty', 'url', 'util', 'vm', 'zlib'];
  if (semver.lt(version, '6.0.0')) coreModules.push('freelist');
  if (semver.gte(version, '1.0.0')) coreModules.push('v8');
  if (semver.gte(version, '1.1.0')) coreModules.push('process');
  if (semver.gte(version, '8.0.0')) coreModules.push('inspector');
  if (semver.gte(version, '8.1.0')) coreModules.push('async_hooks');
  if (semver.gte(version, '8.4.0')) coreModules.push('http2');
  if (semver.gte(version, '8.5.0')) coreModules.push('perf_hooks');
  if (semver.gte(version, '10.0.0')) coreModules.push('trace_events');

  if (semver.gte(version, '10.5.0') && (experimental || semver.gte(version, '12.0.0'))) {
    coreModules.push('worker_threads');
  }

  if (semver.gte(version, '12.16.0') && experimental) {
    coreModules.push('wasi');
  }

  return coreModules;
};

var reader = {
  read: read
};

function read(jsonPath) {
  return find(_path().dirname(jsonPath));
}

function find(dir) {
  try {
    var string = _fs()["default"].readFileSync(_path().toNamespacedPath(_path().join(dir, 'package.json')), 'utf8');

    return {
      string: string
    };
  } catch (error) {
    if (error.code === 'ENOENT') {
      var parent = _path().dirname(dir);

      if (dir !== parent) return find(parent);
      return {
        string: undefined
      };
    }

    throw error;
  }
}

var isWindows = process.platform === 'win32';
var own$1 = {}.hasOwnProperty;
var codes = {};
var messages = new Map();
var nodeInternalPrefix = '__node_internal_';
var userStackTraceLimit;
codes.ERR_INVALID_MODULE_SPECIFIER = createError('ERR_INVALID_MODULE_SPECIFIER', function (request, reason) {
  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  return "Invalid module \"".concat(request, "\" ").concat(reason).concat(base ? " imported from ".concat(base) : '');
}, TypeError);
codes.ERR_INVALID_PACKAGE_CONFIG = createError('ERR_INVALID_PACKAGE_CONFIG', function (path, base, message) {
  return "Invalid package config ".concat(path).concat(base ? " while importing ".concat(base) : '').concat(message ? ". ".concat(message) : '');
}, Error);
codes.ERR_INVALID_PACKAGE_TARGET = createError('ERR_INVALID_PACKAGE_TARGET', function (pkgPath, key, target) {
  var isImport = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var base = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  var relError = typeof target === 'string' && !isImport && target.length > 0 && !target.startsWith('./');

  if (key === '.') {
    _assert()(isImport === false);

    return "Invalid \"exports\" main target ".concat(JSON.stringify(target), " defined ") + "in the package config ".concat(pkgPath, "package.json").concat(base ? " imported from ".concat(base) : '').concat(relError ? '; targets must start with "./"' : '');
  }

  return "Invalid \"".concat(isImport ? 'imports' : 'exports', "\" target ").concat(JSON.stringify(target), " defined for '").concat(key, "' in the package config ").concat(pkgPath, "package.json").concat(base ? " imported from ".concat(base) : '').concat(relError ? '; targets must start with "./"' : '');
}, Error);
codes.ERR_MODULE_NOT_FOUND = createError('ERR_MODULE_NOT_FOUND', function (path, base) {
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'package';
  return "Cannot find ".concat(type, " '").concat(path, "' imported from ").concat(base);
}, Error);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError('ERR_PACKAGE_IMPORT_NOT_DEFINED', function (specifier, packagePath, base) {
  return "Package import specifier \"".concat(specifier, "\" is not defined").concat(packagePath ? " in package ".concat(packagePath, "package.json") : '', " imported from ").concat(base);
}, TypeError);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError('ERR_PACKAGE_PATH_NOT_EXPORTED', function (pkgPath, subpath) {
  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  if (subpath === '.') return "No \"exports\" main defined in ".concat(pkgPath, "package.json").concat(base ? " imported from ".concat(base) : '');
  return "Package subpath '".concat(subpath, "' is not defined by \"exports\" in ").concat(pkgPath, "package.json").concat(base ? " imported from ".concat(base) : '');
}, Error);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError('ERR_UNSUPPORTED_DIR_IMPORT', "Directory import '%s' is not supported " + 'resolving ES modules imported from %s', Error);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError('ERR_UNKNOWN_FILE_EXTENSION', 'Unknown file extension "%s" for %s', TypeError);
codes.ERR_INVALID_ARG_VALUE = createError('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  var inspected = (0, _util().inspect)(value);

  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }

  var type = name.includes('.') ? 'property' : 'argument';
  return "The ".concat(type, " '").concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError);
codes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError('ERR_UNSUPPORTED_ESM_URL_SCHEME', function (url) {
  var message = 'Only file and data URLs are supported by the default ESM loader';

  if (isWindows && url.protocol.length === 2) {
    message += '. On Windows, absolute paths must be valid file:// URLs';
  }

  message += ". Received protocol '".concat(url.protocol, "'");
  return message;
}, Error);

function createError(sym, value, def) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(def, sym);
}

function makeNodeErrorWithCode(Base, key) {
  return NodeError;

  function NodeError() {
    var limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    var error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var message = getMessage(key, args, error);
    Object.defineProperty(error, 'message', {
      value: message,
      enumerable: false,
      writable: true,
      configurable: true
    });
    Object.defineProperty(error, 'toString', {
      value: function value() {
        return "".concat(this.name, " [").concat(key, "]: ").concat(this.message);
      },
      enumerable: false,
      writable: true,
      configurable: true
    });
    addCodeToName(error, Base.name, key);
    error.code = key;
    return error;
  }
}

var addCodeToName = hideStackFrames(function (error, name, code) {
  error = captureLargerStackTrace(error);
  error.name = "".concat(name, " [").concat(code, "]");
  error.stack;

  if (name === 'SystemError') {
    Object.defineProperty(error, 'name', {
      value: name,
      enumerable: false,
      writable: true,
      configurable: true
    });
  } else {
    delete error.name;
  }
});

function isErrorStackTraceLimitWritable() {
  var desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');

  if (desc === undefined) {
    return Object.isExtensible(Error);
  }

  return own$1.call(desc, 'writable') ? desc.writable : desc.set !== undefined;
}

function hideStackFrames(fn) {
  var hidden = nodeInternalPrefix + fn.name;
  Object.defineProperty(fn, 'name', {
    value: hidden
  });
  return fn;
}

var captureLargerStackTrace = hideStackFrames(function (error) {
  var stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();

  if (stackTraceLimitIsWritable) {
    userStackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Number.POSITIVE_INFINITY;
  }

  Error.captureStackTrace(error);
  if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
  return error;
});

function getMessage(key, args, self) {
  var message = messages.get(key);

  if (typeof message === 'function') {
    _assert()(message.length <= args.length, "Code: ".concat(key, "; The provided arguments length (").concat(args.length, ") does not ") + "match the required ones (".concat(message.length, ")."));

    return Reflect.apply(message, self, args);
  }

  var expectedLength = (message.match(/%[dfijoOs]/g) || []).length;

  _assert()(expectedLength === args.length, "Code: ".concat(key, "; The provided arguments length (").concat(args.length, ") does not ") + "match the required ones (".concat(expectedLength, ")."));

  if (args.length === 0) return message;
  args.unshift(message);
  return Reflect.apply(_util().format, null, args);
}

var ERR_UNKNOWN_FILE_EXTENSION = codes.ERR_UNKNOWN_FILE_EXTENSION;
var extensionFormatMap = {
  __proto__: null,
  '.cjs': 'commonjs',
  '.js': 'module',
  '.mjs': 'module'
};

function defaultGetFormat(url) {
  if (url.startsWith('node:')) {
    return {
      format: 'builtin'
    };
  }

  var parsed = new (_url().URL)(url);

  if (parsed.protocol === 'data:') {
    var _ref2 = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null],
        mime = _ref2[1];

    var format = mime === 'text/javascript' ? 'module' : null;
    return {
      format: format
    };
  }

  if (parsed.protocol === 'file:') {
    var ext = _path().extname(parsed.pathname);

    var _format;

    if (ext === '.js') {
      _format = getPackageType(parsed.href) === 'module' ? 'module' : 'commonjs';
    } else {
      _format = extensionFormatMap[ext];
    }

    if (!_format) {
      throw new ERR_UNKNOWN_FILE_EXTENSION(ext, (0, _url().fileURLToPath)(url));
    }

    return {
      format: _format || null
    };
  }

  return {
    format: null
  };
}

var listOfBuiltins = builtins();
var ERR_INVALID_MODULE_SPECIFIER = codes.ERR_INVALID_MODULE_SPECIFIER,
    ERR_INVALID_PACKAGE_CONFIG = codes.ERR_INVALID_PACKAGE_CONFIG,
    ERR_INVALID_PACKAGE_TARGET = codes.ERR_INVALID_PACKAGE_TARGET,
    ERR_MODULE_NOT_FOUND = codes.ERR_MODULE_NOT_FOUND,
    ERR_PACKAGE_IMPORT_NOT_DEFINED = codes.ERR_PACKAGE_IMPORT_NOT_DEFINED,
    ERR_PACKAGE_PATH_NOT_EXPORTED = codes.ERR_PACKAGE_PATH_NOT_EXPORTED,
    ERR_UNSUPPORTED_DIR_IMPORT = codes.ERR_UNSUPPORTED_DIR_IMPORT,
    ERR_UNSUPPORTED_ESM_URL_SCHEME = codes.ERR_UNSUPPORTED_ESM_URL_SCHEME,
    ERR_INVALID_ARG_VALUE = codes.ERR_INVALID_ARG_VALUE;
var own = {}.hasOwnProperty;
var DEFAULT_CONDITIONS = Object.freeze(['node', 'import']);
var DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
var invalidSegmentRegEx = /(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/;
var patternRegEx = /\*/g;
var encodedSepRegEx = /%2f|%2c/i;
var emittedPackageWarnings = new Set();
var packageJsonCache = new Map();

function emitFolderMapDeprecation(match, pjsonUrl, isExports, base) {
  var pjsonPath = (0, _url().fileURLToPath)(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return;
  emittedPackageWarnings.add(pjsonPath + '|' + match);
  process.emitWarning("Use of deprecated folder mapping \"".concat(match, "\" in the ").concat(isExports ? '"exports"' : '"imports"', " field module resolution of the package at ").concat(pjsonPath).concat(base ? " imported from ".concat((0, _url().fileURLToPath)(base)) : '', ".\n") + "Update this package.json to use a subpath pattern like \"".concat(match, "*\"."), 'DeprecationWarning', 'DEP0148');
}

function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
  var _defaultGetFormat = defaultGetFormat(url.href),
      format = _defaultGetFormat.format;

  if (format !== 'module') return;
  var path = (0, _url().fileURLToPath)(url.href);
  var pkgPath = (0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl));
  var basePath = (0, _url().fileURLToPath)(base);
  if (main) process.emitWarning("Package ".concat(pkgPath, " has a \"main\" field set to ").concat(JSON.stringify(main), ", ") + "excluding the full filename and extension to the resolved file at \"".concat(path.slice(pkgPath.length), "\", imported from ").concat(basePath, ".\n Automatic extension resolution of the \"main\" field is") + 'deprecated for ES modules.', 'DeprecationWarning', 'DEP0151');else process.emitWarning("No \"main\" or \"exports\" field defined in the package.json for ".concat(pkgPath, " resolving the main entry point \"").concat(path.slice(pkgPath.length), "\", imported from ").concat(basePath, ".\nDefault \"index\" lookups for the main are deprecated for ES modules."), 'DeprecationWarning', 'DEP0151');
}

function getConditionsSet(conditions) {
  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {
    if (!Array.isArray(conditions)) {
      throw new ERR_INVALID_ARG_VALUE('conditions', conditions, 'expected an array');
    }

    return new Set(conditions);
  }

  return DEFAULT_CONDITIONS_SET;
}

function tryStatSync(path) {
  try {
    return (0, _fs().statSync)(path);
  } catch (_unused) {
    return new (_fs().Stats)();
  }
}

function getPackageConfig(path, specifier, base) {
  var existing = packageJsonCache.get(path);

  if (existing !== undefined) {
    return existing;
  }

  var source = reader.read(path).string;

  if (source === undefined) {
    var _packageConfig = {
      pjsonPath: path,
      exists: false,
      main: undefined,
      name: undefined,
      type: 'none',
      exports: undefined,
      imports: undefined
    };
    packageJsonCache.set(path, _packageConfig);
    return _packageConfig;
  }

  var packageJson;

  try {
    packageJson = JSON.parse(source);
  } catch (error) {
    throw new ERR_INVALID_PACKAGE_CONFIG(path, (base ? "\"".concat(specifier, "\" from ") : '') + (0, _url().fileURLToPath)(base || specifier), error.message);
  }

  var _packageJson = packageJson,
      exports = _packageJson.exports,
      imports = _packageJson.imports,
      main = _packageJson.main,
      name = _packageJson.name,
      type = _packageJson.type;
  var packageConfig = {
    pjsonPath: path,
    exists: true,
    main: typeof main === 'string' ? main : undefined,
    name: typeof name === 'string' ? name : undefined,
    type: type === 'module' || type === 'commonjs' ? type : 'none',
    exports: exports,
    imports: imports && _typeof(imports) === 'object' ? imports : undefined
  };
  packageJsonCache.set(path, packageConfig);
  return packageConfig;
}

function getPackageScopeConfig(resolved) {
  var packageJsonUrl = new (_url().URL)('./package.json', resolved);

  while (true) {
    var _packageJsonPath = packageJsonUrl.pathname;
    if (_packageJsonPath.endsWith('node_modules/package.json')) break;

    var _packageConfig2 = getPackageConfig((0, _url().fileURLToPath)(packageJsonUrl), resolved);

    if (_packageConfig2.exists) return _packageConfig2;
    var lastPackageJsonUrl = packageJsonUrl;
    packageJsonUrl = new (_url().URL)('../package.json', packageJsonUrl);
    if (packageJsonUrl.pathname === lastPackageJsonUrl.pathname) break;
  }

  var packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
  var packageConfig = {
    pjsonPath: packageJsonPath,
    exists: false,
    main: undefined,
    name: undefined,
    type: 'none',
    exports: undefined,
    imports: undefined
  };
  packageJsonCache.set(packageJsonPath, packageConfig);
  return packageConfig;
}

function fileExists(url) {
  return tryStatSync((0, _url().fileURLToPath)(url)).isFile();
}

function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  var guess;

  if (packageConfig.main !== undefined) {
    guess = new (_url().URL)("./".concat(packageConfig.main), packageJsonUrl);
    if (fileExists(guess)) return guess;
    var _tries = ["./".concat(packageConfig.main, ".js"), "./".concat(packageConfig.main, ".json"), "./".concat(packageConfig.main, ".node"), "./".concat(packageConfig.main, "/index.js"), "./".concat(packageConfig.main, "/index.json"), "./".concat(packageConfig.main, "/index.node")];

    var _i3 = -1;

    while (++_i3 < _tries.length) {
      guess = new (_url().URL)(_tries[_i3], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = undefined;
    }

    if (guess) {
      emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
      return guess;
    }
  }

  var tries = ['./index.js', './index.json', './index.node'];
  var i = -1;

  while (++i < tries.length) {
    guess = new (_url().URL)(tries[i], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = undefined;
  }

  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }

  throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), (0, _url().fileURLToPath)(base));
}

function finalizeResolution(resolved, base) {
  if (encodedSepRegEx.test(resolved.pathname)) throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded "/" or "\\" characters', (0, _url().fileURLToPath)(base));
  var path = (0, _url().fileURLToPath)(resolved);
  var stats = tryStatSync(path.endsWith('/') ? path.slice(-1) : path);

  if (stats.isDirectory()) {
    var error = new ERR_UNSUPPORTED_DIR_IMPORT(path, (0, _url().fileURLToPath)(base));
    error.url = String(resolved);
    throw error;
  }

  if (!stats.isFile()) {
    throw new ERR_MODULE_NOT_FOUND(path || resolved.pathname, base && (0, _url().fileURLToPath)(base), 'module');
  }

  return resolved;
}

function throwImportNotDefined(specifier, packageJsonUrl, base) {
  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && (0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), (0, _url().fileURLToPath)(base));
}

function throwExportsNotFound(subpath, packageJsonUrl, base) {
  throw new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), subpath, base && (0, _url().fileURLToPath)(base));
}

function throwInvalidSubpath(subpath, packageJsonUrl, internal, base) {
  var reason = "request is not a valid subpath for the \"".concat(internal ? 'imports' : 'exports', "\" resolution of ").concat((0, _url().fileURLToPath)(packageJsonUrl));
  throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason, base && (0, _url().fileURLToPath)(base));
}

function throwInvalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = _typeof(target) === 'object' && target !== null ? JSON.stringify(target, null, '') : "".concat(target);
  throw new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), subpath, target, internal, base && (0, _url().fileURLToPath)(base));
}

function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, conditions) {
  if (subpath !== '' && !pattern && target[target.length - 1] !== '/') throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);

  if (!target.startsWith('./')) {
    if (internal && !target.startsWith('../') && !target.startsWith('/')) {
      var isURL = false;

      try {
        new (_url().URL)(target);
        isURL = true;
      } catch (_unused2) {}

      if (!isURL) {
        var exportTarget = pattern ? target.replace(patternRegEx, subpath) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }

    throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }

  if (invalidSegmentRegEx.test(target.slice(2))) throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);
  var resolved = new (_url().URL)(target, packageJsonUrl);
  var resolvedPath = resolved.pathname;
  var packagePath = new (_url().URL)('.', packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath)) throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === '') return resolved;
  if (invalidSegmentRegEx.test(subpath)) throwInvalidSubpath(match + subpath, packageJsonUrl, internal, base);
  if (pattern) return new (_url().URL)(resolved.href.replace(patternRegEx, subpath));
  return new (_url().URL)(subpath, resolved);
}

function isArrayIndex(key) {
  var keyNumber = Number(key);
  if ("".concat(keyNumber) !== key) return false;
  return keyNumber >= 0 && keyNumber < 0xffffffff;
}

function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
  if (typeof target === 'string') {
    return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, conditions);
  }

  if (Array.isArray(target)) {
    var targetList = target;
    if (targetList.length === 0) return null;
    var lastException;
    var i = -1;

    while (++i < targetList.length) {
      var targetItem = targetList[i];
      var resolved = void 0;

      try {
        resolved = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, conditions);
      } catch (error) {
        lastException = error;
        if (error.code === 'ERR_INVALID_PACKAGE_TARGET') continue;
        throw error;
      }

      if (resolved === undefined) continue;

      if (resolved === null) {
        lastException = null;
        continue;
      }

      return resolved;
    }

    if (lastException === undefined || lastException === null) {
      return lastException;
    }

    throw lastException;
  }

  if (_typeof(target) === 'object' && target !== null) {
    var keys = Object.getOwnPropertyNames(target);

    var _i4 = -1;

    while (++_i4 < keys.length) {
      var key = keys[_i4];

      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
      }
    }

    _i4 = -1;

    while (++_i4 < keys.length) {
      var _key3 = keys[_i4];

      if (_key3 === 'default' || conditions && conditions.has(_key3)) {
        var conditionalTarget = target[_key3];

        var _resolved = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, conditions);

        if (_resolved === undefined) continue;
        return _resolved;
      }
    }

    return undefined;
  }

  if (target === null) {
    return null;
  }

  throwInvalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
}

function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports === 'string' || Array.isArray(exports)) return true;
  if (_typeof(exports) !== 'object' || exports === null) return false;
  var keys = Object.getOwnPropertyNames(exports);
  var isConditionalSugar = false;
  var i = 0;
  var j = -1;

  while (++j < keys.length) {
    var key = keys[j];
    var curIsConditionalSugar = key === '' || key[0] !== '.';

    if (i++ === 0) {
      isConditionalSugar = curIsConditionalSugar;
    } else if (isConditionalSugar !== curIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain some keys starting with \'.\' and some not.' + ' The exports object must either be an object of package subpath keys' + ' or an object of main entry condition name keys only.');
    }
  }

  return isConditionalSugar;
}

function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  var exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) exports = {
    '.': exports
  };

  if (own.call(exports, packageSubpath)) {
    var target = exports[packageSubpath];
    var resolved = resolvePackageTarget(packageJsonUrl, target, '', packageSubpath, base, false, false, conditions);
    if (resolved === null || resolved === undefined) throwExportsNotFound(packageSubpath, packageJsonUrl, base);
    return {
      resolved: resolved,
      exact: true
    };
  }

  var bestMatch = '';
  var keys = Object.getOwnPropertyNames(exports);
  var i = -1;

  while (++i < keys.length) {
    var key = keys[i];

    if (key[key.length - 1] === '*' && packageSubpath.startsWith(key.slice(0, -1)) && packageSubpath.length >= key.length && key.length > bestMatch.length) {
      bestMatch = key;
    } else if (key[key.length - 1] === '/' && packageSubpath.startsWith(key) && key.length > bestMatch.length) {
      bestMatch = key;
    }
  }

  if (bestMatch) {
    var _target = exports[bestMatch];
    var pattern = bestMatch[bestMatch.length - 1] === '*';
    var subpath = packageSubpath.slice(bestMatch.length - (pattern ? 1 : 0));

    var _resolved2 = resolvePackageTarget(packageJsonUrl, _target, subpath, bestMatch, base, pattern, false, conditions);

    if (_resolved2 === null || _resolved2 === undefined) throwExportsNotFound(packageSubpath, packageJsonUrl, base);
    if (!pattern) emitFolderMapDeprecation(bestMatch, packageJsonUrl, true, base);
    return {
      resolved: _resolved2,
      exact: pattern
    };
  }

  throwExportsNotFound(packageSubpath, packageJsonUrl, base);
}

function packageImportsResolve(name, base, conditions) {
  if (name === '#' || name.startsWith('#/')) {
    var reason = 'is not a valid internal imports specifier name';
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, _url().fileURLToPath)(base));
  }

  var packageJsonUrl;
  var packageConfig = getPackageScopeConfig(base);

  if (packageConfig.exists) {
    packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
    var imports = packageConfig.imports;

    if (imports) {
      if (own.call(imports, name)) {
        var resolved = resolvePackageTarget(packageJsonUrl, imports[name], '', name, base, false, true, conditions);
        if (resolved !== null) return {
          resolved: resolved,
          exact: true
        };
      } else {
        var bestMatch = '';
        var keys = Object.getOwnPropertyNames(imports);
        var i = -1;

        while (++i < keys.length) {
          var key = keys[i];

          if (key[key.length - 1] === '*' && name.startsWith(key.slice(0, -1)) && name.length >= key.length && key.length > bestMatch.length) {
            bestMatch = key;
          } else if (key[key.length - 1] === '/' && name.startsWith(key) && key.length > bestMatch.length) {
            bestMatch = key;
          }
        }

        if (bestMatch) {
          var target = imports[bestMatch];
          var pattern = bestMatch[bestMatch.length - 1] === '*';
          var subpath = name.slice(bestMatch.length - (pattern ? 1 : 0));

          var _resolved3 = resolvePackageTarget(packageJsonUrl, target, subpath, bestMatch, base, pattern, true, conditions);

          if (_resolved3 !== null) {
            if (!pattern) emitFolderMapDeprecation(bestMatch, packageJsonUrl, false, base);
            return {
              resolved: _resolved3,
              exact: pattern
            };
          }
        }
      }
    }
  }

  throwImportNotDefined(name, packageJsonUrl, base);
}

function getPackageType(url) {
  var packageConfig = getPackageScopeConfig(url);
  return packageConfig.type;
}

function parsePackageName(specifier, base) {
  var separatorIndex = specifier.indexOf('/');
  var validPackageName = true;
  var isScoped = false;

  if (specifier[0] === '@') {
    isScoped = true;

    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf('/', separatorIndex + 1);
    }
  }

  var packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  var i = -1;

  while (++i < packageName.length) {
    if (packageName[i] === '%' || packageName[i] === '\\') {
      validPackageName = false;
      break;
    }
  }

  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(specifier, 'is not a valid package name', (0, _url().fileURLToPath)(base));
  }

  var packageSubpath = '.' + (separatorIndex === -1 ? '' : specifier.slice(separatorIndex));
  return {
    packageName: packageName,
    packageSubpath: packageSubpath,
    isScoped: isScoped
  };
}

function packageResolve(specifier, base, conditions) {
  var _parsePackageName = parsePackageName(specifier, base),
      packageName = _parsePackageName.packageName,
      packageSubpath = _parsePackageName.packageSubpath,
      isScoped = _parsePackageName.isScoped;

  var packageConfig = getPackageScopeConfig(base);

  if (packageConfig.exists) {
    var _packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);

    if (packageConfig.name === packageName && packageConfig.exports !== undefined && packageConfig.exports !== null) {
      return packageExportsResolve(_packageJsonUrl, packageSubpath, packageConfig, base, conditions).resolved;
    }
  }

  var packageJsonUrl = new (_url().URL)('./node_modules/' + packageName + '/package.json', base);
  var packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
  var lastPath;

  do {
    var stat = tryStatSync(packageJsonPath.slice(0, -13));

    if (!stat.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new (_url().URL)((isScoped ? '../../../../node_modules/' : '../../../node_modules/') + packageName + '/package.json', packageJsonUrl);
      packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
      continue;
    }

    var _packageConfig3 = getPackageConfig(packageJsonPath, specifier, base);

    if (_packageConfig3.exports !== undefined && _packageConfig3.exports !== null) return packageExportsResolve(packageJsonUrl, packageSubpath, _packageConfig3, base, conditions).resolved;
    if (packageSubpath === '.') return legacyMainResolve(packageJsonUrl, _packageConfig3, base);
    return new (_url().URL)(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);

  throw new ERR_MODULE_NOT_FOUND(packageName, (0, _url().fileURLToPath)(base));
}

function isRelativeSpecifier(specifier) {
  if (specifier[0] === '.') {
    if (specifier.length === 1 || specifier[1] === '/') return true;

    if (specifier[1] === '.' && (specifier.length === 2 || specifier[2] === '/')) {
      return true;
    }
  }

  return false;
}

function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === '') return false;
  if (specifier[0] === '/') return true;
  return isRelativeSpecifier(specifier);
}

function moduleResolve(specifier, base, conditions) {
  var resolved;

  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    resolved = new (_url().URL)(specifier, base);
  } else if (specifier[0] === '#') {
    var _packageImportsResolv = packageImportsResolve(specifier, base, conditions);

    resolved = _packageImportsResolv.resolved;
  } else {
    try {
      resolved = new (_url().URL)(specifier);
    } catch (_unused3) {
      resolved = packageResolve(specifier, base, conditions);
    }
  }

  return finalizeResolution(resolved, base);
}

function defaultResolve(specifier) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parentURL = context.parentURL;
  var parsed;

  try {
    parsed = new (_url().URL)(specifier);

    if (parsed.protocol === 'data:') {
      return {
        url: specifier
      };
    }
  } catch (_unused4) {}

  if (parsed && parsed.protocol === 'node:') return {
    url: specifier
  };
  if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:') throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);

  if (listOfBuiltins.includes(specifier)) {
    return {
      url: 'node:' + specifier
    };
  }

  if (parentURL.startsWith('data:')) {
    new (_url().URL)(specifier, parentURL);
  }

  var conditions = getConditionsSet(context.conditions);
  var url = moduleResolve(specifier, new (_url().URL)(parentURL), conditions);
  var urlPath = (0, _url().fileURLToPath)(url);
  var real = (0, _fs().realpathSync)(urlPath);
  var old = url;
  url = (0, _url().pathToFileURL)(real + (urlPath.endsWith(_path().sep) ? '/' : ''));
  url.search = old.search;
  url.hash = old.hash;
  return {
    url: "".concat(url)
  };
}

function resolve(_x, _x2) {
  return _resolve.apply(this, arguments);
}

function _resolve() {
  _resolve = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2(specifier, parent) {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (parent) {
              _context2.next = 2;
              break;
            }

            throw new Error('Please pass `parent`: `import-meta-resolve` cannot ponyfill that');

          case 2:
            _context2.prev = 2;
            return _context2.abrupt("return", defaultResolve(specifier, {
              parentURL: parent
            }).url);

          case 6:
            _context2.prev = 6;
            _context2.t0 = _context2["catch"](2);
            return _context2.abrupt("return", _context2.t0.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ? _context2.t0.url : Promise.reject(_context2.t0));

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[2, 6]]);
  }));
  return _resolve.apply(this, arguments);
}

0 && 0;