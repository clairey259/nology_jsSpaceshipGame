"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginHiddenCallStack = beginHiddenCallStack;
exports.endHiddenCallStack = endHiddenCallStack;
exports.expectedError = expectedError;
exports.injcectVirtualStackFrame = injcectVirtualStackFrame;
var ErrorToString = Function.call.bind(Error.prototype.toString);
var SUPPORTED = !!Error.captureStackTrace;
var START_HIDNG = "startHiding - secret - don't use this - v1";
var STOP_HIDNG = "stopHiding - secret - don't use this - v1";
var expectedErrors = new WeakSet();
var virtualFrames = new WeakMap();

function CallSite(filename) {
  return Object.create({
    isNative: function isNative() {
      return false;
    },
    isConstructor: function isConstructor() {
      return false;
    },
    isToplevel: function isToplevel() {
      return true;
    },
    getFileName: function getFileName() {
      return filename;
    },
    getLineNumber: function getLineNumber() {
      return undefined;
    },
    getColumnNumber: function getColumnNumber() {
      return undefined;
    },
    getFunctionName: function getFunctionName() {
      return undefined;
    },
    getMethodName: function getMethodName() {
      return undefined;
    },
    getTypeName: function getTypeName() {
      return undefined;
    },
    toString: function toString() {
      return filename;
    }
  });
}

function injcectVirtualStackFrame(error, filename) {
  if (!SUPPORTED) return;
  var frames = virtualFrames.get(error);
  if (!frames) virtualFrames.set(error, frames = []);
  frames.push(CallSite(filename));
  return error;
}

function expectedError(error) {
  if (!SUPPORTED) return;
  expectedErrors.add(error);
  return error;
}

function beginHiddenCallStack(fn) {
  if (!SUPPORTED) return fn;
  return Object.defineProperty(function () {
    setupPrepareStackTrace();
    return fn.apply(void 0, arguments);
  }, "name", {
    value: STOP_HIDNG
  });
}

function endHiddenCallStack(fn) {
  if (!SUPPORTED) return fn;
  return Object.defineProperty(function () {
    return fn.apply(void 0, arguments);
  }, "name", {
    value: START_HIDNG
  });
}

function setupPrepareStackTrace() {
  setupPrepareStackTrace = function setupPrepareStackTrace() {};

  var _Error$prepareStackTr = Error.prepareStackTrace,
      prepareStackTrace = _Error$prepareStackTr === void 0 ? defaultPrepareStackTrace : _Error$prepareStackTr;
  var MIN_STACK_TRACE_LIMIT = 50;
  Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, MIN_STACK_TRACE_LIMIT));

  Error.prepareStackTrace = function stackTraceRewriter(err, trace) {
    var newTrace = [];
    var isExpected = expectedErrors.has(err);
    var status = isExpected ? "hiding" : "unknown";

    for (var i = 0; i < trace.length; i++) {
      var name = trace[i].getFunctionName();

      if (name === START_HIDNG) {
        status = "hiding";
      } else if (name === STOP_HIDNG) {
        if (status === "hiding") {
          status = "showing";

          if (virtualFrames.has(err)) {
            var _newTrace;

            (_newTrace = newTrace).unshift.apply(_newTrace, _toConsumableArray(virtualFrames.get(err)));
          }
        } else if (status === "unknown") {
          newTrace = trace;
          break;
        }
      } else if (status !== "hiding") {
        newTrace.push(trace[i]);
      }
    }

    return prepareStackTrace(err, newTrace);
  };
}

function defaultPrepareStackTrace(err, trace) {
  if (trace.length === 0) return ErrorToString(err);
  return "".concat(ErrorToString(err), "\n    at ").concat(trace.join("\n    at "));
}

0 && 0;