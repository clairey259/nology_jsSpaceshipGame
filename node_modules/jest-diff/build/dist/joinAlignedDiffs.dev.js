'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;

var _cleanupSemantic = require('./cleanupSemantic');
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var formatTrailingSpaces = function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, function (match) {
    return trailingSpaceFormatter(match);
  });
};

var printDiffLine = function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color("".concat(indicator, " ").concat(formatTrailingSpaces(line, trailingSpaceFormatter))) : indicator !== ' ' ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color("".concat(indicator, " ").concat(emptyFirstOrLastLinePlaceholder)) : '';
};

var printDeleteLine = function printDeleteLine(line, isFirstOrLast, _ref) {
  var aColor = _ref.aColor,
      aIndicator = _ref.aIndicator,
      changeLineTrailingSpaceColor = _ref.changeLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder = _ref.emptyFirstOrLastLinePlaceholder;
  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
};

var printInsertLine = function printInsertLine(line, isFirstOrLast, _ref2) {
  var bColor = _ref2.bColor,
      bIndicator = _ref2.bIndicator,
      changeLineTrailingSpaceColor = _ref2.changeLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder = _ref2.emptyFirstOrLastLinePlaceholder;
  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
};

var printCommonLine = function printCommonLine(line, isFirstOrLast, _ref3) {
  var commonColor = _ref3.commonColor,
      commonIndicator = _ref3.commonIndicator,
      commonLineTrailingSpaceColor = _ref3.commonLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder = _ref3.emptyFirstOrLastLinePlaceholder;
  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}; // In GNU diff format, indexes are one-based instead of zero-based.


var createPatchMark = function createPatchMark(aStart, aEnd, bStart, bEnd, _ref4) {
  var patchColor = _ref4.patchColor;
  return patchColor("@@ -".concat(aStart + 1, ",").concat(aEnd - aStart, " +").concat(bStart + 1, ",").concat(bEnd - bStart, " @@"));
}; // jest --no-expand
//
// Given array of aligned strings with inverse highlight formatting,
// return joined lines with diff formatting (and patch marks, if needed).


var joinAlignedDiffsNoExpand = function joinAlignedDiffsNoExpand(diffs, options) {
  var iLength = diffs.length;
  var nContextLines = options.contextLines;
  var nContextLines2 = nContextLines + nContextLines; // First pass: count output lines and see if it has patches.

  var jLength = iLength;
  var hasExcessAtStartOrEnd = false;
  var nExcessesBetweenChanges = 0;
  var i = 0;

  while (i !== iLength) {
    var iStart = i;

    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {
      i += 1;
    }

    if (iStart !== i) {
      if (iStart === 0) {
        // at start
        if (i > nContextLines) {
          jLength -= i - nContextLines; // subtract excess common lines

          hasExcessAtStartOrEnd = true;
        }
      } else if (i === iLength) {
        // at end
        var n = i - iStart;

        if (n > nContextLines) {
          jLength -= n - nContextLines; // subtract excess common lines

          hasExcessAtStartOrEnd = true;
        }
      } else {
        // between changes
        var _n = i - iStart;

        if (_n > nContextLines2) {
          jLength -= _n - nContextLines2; // subtract excess common lines

          nExcessesBetweenChanges += 1;
        }
      }
    }

    while (i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL) {
      i += 1;
    }
  }

  var hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;

  if (nExcessesBetweenChanges !== 0) {
    jLength += nExcessesBetweenChanges + 1; // add patch lines
  } else if (hasExcessAtStartOrEnd) {
    jLength += 1; // add patch line
  }

  var jLast = jLength - 1;
  var lines = [];
  var jPatchMark = 0; // index of placeholder line for current patch mark

  if (hasPatch) {
    lines.push(''); // placeholder line for first patch mark
  } // Indexes of expected or received lines in current patch:


  var aStart = 0;
  var bStart = 0;
  var aEnd = 0;
  var bEnd = 0;

  var pushCommonLine = function pushCommonLine(line) {
    var j = lines.length;
    lines.push(printCommonLine(line, j === 0 || j === jLast, options));
    aEnd += 1;
    bEnd += 1;
  };

  var pushDeleteLine = function pushDeleteLine(line) {
    var j = lines.length;
    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));
    aEnd += 1;
  };

  var pushInsertLine = function pushInsertLine(line) {
    var j = lines.length;
    lines.push(printInsertLine(line, j === 0 || j === jLast, options));
    bEnd += 1;
  }; // Second pass: push lines with diff formatting (and patch marks, if needed).


  i = 0;

  while (i !== iLength) {
    var _iStart = i;

    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {
      i += 1;
    }

    if (_iStart !== i) {
      if (_iStart === 0) {
        // at beginning
        if (i > nContextLines) {
          _iStart = i - nContextLines;
          aStart = _iStart;
          bStart = _iStart;
          aEnd = aStart;
          bEnd = bStart;
        }

        for (var iCommon = _iStart; iCommon !== i; iCommon += 1) {
          pushCommonLine(diffs[iCommon][1]);
        }
      } else if (i === iLength) {
        // at end
        var iEnd = i - _iStart > nContextLines ? _iStart + nContextLines : i;

        for (var _iCommon = _iStart; _iCommon !== iEnd; _iCommon += 1) {
          pushCommonLine(diffs[_iCommon][1]);
        }
      } else {
        // between changes
        var nCommon = i - _iStart;

        if (nCommon > nContextLines2) {
          var _iEnd = _iStart + nContextLines;

          for (var _iCommon2 = _iStart; _iCommon2 !== _iEnd; _iCommon2 += 1) {
            pushCommonLine(diffs[_iCommon2][1]);
          }

          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
          jPatchMark = lines.length;
          lines.push(''); // placeholder line for next patch mark

          var nOmit = nCommon - nContextLines2;
          aStart = aEnd + nOmit;
          bStart = bEnd + nOmit;
          aEnd = aStart;
          bEnd = bStart;

          for (var _iCommon3 = i - nContextLines; _iCommon3 !== i; _iCommon3 += 1) {
            pushCommonLine(diffs[_iCommon3][1]);
          }
        } else {
          for (var _iCommon4 = _iStart; _iCommon4 !== i; _iCommon4 += 1) {
            pushCommonLine(diffs[_iCommon4][1]);
          }
        }
      }
    }

    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE) {
      pushDeleteLine(diffs[i][1]);
      i += 1;
    }

    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT) {
      pushInsertLine(diffs[i][1]);
      i += 1;
    }
  }

  if (hasPatch) {
    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
  }

  return lines.join('\n');
}; // jest --expand
//
// Given array of aligned strings with inverse highlight formatting,
// return joined lines with diff formatting.


exports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;

var joinAlignedDiffsExpand = function joinAlignedDiffsExpand(diffs, options) {
  return diffs.map(function (diff, i, diffs) {
    var line = diff[1];
    var isFirstOrLast = i === 0 || i === diffs.length - 1;

    switch (diff[0]) {
      case _cleanupSemantic.DIFF_DELETE:
        return printDeleteLine(line, isFirstOrLast, options);

      case _cleanupSemantic.DIFF_INSERT:
        return printInsertLine(line, isFirstOrLast, options);

      default:
        return printCommonLine(line, isFirstOrLast, options);
    }
  }).join('\n');
};

exports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;