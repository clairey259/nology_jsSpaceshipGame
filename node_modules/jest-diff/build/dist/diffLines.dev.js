'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.printDiffLines = exports.diffLinesUnified2 = exports.diffLinesUnified = exports.diffLinesRaw = void 0;

var _diffSequences = _interopRequireDefault(require('diff-sequences'));

var _cleanupSemantic = require('./cleanupSemantic');

var _joinAlignedDiffs = require('./joinAlignedDiffs');

var _normalizeDiffOptions = require('./normalizeDiffOptions');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var isEmptyString = function isEmptyString(lines) {
  return lines.length === 1 && lines[0].length === 0;
};

var countChanges = function countChanges(diffs) {
  var a = 0;
  var b = 0;
  diffs.forEach(function (diff) {
    switch (diff[0]) {
      case _cleanupSemantic.DIFF_DELETE:
        a += 1;
        break;

      case _cleanupSemantic.DIFF_INSERT:
        b += 1;
        break;
    }
  });
  return {
    a: a,
    b: b
  };
};

var printAnnotation = function printAnnotation(_ref, changeCounts) {
  var aAnnotation = _ref.aAnnotation,
      aColor = _ref.aColor,
      aIndicator = _ref.aIndicator,
      bAnnotation = _ref.bAnnotation,
      bColor = _ref.bColor,
      bIndicator = _ref.bIndicator,
      includeChangeCounts = _ref.includeChangeCounts,
      omitAnnotationLines = _ref.omitAnnotationLines;

  if (omitAnnotationLines) {
    return '';
  }

  var aRest = '';
  var bRest = '';

  if (includeChangeCounts) {
    var aCount = String(changeCounts.a);
    var bCount = String(changeCounts.b); // Padding right aligns the ends of the annotations.

    var baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
    var aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));
    var bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff)); // Padding left aligns the ends of the counts.

    var baCountLengthDiff = bCount.length - aCount.length;
    var aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));
    var bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));
    aRest = "".concat(aAnnotationPadding, "  ").concat(aIndicator, " ").concat(aCountPadding).concat(aCount);
    bRest = "".concat(bAnnotationPadding, "  ").concat(bIndicator, " ").concat(bCountPadding).concat(bCount);
  }

  var a = "".concat(aIndicator, " ").concat(aAnnotation).concat(aRest);
  var b = "".concat(bIndicator, " ").concat(bAnnotation).concat(bRest);
  return "".concat(aColor(a), "\n").concat(bColor(b), "\n\n");
};

var printDiffLines = function printDiffLines(diffs, options) {
  return printAnnotation(options, countChanges(diffs)) + (options.expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options));
}; // Compare two arrays of strings line-by-line. Format as comparison lines.


exports.printDiffLines = printDiffLines;

var diffLinesUnified = function diffLinesUnified(aLines, bLines, options) {
  return printDiffLines(diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines), (0, _normalizeDiffOptions.normalizeDiffOptions)(options));
}; // Given two pairs of arrays of strings:
// Compare the pair of comparison arrays line-by-line.
// Format the corresponding lines in the pair of displayable arrays.


exports.diffLinesUnified = diffLinesUnified;

var diffLinesUnified2 = function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {
    aLinesDisplay = [];
    aLinesCompare = [];
  }

  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {
    bLinesDisplay = [];
    bLinesCompare = [];
  }

  if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {
    // Fall back to diff of display lines.
    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
  }

  var diffs = diffLinesRaw(aLinesCompare, bLinesCompare); // Replace comparison lines with displayable lines.

  var aIndex = 0;
  var bIndex = 0;
  diffs.forEach(function (diff) {
    switch (diff[0]) {
      case _cleanupSemantic.DIFF_DELETE:
        diff[1] = aLinesDisplay[aIndex];
        aIndex += 1;
        break;

      case _cleanupSemantic.DIFF_INSERT:
        diff[1] = bLinesDisplay[bIndex];
        bIndex += 1;
        break;

      default:
        diff[1] = bLinesDisplay[bIndex];
        aIndex += 1;
        bIndex += 1;
    }
  });
  return printDiffLines(diffs, (0, _normalizeDiffOptions.normalizeDiffOptions)(options));
}; // Compare two arrays of strings line-by-line.


exports.diffLinesUnified2 = diffLinesUnified2;

var diffLinesRaw = function diffLinesRaw(aLines, bLines) {
  var aLength = aLines.length;
  var bLength = bLines.length;

  var isCommon = function isCommon(aIndex, bIndex) {
    return aLines[aIndex] === bLines[bIndex];
  };

  var diffs = [];
  var aIndex = 0;
  var bIndex = 0;

  var foundSubsequence = function foundSubsequence(nCommon, aCommon, bCommon) {
    for (; aIndex !== aCommon; aIndex += 1) {
      diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex]));
    }

    for (; bIndex !== bCommon; bIndex += 1) {
      diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex]));
    }

    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {
      diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_EQUAL, bLines[bIndex]));
    }
  };

  (0, _diffSequences["default"])(aLength, bLength, isCommon, foundSubsequence); // After the last common subsequence, push remaining change items.

  for (; aIndex !== aLength; aIndex += 1) {
    diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex]));
  }

  for (; bIndex !== bLength; bIndex += 1) {
    diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex]));
  }

  return diffs;
};

exports.diffLinesRaw = diffLinesRaw;