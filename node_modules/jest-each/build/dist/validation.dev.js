'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.validateTemplateTableArguments = exports.validateArrayTable = exports.extractValidTemplateHeadings = void 0;

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _prettyFormat() {
  var data = require('pretty-format');

  _prettyFormat = function _prettyFormat() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */


var EXPECTED_COLOR = _chalk()["default"].green;

var RECEIVED_COLOR = _chalk()["default"].red;

var validateArrayTable = function validateArrayTable(table) {
  if (!Array.isArray(table)) {
    throw new Error('`.each` must be called with an Array or Tagged Template Literal.\n\n' + "Instead was called with: ".concat((0, _prettyFormat().format)(table, {
      maxDepth: 1,
      min: true
    }), "\n"));
  }

  if (isTaggedTemplateLiteral(table)) {
    if (isEmptyString(table[0])) {
      throw new Error('Error: `.each` called with an empty Tagged Template Literal of table data.\n');
    }

    throw new Error('Error: `.each` called with a Tagged Template Literal with no data, remember to interpolate with ${expression} syntax.\n');
  }

  if (isEmptyTable(table)) {
    throw new Error('Error: `.each` called with an empty Array of table data.\n');
  }
};

exports.validateArrayTable = validateArrayTable;

var isTaggedTemplateLiteral = function isTaggedTemplateLiteral(array) {
  return array.raw !== undefined;
};

var isEmptyTable = function isEmptyTable(table) {
  return table.length === 0;
};

var isEmptyString = function isEmptyString(str) {
  return typeof str === 'string' && str.trim() === '';
};

var validateTemplateTableArguments = function validateTemplateTableArguments(headings, data) {
  var incompleteData = data.length % headings.length;
  var missingData = headings.length - incompleteData;

  if (incompleteData > 0) {
    throw new Error("Not enough arguments supplied for given headings:\n".concat(EXPECTED_COLOR(headings.join(' | ')), "\n\n") + "Received:\n".concat(RECEIVED_COLOR((0, _prettyFormat().format)(data)), "\n\n") + "Missing ".concat(RECEIVED_COLOR(missingData.toString()), " ").concat(pluralize('argument', missingData)));
  }
};

exports.validateTemplateTableArguments = validateTemplateTableArguments;

var pluralize = function pluralize(word, count) {
  return word + (count === 1 ? '' : 's');
};

var START_OF_LINE = '^';
var NEWLINE = '\\n';
var HEADING = '\\s*[^\\s]+\\s*';
var PIPE = '\\|';
var REPEATABLE_HEADING = "(".concat(PIPE).concat(HEADING, ")*");
var HEADINGS_FORMAT = new RegExp(START_OF_LINE + NEWLINE + HEADING + REPEATABLE_HEADING + NEWLINE, 'g');

var extractValidTemplateHeadings = function extractValidTemplateHeadings(headings) {
  var matches = headings.match(HEADINGS_FORMAT);

  if (matches === null) {
    throw new Error("Table headings do not conform to expected format:\n\n".concat(EXPECTED_COLOR('heading1 | headingN'), "\n\nReceived:\n\n").concat(RECEIVED_COLOR((0, _prettyFormat().format)(headings))));
  }

  return matches[0];
};

exports.extractValidTemplateHeadings = extractValidTemplateHeadings;