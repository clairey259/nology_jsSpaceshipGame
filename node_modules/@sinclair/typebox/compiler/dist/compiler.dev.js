"use strict";
/*--------------------------------------------------------------------------

@sinclair/typebox/compiler

The MIT License (MIT)

Copyright (c) 2022 Haydn Paterson (sinclair) <haydn.developer@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

---------------------------------------------------------------------------*/

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeCompiler = exports.TypeCompilerUnknownTypeError = exports.Property = exports.TypeCheck = void 0;

var index_1 = require("../errors/index");

var index_2 = require("../guard/index");

var index_3 = require("../format/index");

var Types = require("../typebox"); // -------------------------------------------------------------------
// TypeCheck
// -------------------------------------------------------------------


var TypeCheck =
/*#__PURE__*/
function () {
  function TypeCheck(schema, references, checkFunc, code) {
    _classCallCheck(this, TypeCheck);

    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
  }
  /** Returns the generated validation code used to validate this type. */


  _createClass(TypeCheck, [{
    key: "Code",
    value: function Code() {
      return this.code;
    }
    /** Returns an iterator for each error in this value. */

  }, {
    key: "Errors",
    value: function Errors(value) {
      return index_1.ValueErrors.Errors(this.schema, this.references, value);
    }
    /** Returns true if the value matches the given type. */

  }, {
    key: "Check",
    value: function Check(value) {
      return this.checkFunc(value);
    }
  }]);

  return TypeCheck;
}();

exports.TypeCheck = TypeCheck; // -------------------------------------------------------------------
// Property
// -------------------------------------------------------------------

var Property;

(function (Property) {
  function DollarSign(code) {
    return code === 36;
  }

  function Underscore(code) {
    return code === 95;
  }

  function Numeric(code) {
    return code >= 48 && code <= 57;
  }

  function Alpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }

  function Check(propertyName) {
    if (propertyName.length === 0) return false;
    {
      var code = propertyName.charCodeAt(0);

      if (!(DollarSign(code) || Underscore(code) || Alpha(code))) {
        return false;
      }
    }

    for (var i = 1; i < propertyName.length; i++) {
      var _code = propertyName.charCodeAt(i);

      if (!(DollarSign(_code) || Underscore(_code) || Alpha(_code) || Numeric(_code))) {
        return false;
      }
    }

    return true;
  }

  Property.Check = Check;
})(Property = exports.Property || (exports.Property = {})); // -------------------------------------------------------------------
// TypeCompiler
// -------------------------------------------------------------------


var TypeCompilerUnknownTypeError =
/*#__PURE__*/
function (_Error) {
  _inherits(TypeCompilerUnknownTypeError, _Error);

  function TypeCompilerUnknownTypeError(schema) {
    var _this;

    _classCallCheck(this, TypeCompilerUnknownTypeError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TypeCompilerUnknownTypeError).call(this, 'TypeCompiler: Unknown type'));
    _this.schema = schema;
    return _this;
  }

  return TypeCompilerUnknownTypeError;
}(_wrapNativeSuper(Error));

exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;
/** Compiles Types for Runtime Type Checking */

var TypeCompiler;

(function (TypeCompiler) {
  var _marked =
  /*#__PURE__*/
  regeneratorRuntime.mark(Any),
      _marked2 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Array),
      _marked3 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Boolean),
      _marked4 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Constructor),
      _marked5 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Function),
      _marked6 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Integer),
      _marked7 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Literal),
      _marked8 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Never),
      _marked9 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Null),
      _marked10 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Number),
      _marked11 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Object),
      _marked12 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Promise),
      _marked13 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Record),
      _marked14 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Ref),
      _marked15 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Self),
      _marked16 =
  /*#__PURE__*/
  regeneratorRuntime.mark(String),
      _marked17 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Tuple),
      _marked18 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Undefined),
      _marked19 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Union),
      _marked20 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Uint8Array),
      _marked21 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Unknown),
      _marked22 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Void),
      _marked23 =
  /*#__PURE__*/
  regeneratorRuntime.mark(Visit);

  // -------------------------------------------------------------------
  // Types
  // -------------------------------------------------------------------
  function Any(schema, value) {
    return regeneratorRuntime.wrap(function Any$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return '(true)';

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _marked);
  }

  function Array(schema, value) {
    var expression;
    return regeneratorRuntime.wrap(function Array$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            expression = CreateExpression(schema.items, 'value');

            if (!(schema.minItems !== undefined)) {
              _context2.next = 4;
              break;
            }

            _context2.next = 4;
            return "(".concat(value, ".length >= ").concat(schema.minItems, ")");

          case 4:
            if (!(schema.maxItems !== undefined)) {
              _context2.next = 7;
              break;
            }

            _context2.next = 7;
            return "(".concat(value, ".length <= ").concat(schema.maxItems, ")");

          case 7:
            if (!(schema.uniqueItems !== undefined)) {
              _context2.next = 10;
              break;
            }

            _context2.next = 10;
            return "(new Set(".concat(value, ").size === ").concat(value, ".length)");

          case 10:
            _context2.next = 12;
            return "(Array.isArray(".concat(value, ") && ").concat(value, ".every(value => ").concat(expression, "))");

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2);
  }

  function Boolean(schema, value) {
    return regeneratorRuntime.wrap(function Boolean$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return "(typeof ".concat(value, " === 'boolean')");

          case 2:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked3);
  }

  function Constructor(schema, value) {
    return regeneratorRuntime.wrap(function Constructor$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.delegateYield(Visit(schema.returns, "".concat(value, ".prototype")), "t0", 1);

          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked4);
  }

  function Function(schema, value) {
    return regeneratorRuntime.wrap(function Function$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return "(typeof ".concat(value, " === 'function')");

          case 2:
          case "end":
            return _context5.stop();
        }
      }
    }, _marked5);
  }

  function Integer(schema, value) {
    return regeneratorRuntime.wrap(function Integer$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return "(typeof ".concat(value, " === 'number' && Number.isInteger(").concat(value, "))");

          case 2:
            if (!(schema.multipleOf !== undefined)) {
              _context6.next = 5;
              break;
            }

            _context6.next = 5;
            return "(".concat(value, " % ").concat(schema.multipleOf, " === 0)");

          case 5:
            if (!(schema.exclusiveMinimum !== undefined)) {
              _context6.next = 8;
              break;
            }

            _context6.next = 8;
            return "(".concat(value, " > ").concat(schema.exclusiveMinimum, ")");

          case 8:
            if (!(schema.exclusiveMaximum !== undefined)) {
              _context6.next = 11;
              break;
            }

            _context6.next = 11;
            return "(".concat(value, " < ").concat(schema.exclusiveMaximum, ")");

          case 11:
            if (!(schema.minimum !== undefined)) {
              _context6.next = 14;
              break;
            }

            _context6.next = 14;
            return "(".concat(value, " >= ").concat(schema.minimum, ")");

          case 14:
            if (!(schema.maximum !== undefined)) {
              _context6.next = 17;
              break;
            }

            _context6.next = 17;
            return "(".concat(value, " <= ").concat(schema.maximum, ")");

          case 17:
          case "end":
            return _context6.stop();
        }
      }
    }, _marked6);
  }

  function Literal(schema, value) {
    return regeneratorRuntime.wrap(function Literal$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (!(typeof schema["const"] === 'number' || typeof schema["const"] === 'boolean')) {
              _context7.next = 5;
              break;
            }

            _context7.next = 3;
            return "(".concat(value, " === ").concat(schema["const"], ")");

          case 3:
            _context7.next = 7;
            break;

          case 5:
            _context7.next = 7;
            return "(".concat(value, " === '").concat(schema["const"], "')");

          case 7:
          case "end":
            return _context7.stop();
        }
      }
    }, _marked7);
  }

  function Never(schema, value) {
    return regeneratorRuntime.wrap(function Never$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return "(false)";

          case 2:
          case "end":
            return _context8.stop();
        }
      }
    }, _marked8);
  }

  function Null(schema, value) {
    return regeneratorRuntime.wrap(function Null$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return "(".concat(value, " === null)");

          case 2:
          case "end":
            return _context9.stop();
        }
      }
    }, _marked9);
  }

  function Number(schema, value) {
    return regeneratorRuntime.wrap(function Number$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return "(typeof ".concat(value, " === 'number')");

          case 2:
            if (!(schema.multipleOf !== undefined)) {
              _context10.next = 5;
              break;
            }

            _context10.next = 5;
            return "(".concat(value, " % ").concat(schema.multipleOf, " === 0)");

          case 5:
            if (!(schema.exclusiveMinimum !== undefined)) {
              _context10.next = 8;
              break;
            }

            _context10.next = 8;
            return "(".concat(value, " > ").concat(schema.exclusiveMinimum, ")");

          case 8:
            if (!(schema.exclusiveMaximum !== undefined)) {
              _context10.next = 11;
              break;
            }

            _context10.next = 11;
            return "(".concat(value, " < ").concat(schema.exclusiveMaximum, ")");

          case 11:
            if (!(schema.minimum !== undefined)) {
              _context10.next = 14;
              break;
            }

            _context10.next = 14;
            return "(".concat(value, " >= ").concat(schema.minimum, ")");

          case 14:
            if (!(schema.maximum !== undefined)) {
              _context10.next = 17;
              break;
            }

            _context10.next = 17;
            return "(".concat(value, " <= ").concat(schema.maximum, ")");

          case 17:
          case "end":
            return _context10.stop();
        }
      }
    }, _marked10);
  }

  function Object(schema, value) {
    var propertyKeys, keys, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, propertyKey, memberExpression, propertySchema, expression;

    return regeneratorRuntime.wrap(function Object$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return "(typeof ".concat(value, " === 'object' && ").concat(value, " !== null && !Array.isArray(").concat(value, "))");

          case 2:
            if (!(schema.minProperties !== undefined)) {
              _context11.next = 5;
              break;
            }

            _context11.next = 5;
            return "(Object.keys(".concat(value, ").length >= ").concat(schema.minProperties, ")");

          case 5:
            if (!(schema.maxProperties !== undefined)) {
              _context11.next = 8;
              break;
            }

            _context11.next = 8;
            return "(Object.keys(".concat(value, ").length <= ").concat(schema.maxProperties, ")");

          case 8:
            propertyKeys = globalThis.Object.keys(schema.properties);

            if (!(schema.additionalProperties === false)) {
              _context11.next = 18;
              break;
            }

            if (!(schema.required && schema.required.length === propertyKeys.length)) {
              _context11.next = 15;
              break;
            }

            _context11.next = 13;
            return "(Object.keys(".concat(value, ").length === ").concat(propertyKeys.length, ")");

          case 13:
            _context11.next = 18;
            break;

          case 15:
            keys = "[".concat(propertyKeys.map(function (key) {
              return "'".concat(key, "'");
            }).join(', '), "]");
            _context11.next = 18;
            return "(Object.keys(".concat(value, ").every(key => ").concat(keys, ".includes(key)))");

          case 18:
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context11.prev = 21;
            _iterator = propertyKeys[Symbol.iterator]();

          case 23:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context11.next = 37;
              break;
            }

            propertyKey = _step.value;
            memberExpression = Property.Check(propertyKey) ? "".concat(value, ".").concat(propertyKey) : "".concat(value, "['").concat(propertyKey, "']");
            propertySchema = schema.properties[propertyKey];

            if (!(schema.required && schema.required.includes(propertyKey))) {
              _context11.next = 31;
              break;
            }

            return _context11.delegateYield(Visit(propertySchema, memberExpression), "t0", 29);

          case 29:
            _context11.next = 34;
            break;

          case 31:
            expression = CreateExpression(propertySchema, memberExpression);
            _context11.next = 34;
            return "(".concat(memberExpression, " === undefined ? true : (").concat(expression, "))");

          case 34:
            _iteratorNormalCompletion = true;
            _context11.next = 23;
            break;

          case 37:
            _context11.next = 43;
            break;

          case 39:
            _context11.prev = 39;
            _context11.t1 = _context11["catch"](21);
            _didIteratorError = true;
            _iteratorError = _context11.t1;

          case 43:
            _context11.prev = 43;
            _context11.prev = 44;

            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }

          case 46:
            _context11.prev = 46;

            if (!_didIteratorError) {
              _context11.next = 49;
              break;
            }

            throw _iteratorError;

          case 49:
            return _context11.finish(46);

          case 50:
            return _context11.finish(43);

          case 51:
          case "end":
            return _context11.stop();
        }
      }
    }, _marked11, null, [[21, 39, 43, 51], [44,, 46, 50]]);
  }

  function Promise(schema, value) {
    return regeneratorRuntime.wrap(function Promise$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            _context12.next = 2;
            return "(typeof value === 'object' && typeof ".concat(value, ".then === 'function')");

          case 2:
          case "end":
            return _context12.stop();
        }
      }
    }, _marked12);
  }

  function Record(schema, value) {
    var _globalThis$Object$en, keyPattern, valueSchema, local, expression;

    return regeneratorRuntime.wrap(function Record$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            _context13.next = 2;
            return "(typeof ".concat(value, " === 'object' && ").concat(value, " !== null && !Array.isArray(").concat(value, "))");

          case 2:
            _globalThis$Object$en = _slicedToArray(globalThis.Object.entries(schema.patternProperties)[0], 2), keyPattern = _globalThis$Object$en[0], valueSchema = _globalThis$Object$en[1];
            local = PushLocal("new RegExp(/".concat(keyPattern, "/)"));
            _context13.next = 6;
            return "(Object.keys(".concat(value, ").every(key => ").concat(local, ".test(key)))");

          case 6:
            expression = CreateExpression(valueSchema, 'value');
            _context13.next = 9;
            return "(Object.values(".concat(value, ").every(value => ").concat(expression, "))");

          case 9:
          case "end":
            return _context13.stop();
        }
      }
    }, _marked13);
  }

  function Ref(schema, value) {
    var reference;
    return regeneratorRuntime.wrap(function Ref$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            if (!names.has(schema.$ref)) {
              _context14.next = 4;
              break;
            }

            _context14.next = 3;
            return "(".concat(CreateFunctionName(schema.$ref), "(").concat(value, "))");

          case 3:
            return _context14.abrupt("return", _context14.sent);

          case 4:
            if (referenceMap.has(schema.$ref)) {
              _context14.next = 6;
              break;
            }

            throw Error("TypeCompiler.Ref: Cannot de-reference schema with $id '".concat(schema.$ref, "'"));

          case 6:
            reference = referenceMap.get(schema.$ref);
            return _context14.delegateYield(Visit(reference, value), "t0", 8);

          case 8:
          case "end":
            return _context14.stop();
        }
      }
    }, _marked14);
  }

  function Self(schema, value) {
    var func;
    return regeneratorRuntime.wrap(function Self$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            func = CreateFunctionName(schema.$ref);
            _context15.next = 3;
            return "(".concat(func, "(").concat(value, "))");

          case 3:
          case "end":
            return _context15.stop();
        }
      }
    }, _marked15);
  }

  function String(schema, value) {
    var local;
    return regeneratorRuntime.wrap(function String$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            _context16.next = 2;
            return "(typeof ".concat(value, " === 'string')");

          case 2:
            if (!(schema.minLength !== undefined)) {
              _context16.next = 5;
              break;
            }

            _context16.next = 5;
            return "(".concat(value, ".length >= ").concat(schema.minLength, ")");

          case 5:
            if (!(schema.maxLength !== undefined)) {
              _context16.next = 8;
              break;
            }

            _context16.next = 8;
            return "(".concat(value, ".length <= ").concat(schema.maxLength, ")");

          case 8:
            if (!(schema.pattern !== undefined)) {
              _context16.next = 12;
              break;
            }

            local = PushLocal("new RegExp(/".concat(schema.pattern, "/);"));
            _context16.next = 12;
            return "(".concat(local, ".test(").concat(value, "))");

          case 12:
            if (!(schema.format !== undefined)) {
              _context16.next = 15;
              break;
            }

            _context16.next = 15;
            return "(format('".concat(schema.format, "', ").concat(value, "))");

          case 15:
          case "end":
            return _context16.stop();
        }
      }
    }, _marked16);
  }

  function Tuple(schema, value) {
    var i, expression;
    return regeneratorRuntime.wrap(function Tuple$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            _context17.next = 2;
            return "(Array.isArray(".concat(value, "))");

          case 2:
            if (!(schema.items === undefined)) {
              _context17.next = 6;
              break;
            }

            _context17.next = 5;
            return "(".concat(value, ".length === 0)");

          case 5:
            return _context17.abrupt("return", _context17.sent);

          case 6:
            _context17.next = 8;
            return "(".concat(value, ".length === ").concat(schema.maxItems, ")");

          case 8:
            i = 0;

          case 9:
            if (!(i < schema.items.length)) {
              _context17.next = 16;
              break;
            }

            expression = CreateExpression(schema.items[i], "".concat(value, "[").concat(i, "]"));
            _context17.next = 13;
            return "(".concat(expression, ")");

          case 13:
            i++;
            _context17.next = 9;
            break;

          case 16:
          case "end":
            return _context17.stop();
        }
      }
    }, _marked17);
  }

  function Undefined(schema, value) {
    return regeneratorRuntime.wrap(function Undefined$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            _context18.next = 2;
            return "(".concat(value, " === undefined)");

          case 2:
          case "end":
            return _context18.stop();
        }
      }
    }, _marked18);
  }

  function Union(schema, value) {
    var expressions;
    return regeneratorRuntime.wrap(function Union$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            expressions = schema.anyOf.map(function (schema) {
              return CreateExpression(schema, value);
            });
            _context19.next = 3;
            return "(".concat(expressions.join(' || '), ")");

          case 3:
          case "end":
            return _context19.stop();
        }
      }
    }, _marked19);
  }

  function Uint8Array(schema, value) {
    return regeneratorRuntime.wrap(function Uint8Array$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            _context20.next = 2;
            return "(".concat(value, " instanceof Uint8Array)");

          case 2:
            if (!schema.maxByteLength) {
              _context20.next = 5;
              break;
            }

            _context20.next = 5;
            return "(".concat(value, ".length <= ").concat(schema.maxByteLength, ")");

          case 5:
            if (!schema.minByteLength) {
              _context20.next = 8;
              break;
            }

            _context20.next = 8;
            return "(".concat(value, ".length >= ").concat(schema.minByteLength, ")");

          case 8:
          case "end":
            return _context20.stop();
        }
      }
    }, _marked20);
  }

  function Unknown(schema, value) {
    return regeneratorRuntime.wrap(function Unknown$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            _context21.next = 2;
            return '(true)';

          case 2:
          case "end":
            return _context21.stop();
        }
      }
    }, _marked21);
  }

  function Void(schema, value) {
    return regeneratorRuntime.wrap(function Void$(_context22) {
      while (1) {
        switch (_context22.prev = _context22.next) {
          case 0:
            _context22.next = 2;
            return "(".concat(value, " === null)");

          case 2:
          case "end":
            return _context22.stop();
        }
      }
    }, _marked22);
  }

  function Visit(schema, value) {
    var name, body, anySchema;
    return regeneratorRuntime.wrap(function Visit$(_context23) {
      while (1) {
        switch (_context23.prev = _context23.next) {
          case 0:
            if (!(schema.$id && !names.has(schema.$id))) {
              _context23.next = 8;
              break;
            }

            names.add(schema.$id);
            name = CreateFunctionName(schema.$id);
            body = CreateFunction(name, schema, 'value');
            PushFunction(body);
            _context23.next = 7;
            return "(".concat(name, "(").concat(value, "))");

          case 7:
            return _context23.abrupt("return");

          case 8:
            anySchema = schema;
            _context23.t0 = anySchema[Types.Kind];
            _context23.next = _context23.t0 === 'Any' ? 12 : _context23.t0 === 'Array' ? 14 : _context23.t0 === 'Boolean' ? 16 : _context23.t0 === 'Constructor' ? 18 : _context23.t0 === 'Function' ? 20 : _context23.t0 === 'Integer' ? 22 : _context23.t0 === 'Literal' ? 24 : _context23.t0 === 'Never' ? 26 : _context23.t0 === 'Null' ? 28 : _context23.t0 === 'Number' ? 30 : _context23.t0 === 'Object' ? 32 : _context23.t0 === 'Promise' ? 34 : _context23.t0 === 'Record' ? 36 : _context23.t0 === 'Ref' ? 38 : _context23.t0 === 'Self' ? 40 : _context23.t0 === 'String' ? 42 : _context23.t0 === 'Tuple' ? 44 : _context23.t0 === 'Undefined' ? 46 : _context23.t0 === 'Union' ? 48 : _context23.t0 === 'Uint8Array' ? 50 : _context23.t0 === 'Unknown' ? 52 : _context23.t0 === 'Void' ? 54 : 56;
            break;

          case 12:
            return _context23.delegateYield(Any(anySchema, value), "t1", 13);

          case 13:
            return _context23.abrupt("return", _context23.t1);

          case 14:
            return _context23.delegateYield(Array(anySchema, value), "t2", 15);

          case 15:
            return _context23.abrupt("return", _context23.t2);

          case 16:
            return _context23.delegateYield(Boolean(anySchema, value), "t3", 17);

          case 17:
            return _context23.abrupt("return", _context23.t3);

          case 18:
            return _context23.delegateYield(Constructor(anySchema, value), "t4", 19);

          case 19:
            return _context23.abrupt("return", _context23.t4);

          case 20:
            return _context23.delegateYield(Function(anySchema, value), "t5", 21);

          case 21:
            return _context23.abrupt("return", _context23.t5);

          case 22:
            return _context23.delegateYield(Integer(anySchema, value), "t6", 23);

          case 23:
            return _context23.abrupt("return", _context23.t6);

          case 24:
            return _context23.delegateYield(Literal(anySchema, value), "t7", 25);

          case 25:
            return _context23.abrupt("return", _context23.t7);

          case 26:
            return _context23.delegateYield(Never(anySchema, value), "t8", 27);

          case 27:
            return _context23.abrupt("return", _context23.t8);

          case 28:
            return _context23.delegateYield(Null(anySchema, value), "t9", 29);

          case 29:
            return _context23.abrupt("return", _context23.t9);

          case 30:
            return _context23.delegateYield(Number(anySchema, value), "t10", 31);

          case 31:
            return _context23.abrupt("return", _context23.t10);

          case 32:
            return _context23.delegateYield(Object(anySchema, value), "t11", 33);

          case 33:
            return _context23.abrupt("return", _context23.t11);

          case 34:
            return _context23.delegateYield(Promise(anySchema, value), "t12", 35);

          case 35:
            return _context23.abrupt("return", _context23.t12);

          case 36:
            return _context23.delegateYield(Record(anySchema, value), "t13", 37);

          case 37:
            return _context23.abrupt("return", _context23.t13);

          case 38:
            return _context23.delegateYield(Ref(anySchema, value), "t14", 39);

          case 39:
            return _context23.abrupt("return", _context23.t14);

          case 40:
            return _context23.delegateYield(Self(anySchema, value), "t15", 41);

          case 41:
            return _context23.abrupt("return", _context23.t15);

          case 42:
            return _context23.delegateYield(String(anySchema, value), "t16", 43);

          case 43:
            return _context23.abrupt("return", _context23.t16);

          case 44:
            return _context23.delegateYield(Tuple(anySchema, value), "t17", 45);

          case 45:
            return _context23.abrupt("return", _context23.t17);

          case 46:
            return _context23.delegateYield(Undefined(anySchema, value), "t18", 47);

          case 47:
            return _context23.abrupt("return", _context23.t18);

          case 48:
            return _context23.delegateYield(Union(anySchema, value), "t19", 49);

          case 49:
            return _context23.abrupt("return", _context23.t19);

          case 50:
            return _context23.delegateYield(Uint8Array(anySchema, value), "t20", 51);

          case 51:
            return _context23.abrupt("return", _context23.t20);

          case 52:
            return _context23.delegateYield(Unknown(anySchema, value), "t21", 53);

          case 53:
            return _context23.abrupt("return", _context23.t21);

          case 54:
            return _context23.delegateYield(Void(anySchema, value), "t22", 55);

          case 55:
            return _context23.abrupt("return", _context23.t22);

          case 56:
            throw new TypeCompilerUnknownTypeError(schema);

          case 57:
          case "end":
            return _context23.stop();
        }
      }
    }, _marked23);
  } // -------------------------------------------------------------------
  // Compile State
  // -------------------------------------------------------------------


  var referenceMap = new Map();
  var locals = new Set(); // local variables and functions

  var names = new Set(); // cache of local functions

  function ResetCompiler() {
    referenceMap.clear();
    locals.clear();
    names.clear();
  }

  function AddReferences() {
    var schemas = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = schemas[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var schema = _step2.value;
        if (!schema.$id) throw new Error("TypeCompiler: Referenced schemas must specify an $id.");
        if (referenceMap.has(schema.$id)) throw new Error("TypeCompiler: Duplicate schema $id found for '".concat(schema.$id, "'"));
        referenceMap.set(schema.$id, schema);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  function CreateExpression(schema, value) {
    return _toConsumableArray(Visit(schema, value)).join(' && ');
  }

  function CreateFunctionName($id) {
    return "check_".concat($id.replace(/-/g, '_'));
  }

  function CreateFunction(name, schema, value) {
    var expression = _toConsumableArray(Visit(schema, value)).map(function (condition) {
      return "    ".concat(condition);
    }).join(' &&\n');

    return "function ".concat(name, "(value) {\n  return (\n").concat(expression, "\n )\n}");
  }

  function PushFunction(functionBody) {
    locals.add(functionBody);
  }

  function PushLocal(expression) {
    var local = "local_".concat(locals.size);
    locals.add("const ".concat(local, " = ").concat(expression));
    return local;
  }

  function GetLocals() {
    return _toConsumableArray(locals.values());
  } // -------------------------------------------------------------------
  // Compile
  // -------------------------------------------------------------------


  function Build(schema) {
    var references = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    ResetCompiler();
    AddReferences(references);
    var check = CreateFunction('check', schema, 'value');
    var locals = GetLocals();
    return "".concat(locals.join('\n'), "\nreturn ").concat(check);
  }
  /** Compiles the given type for runtime type checking. This compiler only accepts known TypeBox types non-inclusive of unsafe types. */


  function Compile(schema) {
    var references = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    index_2.TypeGuard.Assert(schema, references);
    var code = Build(schema, references);
    var func1 = globalThis.Function('format', code);
    var func2 = func1(function (format, value) {
      if (!index_3.Format.Has(format)) return false;
      var func = index_3.Format.Get(format);
      return func(value);
    });
    return new TypeCheck(schema, references, func2, code);
  }

  TypeCompiler.Compile = Compile;
})(TypeCompiler = exports.TypeCompiler || (exports.TypeCompiler = {}));