"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/**
 * @param {object} exports
 * @param {Set<string>} keys
 */
function loop(exports, keys) {
  if (typeof exports === 'string') {
    return exports;
  }

  if (exports) {
    var idx, tmp;

    if (Array.isArray(exports)) {
      for (idx = 0; idx < exports.length; idx++) {
        if (tmp = loop(exports[idx], keys)) return tmp;
      }
    } else {
      for (idx in exports) {
        if (keys.has(idx)) {
          return loop(exports[idx], keys);
        }
      }
    }
  }
}
/**
 * @param {string} name The package name
 * @param {string} entry The target entry, eg "."
 * @param {number} [condition] Unmatched condition?
 */


function bail(name, entry, condition) {
  throw new Error(condition ? "No known conditions for \"".concat(entry, "\" entry in \"").concat(name, "\" package") : "Missing \"".concat(entry, "\" export in \"").concat(name, "\" package"));
}
/**
 * @param {string} name the package name
 * @param {string} entry the target path/import
 */


function toName(name, entry) {
  return entry === name ? '.' : entry[0] === '.' ? entry : entry.replace(new RegExp('^' + name + '\/'), './');
}
/**
 * @param {object} pkg package.json contents
 * @param {string} [entry] entry name or import path
 * @param {object} [options]
 * @param {boolean} [options.browser]
 * @param {boolean} [options.require]
 * @param {string[]} [options.conditions]
 * @param {boolean} [options.unsafe]
 */


function resolve(pkg) {
  var entry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var name = pkg.name,
      exports = pkg.exports;

  if (exports) {
    var browser = options.browser,
        require = options.require,
        unsafe = options.unsafe,
        _options$conditions = options.conditions,
        conditions = _options$conditions === void 0 ? [] : _options$conditions;
    var target = toName(name, entry);
    if (target[0] !== '.') target = './' + target;

    if (typeof exports === 'string') {
      return target === '.' ? exports : bail(name, target);
    }

    var allows = new Set(['default'].concat(_toConsumableArray(conditions)));
    unsafe || allows.add(require ? 'require' : 'import');
    unsafe || allows.add(browser ? 'browser' : 'node');
    var key,
        tmp,
        isSingle = false;

    for (key in exports) {
      isSingle = key[0] !== '.';
      break;
    }

    if (isSingle) {
      return target === '.' ? loop(exports, allows) || bail(name, target, 1) : bail(name, target);
    }

    if (tmp = exports[target]) {
      return loop(tmp, allows) || bail(name, target, 1);
    }

    for (key in exports) {
      tmp = key[key.length - 1];

      if (tmp === '/' && target.startsWith(key)) {
        return (tmp = loop(exports[key], allows)) ? tmp + target.substring(key.length) : bail(name, target, 1);
      }

      if (tmp === '*' && target.startsWith(key.slice(0, -1))) {
        // do not trigger if no *content* to inject
        if (target.substring(key.length - 1).length > 0) {
          return (tmp = loop(exports[key], allows)) ? tmp.replace('*', target.substring(key.length - 1)) : bail(name, target, 1);
        }
      }
    }

    return bail(name, target);
  }
}
/**
 * @param {object} pkg
 * @param {object} [options]
 * @param {string|boolean} [options.browser]
 * @param {string[]} [options.fields]
 */


function legacy(pkg) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var i = 0,
      value,
      browser = options.browser,
      fields = options.fields || ['module', 'main'];

  if (browser && !fields.includes('browser')) {
    fields.unshift('browser');
  }

  for (; i < fields.length; i++) {
    if (value = pkg[fields[i]]) {
      if (typeof value == 'string') {//
      } else if (_typeof(value) == 'object' && fields[i] == 'browser') {
        if (typeof browser == 'string') {
          value = value[browser = toName(pkg.name, browser)];
          if (value == null) return browser;
        }
      } else {
        continue;
      }

      return typeof value == 'string' ? './' + value.replace(/^\.?\//, '') : value;
    }
  }
}

exports.legacy = legacy;
exports.resolve = resolve;