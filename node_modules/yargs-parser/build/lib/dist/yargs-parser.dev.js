"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.YargsParser = void 0;

var _tokenizeArgString = require("./tokenize-arg-string.js");

var _yargsParserTypes = require("./yargs-parser-types.js");

var _stringUtils = require("./string-utils.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var mixin;

var YargsParser =
/*#__PURE__*/
function () {
  function YargsParser(_mixin) {
    _classCallCheck(this, YargsParser);

    mixin = _mixin;
  }

  _createClass(YargsParser, [{
    key: "parse",
    value: function parse(argsInput, options) {
      var opts = Object.assign({
        alias: undefined,
        array: undefined,
        "boolean": undefined,
        config: undefined,
        configObjects: undefined,
        configuration: undefined,
        coerce: undefined,
        count: undefined,
        "default": undefined,
        envPrefix: undefined,
        narg: undefined,
        normalize: undefined,
        string: undefined,
        number: undefined,
        __: undefined,
        key: undefined
      }, options); // allow a string argument to be passed in rather
      // than an argv array.

      var args = (0, _tokenizeArgString.tokenizeArgString)(argsInput); // tokenizeArgString adds extra quotes to args if argsInput is a string
      // only strip those extra quotes in processValue if argsInput is a string

      var inputIsString = typeof argsInput === 'string'; // aliases might have transitive relationships, normalize this.

      var aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
      var configuration = Object.assign({
        'boolean-negation': true,
        'camel-case-expansion': true,
        'combine-arrays': false,
        'dot-notation': true,
        'duplicate-arguments-array': true,
        'flatten-duplicate-arrays': true,
        'greedy-arrays': true,
        'halt-at-non-option': false,
        'nargs-eats-options': false,
        'negation-prefix': 'no-',
        'parse-numbers': true,
        'parse-positional-numbers': true,
        'populate--': false,
        'set-placeholder-key': false,
        'short-option-groups': true,
        'strip-aliased': false,
        'strip-dashed': false,
        'unknown-options-as-args': false
      }, opts.configuration);
      var defaults = Object.assign(Object.create(null), opts["default"]);
      var configObjects = opts.configObjects || [];
      var envPrefix = opts.envPrefix;
      var notFlagsOption = configuration['populate--'];
      var notFlagsArgv = notFlagsOption ? '--' : '_';
      var newAliases = Object.create(null);
      var defaulted = Object.create(null); // allow a i18n handler to be passed in, default to a fake one (util.format).

      var __ = opts.__ || mixin.format;

      var flags = {
        aliases: Object.create(null),
        arrays: Object.create(null),
        bools: Object.create(null),
        strings: Object.create(null),
        numbers: Object.create(null),
        counts: Object.create(null),
        normalize: Object.create(null),
        configs: Object.create(null),
        nargs: Object.create(null),
        coercions: Object.create(null),
        keys: []
      };
      var negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
      var negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
      [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {
        var key = _typeof(opt) === 'object' ? opt.key : opt; // assign to flags[bools|strings|numbers]

        var assignment = Object.keys(opt).map(function (key) {
          var arrayFlagKeys = {
            "boolean": 'bools',
            string: 'strings',
            number: 'numbers'
          };
          return arrayFlagKeys[key];
        }).filter(Boolean).pop(); // assign key to be coerced

        if (assignment) {
          flags[assignment][key] = true;
        }

        flags.arrays[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts["boolean"] || []).filter(Boolean).forEach(function (key) {
        flags.bools[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.string || []).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.number || []).filter(Boolean).forEach(function (key) {
        flags.numbers[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.count || []).filter(Boolean).forEach(function (key) {
        flags.counts[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {
        flags.normalize[key] = true;
        flags.keys.push(key);
      });

      if (_typeof(opts.narg) === 'object') {
        Object.entries(opts.narg).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          if (typeof value === 'number') {
            flags.nargs[key] = value;
            flags.keys.push(key);
          }
        });
      }

      if (_typeof(opts.coerce) === 'object') {
        Object.entries(opts.coerce).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              key = _ref4[0],
              value = _ref4[1];

          if (typeof value === 'function') {
            flags.coercions[key] = value;
            flags.keys.push(key);
          }
        });
      }

      if (typeof opts.config !== 'undefined') {
        if (Array.isArray(opts.config) || typeof opts.config === 'string') {
          ;
          [].concat(opts.config).filter(Boolean).forEach(function (key) {
            flags.configs[key] = true;
          });
        } else if (_typeof(opts.config) === 'object') {
          Object.entries(opts.config).forEach(function (_ref5) {
            var _ref6 = _slicedToArray(_ref5, 2),
                key = _ref6[0],
                value = _ref6[1];

            if (typeof value === 'boolean' || typeof value === 'function') {
              flags.configs[key] = value;
            }
          });
        }
      } // create a lookup table that takes into account all
      // combinations of aliases: {f: ['foo'], foo: ['f']}


      extendAliases(opts.key, aliases, opts["default"], flags.arrays); // apply default values to all aliases.

      Object.keys(defaults).forEach(function (key) {
        (flags.aliases[key] || []).forEach(function (alias) {
          defaults[alias] = defaults[key];
        });
      });
      var error = null;
      checkConfiguration();
      var notFlags = [];
      var argv = Object.assign(Object.create(null), {
        _: []
      }); // TODO(bcoe): for the first pass at removing object prototype  we didn't
      // remove all prototypes from objects returned by this API, we might want
      // to gradually move towards doing so.

      var argvReturn = {};

      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        var truncatedArg = arg.replace(/^-{3,}/, '---');
        var broken = void 0;
        var key = void 0;
        var letters = void 0;
        var m = void 0;
        var next = void 0;
        var value = void 0; // any unknown option (except for end-of-options, "--")

        if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
          pushPositional(arg); // ---, ---=, ----, etc,
        } else if (truncatedArg.match(/^---+(=|$)/)) {
          // options without key name are invalid.
          pushPositional(arg);
          continue; // -- separated by =
        } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {
          // Using [\s\S] instead of . because js doesn't support the
          // 'dotall' regex modifier. See:
          // http://stackoverflow.com/a/1068308/13216
          m = arg.match(/^--?([^=]+)=([\s\S]*)$/); // arrays format = '--f=a b c'

          if (m !== null && Array.isArray(m) && m.length >= 3) {
            if (checkAllAliases(m[1], flags.arrays)) {
              i = eatArray(i, m[1], args, m[2]);
            } else if (checkAllAliases(m[1], flags.nargs) !== false) {
              // nargs format = '--f=monkey washing cat'
              i = eatNargs(i, m[1], args, m[2]);
            } else {
              setArg(m[1], m[2], true);
            }
          }
        } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
          m = arg.match(negatedBoolean);

          if (m !== null && Array.isArray(m) && m.length >= 2) {
            key = m[1];
            setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
          } // -- separated by space.

        } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {
          m = arg.match(/^--?(.+)/);

          if (m !== null && Array.isArray(m) && m.length >= 2) {
            key = m[1];

            if (checkAllAliases(key, flags.arrays)) {
              // array format = '--foo a b c'
              i = eatArray(i, key, args);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              // nargs format = '--foo a b c'
              // should be truthy even if: flags.nargs[key] === 0
              i = eatNargs(i, key, args);
            } else {
              next = args[i + 1];

              if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else if (/^(true|false)$/.test(next)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          } // dot-notation flag separated by '='.

        } else if (arg.match(/^-.\..+=/)) {
          m = arg.match(/^-([^=]+)=([\s\S]*)$/);

          if (m !== null && Array.isArray(m) && m.length >= 3) {
            setArg(m[1], m[2]);
          } // dot-notation flag separated by space.

        } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
          next = args[i + 1];
          m = arg.match(/^-(.\..+)/);

          if (m !== null && Array.isArray(m) && m.length >= 2) {
            key = m[1];

            if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
          letters = arg.slice(1, -1).split('');
          broken = false;

          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);

            if (letters[j + 1] && letters[j + 1] === '=') {
              value = arg.slice(j + 3);
              key = letters[j];

              if (checkAllAliases(key, flags.arrays)) {
                // array format = '-f=a b c'
                i = eatArray(i, key, args, value);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                // nargs format = '-f=monkey washing cat'
                i = eatNargs(i, key, args, value);
              } else {
                setArg(key, value);
              }

              broken = true;
              break;
            }

            if (next === '-') {
              setArg(letters[j], next);
              continue;
            } // current letter is an alphabetic character and next value is a number


            if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
              setArg(letters[j], next);
              broken = true;
              break;
            }

            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], next);
              broken = true;
              break;
            } else {
              setArg(letters[j], defaultValue(letters[j]));
            }
          }

          key = arg.slice(-1)[0];

          if (!broken && key !== '-') {
            if (checkAllAliases(key, flags.arrays)) {
              // array format = '-f a b c'
              i = eatArray(i, key, args);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              // nargs format = '-f a b c'
              // should be truthy even if: flags.nargs[key] === 0
              i = eatNargs(i, key, args);
            } else {
              next = args[i + 1];

              if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else if (/^(true|false)$/.test(next)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          }
        } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
          // single-digit boolean alias, e.g: xargs -0
          key = arg.slice(1);
          setArg(key, defaultValue(key));
        } else if (arg === '--') {
          notFlags = args.slice(i + 1);
          break;
        } else if (configuration['halt-at-non-option']) {
          notFlags = args.slice(i);
          break;
        } else {
          pushPositional(arg);
        }
      } // order of precedence:
      // 1. command line arg
      // 2. value from env var
      // 3. value from config file
      // 4. value from config objects
      // 5. configured default value


      applyEnvVars(argv, true); // special case: check env vars that point to config file

      applyEnvVars(argv, false);
      setConfig(argv);
      setConfigObjects();
      applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
      applyCoercions(argv);
      if (configuration['set-placeholder-key']) setPlaceholderKeys(argv); // for any counts either not in args or without an explicit default, set to 0

      Object.keys(flags.counts).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) setArg(key, 0);
      }); // '--' defaults to undefined.

      if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];
      notFlags.forEach(function (key) {
        argv[notFlagsArgv].push(key);
      });

      if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
        Object.keys(argv).filter(function (key) {
          return key !== '--' && key.includes('-');
        }).forEach(function (key) {
          delete argv[key];
        });
      }

      if (configuration['strip-aliased']) {
        var _ref7;

        ;

        (_ref7 = []).concat.apply(_ref7, _toConsumableArray(Object.keys(aliases).map(function (k) {
          return aliases[k];
        }))).forEach(function (alias) {
          if (configuration['camel-case-expansion'] && alias.includes('-')) {
            delete argv[alias.split('.').map(function (prop) {
              return (0, _stringUtils.camelCase)(prop);
            }).join('.')];
          }

          delete argv[alias];
        });
      } // Push argument into positional array, applying numeric coercion:


      function pushPositional(arg) {
        var maybeCoercedNumber = maybeCoerceNumber('_', arg);

        if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {
          argv._.push(maybeCoercedNumber);
        }
      } // how many arguments should we consume, based
      // on the nargs option?


      function eatNargs(i, key, args, argAfterEqualSign) {
        var ii;
        var toEat = checkAllAliases(key, flags.nargs); // NaN has a special meaning for the array type, indicating that one or
        // more values are expected.

        toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;

        if (toEat === 0) {
          if (!isUndefined(argAfterEqualSign)) {
            error = Error(__('Argument unexpected for: %s', key));
          }

          setArg(key, defaultValue(key));
          return i;
        }

        var available = isUndefined(argAfterEqualSign) ? 0 : 1;

        if (configuration['nargs-eats-options']) {
          // classic behavior, yargs eats positional and dash arguments.
          if (args.length - (i + 1) + available < toEat) {
            error = Error(__('Not enough arguments following: %s', key));
          }

          available = toEat;
        } else {
          // nargs will not consume flag arguments, e.g., -abc, --foo,
          // and terminates when one is observed.
          for (ii = i + 1; ii < args.length; ii++) {
            if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;else break;
          }

          if (available < toEat) error = Error(__('Not enough arguments following: %s', key));
        }

        var consumed = Math.min(available, toEat);

        if (!isUndefined(argAfterEqualSign) && consumed > 0) {
          setArg(key, argAfterEqualSign);
          consumed--;
        }

        for (ii = i + 1; ii < consumed + i + 1; ii++) {
          setArg(key, args[ii]);
        }

        return i + consumed;
      } // if an option is an array, eat all non-hyphenated arguments
      // following it... YUM!
      // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]


      function eatArray(i, key, args, argAfterEqualSign) {
        var argsToSet = [];
        var next = argAfterEqualSign || args[i + 1]; // If both array and nargs are configured, enforce the nargs count:

        var nargsCount = checkAllAliases(key, flags.nargs);

        if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
          argsToSet.push(true);
        } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
          // for keys without value ==> argsToSet remains an empty []
          // set user default value, if available
          if (defaults[key] !== undefined) {
            var defVal = defaults[key];
            argsToSet = Array.isArray(defVal) ? defVal : [defVal];
          }
        } else {
          // value in --option=value is eaten as is
          if (!isUndefined(argAfterEqualSign)) {
            argsToSet.push(processValue(key, argAfterEqualSign, true));
          }

          for (var ii = i + 1; ii < args.length; ii++) {
            if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount) break;
            next = args[ii];
            if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;
            i = ii;
            argsToSet.push(processValue(key, next, inputIsString));
          }
        } // If both array and nargs are configured, create an error if less than
        // nargs positionals were found. NaN has special meaning, indicating
        // that at least one value is required (more are okay).


        if (typeof nargsCount === 'number' && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
          error = Error(__('Not enough arguments following: %s', key));
        }

        setArg(key, argsToSet);
        return i;
      }

      function setArg(key, val) {
        var shouldStripQuotes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : inputIsString;

        if (/-/.test(key) && configuration['camel-case-expansion']) {
          var alias = key.split('.').map(function (prop) {
            return (0, _stringUtils.camelCase)(prop);
          }).join('.');
          addNewAlias(key, alias);
        }

        var value = processValue(key, val, shouldStripQuotes);
        var splitKey = key.split('.');
        setKey(argv, splitKey, value); // handle populating aliases of the full key

        if (flags.aliases[key]) {
          flags.aliases[key].forEach(function (x) {
            var keyProperties = x.split('.');
            setKey(argv, keyProperties, value);
          });
        } // handle populating aliases of the first element of the dot-notation key


        if (splitKey.length > 1 && configuration['dot-notation']) {
          ;
          (flags.aliases[splitKey[0]] || []).forEach(function (x) {
            var keyProperties = x.split('.'); // expand alias with nested objects in key

            var a = [].concat(splitKey);
            a.shift(); // nuke the old key.

            keyProperties = keyProperties.concat(a); // populate alias only if is not already an alias of the full key
            // (already populated above)

            if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {
              setKey(argv, keyProperties, value);
            }
          });
        } // Set normalize getter and setter when key is in 'normalize' but isn't an array


        if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
          var keys = [key].concat(flags.aliases[key] || []);
          keys.forEach(function (key) {
            Object.defineProperty(argvReturn, key, {
              enumerable: true,
              get: function get() {
                return val;
              },
              set: function set(value) {
                val = typeof value === 'string' ? mixin.normalize(value) : value;
              }
            });
          });
        }
      }

      function addNewAlias(key, alias) {
        if (!(flags.aliases[key] && flags.aliases[key].length)) {
          flags.aliases[key] = [alias];
          newAliases[alias] = true;
        }

        if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
          addNewAlias(alias, key);
        }
      }

      function processValue(key, val, shouldStripQuotes) {
        // strings may be quoted, clean this up as we assign values.
        if (shouldStripQuotes) {
          val = stripQuotes(val);
        } // handle parsing boolean arguments --foo=true --bar false.


        if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
          if (typeof val === 'string') val = val === 'true';
        }

        var value = Array.isArray(val) ? val.map(function (v) {
          return maybeCoerceNumber(key, v);
        }) : maybeCoerceNumber(key, val); // increment a count given as arg (either no value or value parsed as boolean)

        if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
          value = increment();
        } // Set normalized value when key is in 'normalize' and in 'arrays'


        if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
          if (Array.isArray(val)) value = val.map(function (val) {
            return mixin.normalize(val);
          });else value = mixin.normalize(val);
        }

        return value;
      }

      function maybeCoerceNumber(key, value) {
        if (!configuration['parse-positional-numbers'] && key === '_') return value;

        if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
          var shouldCoerceNumber = (0, _stringUtils.looksLikeNumber)(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat("".concat(value))));

          if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
            value = Number(value);
          }
        }

        return value;
      } // set args from config.json file, this should be
      // applied last so that defaults can be applied.


      function setConfig(argv) {
        var configLookup = Object.create(null); // expand defaults/aliases, in-case any happen to reference
        // the config.json file.

        applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
        Object.keys(flags.configs).forEach(function (configKey) {
          var configPath = argv[configKey] || configLookup[configKey];

          if (configPath) {
            try {
              var config = null;
              var resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
              var resolveConfig = flags.configs[configKey];

              if (typeof resolveConfig === 'function') {
                try {
                  config = resolveConfig(resolvedConfigPath);
                } catch (e) {
                  config = e;
                }

                if (config instanceof Error) {
                  error = config;
                  return;
                }
              } else {
                config = mixin.require(resolvedConfigPath);
              }

              setConfigObject(config);
            } catch (ex) {
              // Deno will receive a PermissionDenied error if an attempt is
              // made to load config without the --allow-read flag:
              if (ex.name === 'PermissionDenied') error = ex;else if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));
            }
          }
        });
      } // set args from config object.
      // it recursively checks nested objects.


      function setConfigObject(config, prev) {
        Object.keys(config).forEach(function (key) {
          var value = config[key];
          var fullKey = prev ? prev + '.' + key : key; // if the value is an inner object and we have dot-notation
          // enabled, treat inner objects in config the same as
          // heavily nested dot notations (foo.bar.apple).

          if (_typeof(value) === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
            // if the value is an object but not an array, check nested object
            setConfigObject(value, fullKey);
          } else {
            // setting arguments via CLI takes precedence over
            // values within the config file.
            if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {
              setArg(fullKey, value);
            }
          }
        });
      } // set all config objects passed in opts


      function setConfigObjects() {
        if (typeof configObjects !== 'undefined') {
          configObjects.forEach(function (configObject) {
            setConfigObject(configObject);
          });
        }
      }

      function applyEnvVars(argv, configOnly) {
        if (typeof envPrefix === 'undefined') return;
        var prefix = typeof envPrefix === 'string' ? envPrefix : '';
        var env = mixin.env();
        Object.keys(env).forEach(function (envVar) {
          if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
            // get array of nested keys and convert them to camel case
            var keys = envVar.split('__').map(function (key, i) {
              if (i === 0) {
                key = key.substring(prefix.length);
              }

              return (0, _stringUtils.camelCase)(key);
            });

            if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {
              setArg(keys.join('.'), env[envVar]);
            }
          }
        });
      }

      function applyCoercions(argv) {
        var coerce;
        var applied = new Set();
        Object.keys(argv).forEach(function (key) {
          if (!applied.has(key)) {
            // If we haven't already coerced this option via one of its aliases
            coerce = checkAllAliases(key, flags.coercions);

            if (typeof coerce === 'function') {
              try {
                var _value = maybeCoerceNumber(key, coerce(argv[key]));

                [].concat(flags.aliases[key] || [], key).forEach(function (ali) {
                  applied.add(ali);
                  argv[ali] = _value;
                });
              } catch (err) {
                error = err;
              }
            }
          }
        });
      }

      function setPlaceholderKeys(argv) {
        flags.keys.forEach(function (key) {
          // don't set placeholder keys for dot notation options 'foo.bar'.
          if (~key.indexOf('.')) return;
          if (typeof argv[key] === 'undefined') argv[key] = undefined;
        });
        return argv;
      }

      function applyDefaultsAndAliases(obj, aliases, defaults) {
        var canLog = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        Object.keys(defaults).forEach(function (key) {
          if (!hasKey(obj, key.split('.'))) {
            setKey(obj, key.split('.'), defaults[key]);
            if (canLog) defaulted[key] = true;
            (aliases[key] || []).forEach(function (x) {
              if (hasKey(obj, x.split('.'))) return;
              setKey(obj, x.split('.'), defaults[key]);
            });
          }
        });
      }

      function hasKey(obj, keys) {
        var o = obj;
        if (!configuration['dot-notation']) keys = [keys.join('.')];
        keys.slice(0, -1).forEach(function (key) {
          o = o[key] || {};
        });
        var key = keys[keys.length - 1];
        if (_typeof(o) !== 'object') return false;else return key in o;
      }

      function setKey(obj, keys, value) {
        var o = obj;
        if (!configuration['dot-notation']) keys = [keys.join('.')];
        keys.slice(0, -1).forEach(function (key) {
          // TODO(bcoe): in the next major version of yargs, switch to
          // Object.create(null) for dot notation:
          key = sanitizeKey(key);

          if (_typeof(o) === 'object' && o[key] === undefined) {
            o[key] = {};
          }

          if (_typeof(o[key]) !== 'object' || Array.isArray(o[key])) {
            // ensure that o[key] is an array, and that the last item is an empty object.
            if (Array.isArray(o[key])) {
              o[key].push({});
            } else {
              o[key] = [o[key], {}];
            } // we want to update the empty object at the end of the o[key] array, so set o to that object


            o = o[key][o[key].length - 1];
          } else {
            o = o[key];
          }
        }); // TODO(bcoe): in the next major version of yargs, switch to
        // Object.create(null) for dot notation:

        var key = sanitizeKey(keys[keys.length - 1]);
        var isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
        var isValueArray = Array.isArray(value);
        var duplicate = configuration['duplicate-arguments-array']; // nargs has higher priority than duplicate

        if (!duplicate && checkAllAliases(key, flags.nargs)) {
          duplicate = true;

          if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
            o[key] = undefined;
          }
        }

        if (value === increment()) {
          o[key] = increment(o[key]);
        } else if (Array.isArray(o[key])) {
          if (duplicate && isTypeArray && isValueArray) {
            o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
          } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
            o[key] = value;
          } else {
            o[key] = o[key].concat([value]);
          }
        } else if (o[key] === undefined && isTypeArray) {
          o[key] = isValueArray ? value : [value];
        } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
          o[key] = [o[key], value];
        } else {
          o[key] = value;
        }
      } // extend the aliases list with inferred aliases.


      function extendAliases() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        args.forEach(function (obj) {
          Object.keys(obj || {}).forEach(function (key) {
            // short-circuit if we've already added a key
            // to the aliases array, for example it might
            // exist in both 'opts.default' and 'opts.key'.
            if (flags.aliases[key]) return;
            flags.aliases[key] = [].concat(aliases[key] || []); // For "--option-name", also set argv.optionName

            flags.aliases[key].concat(key).forEach(function (x) {
              if (/-/.test(x) && configuration['camel-case-expansion']) {
                var c = (0, _stringUtils.camelCase)(x);

                if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                  flags.aliases[key].push(c);
                  newAliases[c] = true;
                }
              }
            }); // For "--optionName", also set argv['option-name']

            flags.aliases[key].concat(key).forEach(function (x) {
              if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
                var c = (0, _stringUtils.decamelize)(x, '-');

                if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                  flags.aliases[key].push(c);
                  newAliases[c] = true;
                }
              }
            });
            flags.aliases[key].forEach(function (x) {
              flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
                return x !== y;
              }));
            });
          });
        });
      }

      function checkAllAliases(key, flag) {
        var toCheck = [].concat(flags.aliases[key] || [], key);
        var keys = Object.keys(flag);
        var setAlias = toCheck.find(function (key) {
          return keys.includes(key);
        });
        return setAlias ? flag[setAlias] : false;
      }

      function hasAnyFlag(key) {
        var flagsKeys = Object.keys(flags);
        var toCheck = [].concat(flagsKeys.map(function (k) {
          return flags[k];
        }));
        return toCheck.some(function (flag) {
          return Array.isArray(flag) ? flag.includes(key) : flag[key];
        });
      }

      function hasFlagsMatching(arg) {
        var _ref8;

        for (var _len2 = arguments.length, patterns = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          patterns[_key2 - 1] = arguments[_key2];
        }

        var toCheck = (_ref8 = []).concat.apply(_ref8, patterns);

        return toCheck.some(function (pattern) {
          var match = arg.match(pattern);
          return match && hasAnyFlag(match[1]);
        });
      } // based on a simplified version of the short flag group parsing logic


      function hasAllShortFlags(arg) {
        // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group
        if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
          return false;
        }

        var hasAllFlags = true;
        var next;
        var letters = arg.slice(1).split('');

        for (var _j = 0; _j < letters.length; _j++) {
          next = arg.slice(_j + 2);

          if (!hasAnyFlag(letters[_j])) {
            hasAllFlags = false;
            break;
          }

          if (letters[_j + 1] && letters[_j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[_j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[_j + 1] && letters[_j + 1].match(/\W/)) {
            break;
          }
        }

        return hasAllFlags;
      }

      function isUnknownOptionAsArg(arg) {
        return configuration['unknown-options-as-args'] && isUnknownOption(arg);
      }

      function isUnknownOption(arg) {
        arg = arg.replace(/^-{3,}/, '--'); // ignore negative numbers

        if (arg.match(negative)) {
          return false;
        } // if this is a short option group and all of them are configured, it isn't unknown


        if (hasAllShortFlags(arg)) {
          return false;
        } // e.g. '--count=2'


        var flagWithEquals = /^-+([^=]+?)=[\s\S]*$/; // e.g. '-a' or '--arg'

        var normalFlag = /^-+([^=]+?)$/; // e.g. '-a-'

        var flagEndingInHyphen = /^-+([^=]+?)-$/; // e.g. '-abc123'

        var flagEndingInDigits = /^-+([^=]+?\d+)$/; // e.g. '-a/usr/local'

        var flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/; // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method

        return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
      } // make a best effort to pick a default value
      // for an option based on name and type.


      function defaultValue(key) {
        if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && "".concat(key) in defaults) {
          return defaults[key];
        } else {
          return defaultForType(guessType(key));
        }
      } // return a default value, given the type of a flag.,


      function defaultForType(type) {
        var _def;

        var def = (_def = {}, _defineProperty(_def, _yargsParserTypes.DefaultValuesForTypeKey.BOOLEAN, true), _defineProperty(_def, _yargsParserTypes.DefaultValuesForTypeKey.STRING, ''), _defineProperty(_def, _yargsParserTypes.DefaultValuesForTypeKey.NUMBER, undefined), _defineProperty(_def, _yargsParserTypes.DefaultValuesForTypeKey.ARRAY, []), _def);
        return def[type];
      } // given a flag, enforce a default type.


      function guessType(key) {
        var type = _yargsParserTypes.DefaultValuesForTypeKey.BOOLEAN;
        if (checkAllAliases(key, flags.strings)) type = _yargsParserTypes.DefaultValuesForTypeKey.STRING;else if (checkAllAliases(key, flags.numbers)) type = _yargsParserTypes.DefaultValuesForTypeKey.NUMBER;else if (checkAllAliases(key, flags.bools)) type = _yargsParserTypes.DefaultValuesForTypeKey.BOOLEAN;else if (checkAllAliases(key, flags.arrays)) type = _yargsParserTypes.DefaultValuesForTypeKey.ARRAY;
        return type;
      }

      function isUndefined(num) {
        return num === undefined;
      } // check user configuration settings for inconsistencies


      function checkConfiguration() {
        // count keys should not be set as array/narg
        Object.keys(flags.counts).find(function (key) {
          if (checkAllAliases(key, flags.arrays)) {
            error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
            return true;
          } else if (checkAllAliases(key, flags.nargs)) {
            error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
            return true;
          }

          return false;
        });
      }

      return {
        aliases: Object.assign({}, flags.aliases),
        argv: Object.assign(argvReturn, argv),
        configuration: configuration,
        defaulted: Object.assign({}, defaulted),
        error: error,
        newAliases: Object.assign({}, newAliases)
      };
    }
  }]);

  return YargsParser;
}(); // if any aliases reference each other, we should
// merge them together.


exports.YargsParser = YargsParser;

function combineAliases(aliases) {
  var aliasArrays = [];
  var combined = Object.create(null);
  var change = true; // turn alias lookup hash {key: ['alias1', 'alias2']} into
  // a simple array ['key', 'alias1', 'alias2']

  Object.keys(aliases).forEach(function (key) {
    aliasArrays.push([].concat(aliases[key], key));
  }); // combine arrays until zero changes are
  // made in an iteration.

  while (change) {
    change = false;

    for (var i = 0; i < aliasArrays.length; i++) {
      var _loop = function _loop(ii) {
        var intersect = aliasArrays[i].filter(function (v) {
          return aliasArrays[ii].indexOf(v) !== -1;
        });

        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          return "break";
        }
      };

      for (var ii = i + 1; ii < aliasArrays.length; ii++) {
        var _ret = _loop(ii);

        if (_ret === "break") break;
      }
    }
  } // map arrays back to the hash-lookup (de-dupe while
  // we're at it).


  aliasArrays.forEach(function (aliasArray) {
    aliasArray = aliasArray.filter(function (v, i, self) {
      return self.indexOf(v) === i;
    });
    var lastAlias = aliasArray.pop();

    if (lastAlias !== undefined && typeof lastAlias === 'string') {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
} // this function should only be called when a count is given as an arg
// it is NOT called to set a default value
// thus we can start the count at 1 instead of 0


function increment(orig) {
  return orig !== undefined ? orig + 1 : 1;
} // TODO(bcoe): in the next major version of yargs, switch to
// Object.create(null) for dot notation:


function sanitizeKey(key) {
  if (key === '__proto__') return '___proto___';
  return key;
}

function stripQuotes(val) {
  return typeof val === 'string' && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
}