'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.runCLI = runCLI;

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _exit() {
  var data = _interopRequireDefault(require('exit'));

  _exit = function _exit() {
    return data;
  };

  return data;
}

function fs() {
  var data = _interopRequireWildcard(require('graceful-fs'));

  fs = function fs() {
    return data;
  };

  return data;
}

function _console() {
  var data = require('@jest/console');

  _console = function _console() {
    return data;
  };

  return data;
}

function _jestConfig() {
  var data = require('jest-config');

  _jestConfig = function _jestConfig() {
    return data;
  };

  return data;
}

function _jestRuntime() {
  var data = _interopRequireDefault(require('jest-runtime'));

  _jestRuntime = function _jestRuntime() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestWatcher() {
  var data = require('jest-watcher');

  _jestWatcher = function _jestWatcher() {
    return data;
  };

  return data;
}

var _collectHandles = require('../collectHandles');

var _getChangedFilesPromise = _interopRequireDefault(require('../getChangedFilesPromise'));

var _getConfigsOfProjectsToRun = _interopRequireDefault(require('../getConfigsOfProjectsToRun'));

var _getProjectNamesMissingWarning = _interopRequireDefault(require('../getProjectNamesMissingWarning'));

var _getSelectProjectsMessage = _interopRequireDefault(require('../getSelectProjectsMessage'));

var _createContext = _interopRequireDefault(require('../lib/createContext'));

var _handleDeprecationWarnings = _interopRequireDefault(require('../lib/handleDeprecationWarnings'));

var _logDebugMessages = _interopRequireDefault(require('../lib/logDebugMessages'));

var _pluralize = _interopRequireDefault(require('../pluralize'));

var _runJest = _interopRequireDefault(require('../runJest'));

var _watch = _interopRequireDefault(require('../watch'));

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== 'function') return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var preRunMessagePrint = _jestUtil().preRunMessage.print;

function runCLI(argv, projects) {
  var results, outputStream, _ref, globalConfig, configs, hasDeprecationWarnings, configsOfProjectsToRun, namesMissingWarning, _results, openHandles, formatted, openHandlesString, message;

  return regeneratorRuntime.async(function runCLI$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          // If we output a JSON object, we can't write anything to stdout, since
          // it'll break the JSON structure and it won't be valid.
          outputStream = argv.json || argv.useStderr ? process.stderr : process.stdout;
          _context.next = 3;
          return regeneratorRuntime.awrap((0, _jestConfig().readConfigs)(argv, projects));

        case 3:
          _ref = _context.sent;
          globalConfig = _ref.globalConfig;
          configs = _ref.configs;
          hasDeprecationWarnings = _ref.hasDeprecationWarnings;

          if (argv.debug) {
            (0, _logDebugMessages["default"])(globalConfig, configs, outputStream);
          }

          if (argv.showConfig) {
            (0, _logDebugMessages["default"])(globalConfig, configs, process.stdout);
            (0, _exit()["default"])(0);
          }

          if (argv.clearCache) {
            // stick in a Set to dedupe the deletions
            new Set(configs.map(function (config) {
              return config.cacheDirectory;
            })).forEach(function (cacheDirectory) {
              fs().rmSync(cacheDirectory, {
                force: true,
                recursive: true
              });
              process.stdout.write("Cleared ".concat(cacheDirectory, "\n"));
            });
            (0, _exit()["default"])(0);
          }

          configsOfProjectsToRun = (0, _getConfigsOfProjectsToRun["default"])(configs, {
            ignoreProjects: argv.ignoreProjects,
            selectProjects: argv.selectProjects
          });

          if (argv.selectProjects || argv.ignoreProjects) {
            namesMissingWarning = (0, _getProjectNamesMissingWarning["default"])(configs, {
              ignoreProjects: argv.ignoreProjects,
              selectProjects: argv.selectProjects
            });

            if (namesMissingWarning) {
              outputStream.write(namesMissingWarning);
            }

            outputStream.write((0, _getSelectProjectsMessage["default"])(configsOfProjectsToRun, {
              ignoreProjects: argv.ignoreProjects,
              selectProjects: argv.selectProjects
            }));
          }

          _context.next = 14;
          return regeneratorRuntime.awrap(_run10000(globalConfig, configsOfProjectsToRun, hasDeprecationWarnings, outputStream, function (r) {
            results = r;
          }));

        case 14:
          if (!(argv.watch || argv.watchAll)) {
            _context.next = 16;
            break;
          }

          return _context.abrupt("return", new Promise(function () {}));

        case 16:
          if (results) {
            _context.next = 18;
            break;
          }

          throw new Error('AggregatedResult must be present after test run is complete');

        case 18:
          _results = results, openHandles = _results.openHandles;

          if (openHandles && openHandles.length) {
            formatted = (0, _collectHandles.formatHandleErrors)(openHandles, configs[0]);
            openHandlesString = (0, _pluralize["default"])('open handle', formatted.length, 's');
            message = _chalk()["default"].red("\nJest has detected the following ".concat(openHandlesString, " potentially keeping Jest from exiting:\n\n")) + formatted.join('\n\n');
            console.error(message);
          }

          return _context.abrupt("return", {
            globalConfig: globalConfig,
            results: results
          });

        case 21:
        case "end":
          return _context.stop();
      }
    }
  });
}

var buildContextsAndHasteMaps = function buildContextsAndHasteMaps(configs, globalConfig, outputStream) {
  var hasteMapInstances, contexts;
  return regeneratorRuntime.async(function buildContextsAndHasteMaps$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          hasteMapInstances = Array(configs.length);
          _context3.next = 3;
          return regeneratorRuntime.awrap(Promise.all(configs.map(function _callee(config, index) {
            var hasteMapInstance;
            return regeneratorRuntime.async(function _callee$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    (0, _jestUtil().createDirectory)(config.cacheDirectory);
                    _context2.next = 3;
                    return regeneratorRuntime.awrap(_jestRuntime()["default"].createHasteMap(config, {
                      console: new (_console().CustomConsole)(outputStream, outputStream),
                      maxWorkers: Math.max(1, Math.floor(globalConfig.maxWorkers / configs.length)),
                      resetCache: !config.cache,
                      watch: globalConfig.watch || globalConfig.watchAll,
                      watchman: globalConfig.watchman
                    }));

                  case 3:
                    hasteMapInstance = _context2.sent;
                    hasteMapInstances[index] = hasteMapInstance;
                    _context2.t0 = (0, _createContext["default"]);
                    _context2.t1 = config;
                    _context2.next = 9;
                    return regeneratorRuntime.awrap(hasteMapInstance.build());

                  case 9:
                    _context2.t2 = _context2.sent;
                    return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2));

                  case 11:
                  case "end":
                    return _context2.stop();
                }
              }
            });
          })));

        case 3:
          contexts = _context3.sent;
          return _context3.abrupt("return", {
            contexts: contexts,
            hasteMapInstances: hasteMapInstances
          });

        case 5:
        case "end":
          return _context3.stop();
      }
    }
  });
};

var _run10000 = function _run10000(globalConfig, configs, hasDeprecationWarnings, outputStream, onComplete) {
  var changedFilesPromise, filter, rawFilter, filterSetupPromise, _ref2, contexts, hasteMapInstances;

  return regeneratorRuntime.async(function _run10000$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          // Queries to hg/git can take a while, so we need to start the process
          // as soon as possible, so by the time we need the result it's already there.
          changedFilesPromise = (0, _getChangedFilesPromise["default"])(globalConfig, configs); // Filter may need to do an HTTP call or something similar to setup.
          // We will wait on an async response from this before using the filter.

          if (globalConfig.filter && !globalConfig.skipFilter) {
            rawFilter = require(globalConfig.filter);

            if (rawFilter.setup) {
              // Wrap filter setup Promise to avoid "uncaught Promise" error.
              // If an error is returned, we surface it in the return value.
              filterSetupPromise = function _callee2() {
                return regeneratorRuntime.async(function _callee2$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.prev = 0;
                        _context4.next = 3;
                        return regeneratorRuntime.awrap(rawFilter.setup());

                      case 3:
                        _context4.next = 8;
                        break;

                      case 5:
                        _context4.prev = 5;
                        _context4.t0 = _context4["catch"](0);
                        return _context4.abrupt("return", _context4.t0);

                      case 8:
                        return _context4.abrupt("return", undefined);

                      case 9:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, null, null, [[0, 5]]);
              }();
            }

            filter = function filter(testPaths) {
              var err;
              return regeneratorRuntime.async(function filter$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      if (!filterSetupPromise) {
                        _context5.next = 6;
                        break;
                      }

                      _context5.next = 3;
                      return regeneratorRuntime.awrap(filterSetupPromise);

                    case 3:
                      err = _context5.sent;

                      if (!err) {
                        _context5.next = 6;
                        break;
                      }

                      throw err;

                    case 6:
                      return _context5.abrupt("return", rawFilter(testPaths));

                    case 7:
                    case "end":
                      return _context5.stop();
                  }
                }
              });
            };
          }

          _context6.next = 4;
          return regeneratorRuntime.awrap(buildContextsAndHasteMaps(configs, globalConfig, outputStream));

        case 4:
          _ref2 = _context6.sent;
          contexts = _ref2.contexts;
          hasteMapInstances = _ref2.hasteMapInstances;

          if (!(globalConfig.watch || globalConfig.watchAll)) {
            _context6.next = 12;
            break;
          }

          _context6.next = 10;
          return regeneratorRuntime.awrap(runWatch(contexts, configs, hasDeprecationWarnings, globalConfig, outputStream, hasteMapInstances, filter));

        case 10:
          _context6.next = 14;
          break;

        case 12:
          _context6.next = 14;
          return regeneratorRuntime.awrap(runWithoutWatch(globalConfig, contexts, outputStream, onComplete, changedFilesPromise, filter));

        case 14:
        case "end":
          return _context6.stop();
      }
    }
  });
};

var runWatch = function runWatch(contexts, _configs, hasDeprecationWarnings, globalConfig, outputStream, hasteMapInstances, filter) {
  return regeneratorRuntime.async(function runWatch$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          if (!hasDeprecationWarnings) {
            _context7.next = 10;
            break;
          }

          _context7.prev = 1;
          _context7.next = 4;
          return regeneratorRuntime.awrap((0, _handleDeprecationWarnings["default"])(outputStream, process.stdin));

        case 4:
          return _context7.abrupt("return", (0, _watch["default"])(globalConfig, contexts, outputStream, hasteMapInstances, undefined, undefined, filter));

        case 7:
          _context7.prev = 7;
          _context7.t0 = _context7["catch"](1);
          (0, _exit()["default"])(0);

        case 10:
          return _context7.abrupt("return", (0, _watch["default"])(globalConfig, contexts, outputStream, hasteMapInstances, undefined, undefined, filter));

        case 11:
        case "end":
          return _context7.stop();
      }
    }
  }, null, null, [[1, 7]]);
};

var runWithoutWatch = function runWithoutWatch(globalConfig, contexts, outputStream, onComplete, changedFilesPromise, filter) {
  var startRun;
  return regeneratorRuntime.async(function runWithoutWatch$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          startRun = function startRun() {
            return regeneratorRuntime.async(function startRun$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    if (!globalConfig.listTests) {
                      preRunMessagePrint(outputStream);
                    }

                    return _context8.abrupt("return", (0, _runJest["default"])({
                      changedFilesPromise: changedFilesPromise,
                      contexts: contexts,
                      failedTestsCache: undefined,
                      filter: filter,
                      globalConfig: globalConfig,
                      onComplete: onComplete,
                      outputStream: outputStream,
                      startRun: startRun,
                      testWatcher: new (_jestWatcher().TestWatcher)({
                        isWatchMode: false
                      })
                    }));

                  case 2:
                  case "end":
                    return _context8.stop();
                }
              }
            });
          };

          return _context9.abrupt("return", startRun());

        case 2:
        case "end":
          return _context9.stop();
      }
    }
  });
};