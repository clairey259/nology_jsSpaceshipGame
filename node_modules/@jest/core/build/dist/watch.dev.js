'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = watch;

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _ansiEscapes() {
  var data = _interopRequireDefault(require('ansi-escapes'));

  _ansiEscapes = function _ansiEscapes() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _exit() {
  var data = _interopRequireDefault(require('exit'));

  _exit = function _exit() {
    return data;
  };

  return data;
}

function _slash() {
  var data = _interopRequireDefault(require('slash'));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _jestMessageUtil() {
  var data = require('jest-message-util');

  _jestMessageUtil = function _jestMessageUtil() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestValidate() {
  var data = require('jest-validate');

  _jestValidate = function _jestValidate() {
    return data;
  };

  return data;
}

function _jestWatcher() {
  var data = require('jest-watcher');

  _jestWatcher = function _jestWatcher() {
    return data;
  };

  return data;
}

var _FailedTestsCache = _interopRequireDefault(require('./FailedTestsCache'));

var _SearchSource = _interopRequireDefault(require('./SearchSource'));

var _getChangedFilesPromise = _interopRequireDefault(require('./getChangedFilesPromise'));

var _activeFiltersMessage = _interopRequireDefault(require('./lib/activeFiltersMessage'));

var _createContext = _interopRequireDefault(require('./lib/createContext'));

var _isValidPath = _interopRequireDefault(require('./lib/isValidPath'));

var _updateGlobalConfig = _interopRequireDefault(require('./lib/updateGlobalConfig'));

var _watchPluginsHelpers = require('./lib/watchPluginsHelpers');

var _FailedTestsInteractive = _interopRequireDefault(require('./plugins/FailedTestsInteractive'));

var _Quit = _interopRequireDefault(require('./plugins/Quit'));

var _TestNamePattern = _interopRequireDefault(require('./plugins/TestNamePattern'));

var _TestPathPattern = _interopRequireDefault(require('./plugins/TestPathPattern'));

var _UpdateSnapshots = _interopRequireDefault(require('./plugins/UpdateSnapshots'));

var _UpdateSnapshotsInteractive = _interopRequireDefault(require('./plugins/UpdateSnapshotsInteractive'));

var _runJest = _interopRequireDefault(require('./runJest'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== 'function') return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var preRunMessagePrint = _jestUtil().preRunMessage.print;

var hasExitListener = false;
var INTERNAL_PLUGINS = [_FailedTestsInteractive["default"], _TestPathPattern["default"], _TestNamePattern["default"], _UpdateSnapshots["default"], _UpdateSnapshotsInteractive["default"], _Quit["default"]];
var RESERVED_KEY_PLUGINS = new Map([[_UpdateSnapshots["default"], {
  forbiddenOverwriteMessage: 'updating snapshots',
  key: 'u'
}], [_UpdateSnapshotsInteractive["default"], {
  forbiddenOverwriteMessage: 'updating snapshots interactively',
  key: 'i'
}], [_Quit["default"], {
  forbiddenOverwriteMessage: 'quitting watch mode'
}]]);

function watch(initialGlobalConfig, contexts, outputStream, hasteMapInstances) {
  var stdin,
      hooks,
      filter,
      globalConfig,
      activePlugin,
      updateConfigAndRun,
      watchPlugins,
      watchPluginKeys,
      _iteratorNormalCompletion,
      _didIteratorError,
      _iteratorError,
      _iterator,
      _step,
      plugin,
      reservedInfo,
      key,
      forbiddenOverwriteMessage,
      _iteratorNormalCompletion2,
      _didIteratorError2,
      _iteratorError2,
      _iterator2,
      _step2,
      pluginWithConfig,
      _plugin,
      ThirdPartyPlugin,
      errorWithContext,
      hookSubscriber,
      failedTestsCache,
      searchSources,
      isRunning,
      testWatcher,
      shouldDisplayWatchUsage,
      isWatchUsageDisplayed,
      emitFileChange,
      startRun,
      onKeypress,
      onCancelPatternPrompt,
      _args = arguments;

  return regeneratorRuntime.async(function watch$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          stdin = _args.length > 4 && _args[4] !== undefined ? _args[4] : process.stdin;
          hooks = _args.length > 5 && _args[5] !== undefined ? _args[5] : new (_jestWatcher().JestHook)();
          filter = _args.length > 6 ? _args[6] : undefined;
          // `globalConfig` will be constantly updated and reassigned as a result of
          // watch mode interactions.
          globalConfig = initialGlobalConfig;
          globalConfig = (0, _updateGlobalConfig["default"])(globalConfig, {
            mode: globalConfig.watch ? 'watch' : 'watchAll',
            passWithNoTests: true
          });

          updateConfigAndRun = function updateConfigAndRun() {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                bail = _ref.bail,
                changedSince = _ref.changedSince,
                collectCoverage = _ref.collectCoverage,
                collectCoverageFrom = _ref.collectCoverageFrom,
                coverageDirectory = _ref.coverageDirectory,
                coverageReporters = _ref.coverageReporters,
                findRelatedTests = _ref.findRelatedTests,
                mode = _ref.mode,
                nonFlagArgs = _ref.nonFlagArgs,
                notify = _ref.notify,
                notifyMode = _ref.notifyMode,
                onlyFailures = _ref.onlyFailures,
                reporters = _ref.reporters,
                testNamePattern = _ref.testNamePattern,
                testPathPattern = _ref.testPathPattern,
                updateSnapshot = _ref.updateSnapshot,
                verbose = _ref.verbose;

            var previousUpdateSnapshot = globalConfig.updateSnapshot;
            globalConfig = (0, _updateGlobalConfig["default"])(globalConfig, {
              bail: bail,
              changedSince: changedSince,
              collectCoverage: collectCoverage,
              collectCoverageFrom: collectCoverageFrom,
              coverageDirectory: coverageDirectory,
              coverageReporters: coverageReporters,
              findRelatedTests: findRelatedTests,
              mode: mode,
              nonFlagArgs: nonFlagArgs,
              notify: notify,
              notifyMode: notifyMode,
              onlyFailures: onlyFailures,
              reporters: reporters,
              testNamePattern: testNamePattern,
              testPathPattern: testPathPattern,
              updateSnapshot: updateSnapshot,
              verbose: verbose
            });
            startRun(globalConfig);
            globalConfig = (0, _updateGlobalConfig["default"])(globalConfig, {
              // updateSnapshot is not sticky after a run.
              updateSnapshot: previousUpdateSnapshot === 'all' ? 'none' : previousUpdateSnapshot
            });
          };

          watchPlugins = INTERNAL_PLUGINS.map(function (InternalPlugin) {
            return new InternalPlugin({
              stdin: stdin,
              stdout: outputStream
            });
          });
          watchPlugins.forEach(function (plugin) {
            var hookSubscriber = hooks.getSubscriber();

            if (plugin.apply) {
              plugin.apply(hookSubscriber);
            }
          });

          if (!(globalConfig.watchPlugins != null)) {
            _context.next = 81;
            break;
          }

          watchPluginKeys = new Map();
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 13;
          _iterator = watchPlugins[Symbol.iterator]();

        case 15:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 26;
            break;
          }

          plugin = _step.value;
          reservedInfo = RESERVED_KEY_PLUGINS.get(plugin.constructor) || {};
          key = reservedInfo.key || getPluginKey(plugin, globalConfig);

          if (key) {
            _context.next = 21;
            break;
          }

          return _context.abrupt("continue", 23);

        case 21:
          forbiddenOverwriteMessage = reservedInfo.forbiddenOverwriteMessage;
          watchPluginKeys.set(key, {
            forbiddenOverwriteMessage: forbiddenOverwriteMessage,
            overwritable: forbiddenOverwriteMessage == null,
            plugin: plugin
          });

        case 23:
          _iteratorNormalCompletion = true;
          _context.next = 15;
          break;

        case 26:
          _context.next = 32;
          break;

        case 28:
          _context.prev = 28;
          _context.t0 = _context["catch"](13);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 32:
          _context.prev = 32;
          _context.prev = 33;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 35:
          _context.prev = 35;

          if (!_didIteratorError) {
            _context.next = 38;
            break;
          }

          throw _iteratorError;

        case 38:
          return _context.finish(35);

        case 39:
          return _context.finish(32);

        case 40:
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context.prev = 43;
          _iterator2 = globalConfig.watchPlugins[Symbol.iterator]();

        case 45:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context.next = 67;
            break;
          }

          pluginWithConfig = _step2.value;
          _plugin = void 0;
          _context.prev = 48;
          _context.next = 51;
          return regeneratorRuntime.awrap((0, _jestUtil().requireOrImportModule)(pluginWithConfig.path));

        case 51:
          ThirdPartyPlugin = _context.sent;
          _plugin = new ThirdPartyPlugin({
            config: pluginWithConfig.config,
            stdin: stdin,
            stdout: outputStream
          });
          _context.next = 60;
          break;

        case 55:
          _context.prev = 55;
          _context.t1 = _context["catch"](48);
          errorWithContext = new Error("Failed to initialize watch plugin \"".concat(_chalk()["default"].bold((0, _slash()["default"])(path().relative(process.cwd(), pluginWithConfig.path))), "\":\n\n").concat((0, _jestMessageUtil().formatExecError)(_context.t1, contexts[0].config, {
            noStackTrace: false
          })));
          delete errorWithContext.stack;
          return _context.abrupt("return", Promise.reject(errorWithContext));

        case 60:
          checkForConflicts(watchPluginKeys, _plugin, globalConfig);
          hookSubscriber = hooks.getSubscriber();

          if (_plugin.apply) {
            _plugin.apply(hookSubscriber);
          }

          watchPlugins.push(_plugin);

        case 64:
          _iteratorNormalCompletion2 = true;
          _context.next = 45;
          break;

        case 67:
          _context.next = 73;
          break;

        case 69:
          _context.prev = 69;
          _context.t2 = _context["catch"](43);
          _didIteratorError2 = true;
          _iteratorError2 = _context.t2;

        case 73:
          _context.prev = 73;
          _context.prev = 74;

          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }

        case 76:
          _context.prev = 76;

          if (!_didIteratorError2) {
            _context.next = 79;
            break;
          }

          throw _iteratorError2;

        case 79:
          return _context.finish(76);

        case 80:
          return _context.finish(73);

        case 81:
          failedTestsCache = new _FailedTestsCache["default"]();
          searchSources = contexts.map(function (context) {
            return {
              context: context,
              searchSource: new _SearchSource["default"](context)
            };
          });
          isRunning = false;
          shouldDisplayWatchUsage = true;
          isWatchUsageDisplayed = false;

          emitFileChange = function emitFileChange() {
            if (hooks.isUsed('onFileChange')) {
              var projects = searchSources.map(function (_ref2) {
                var context = _ref2.context,
                    searchSource = _ref2.searchSource;
                return {
                  config: context.config,
                  testPaths: searchSource.findMatchingTests('').tests.map(function (t) {
                    return t.path;
                  })
                };
              });
              hooks.getEmitter().onFileChange({
                projects: projects
              });
            }
          };

          emitFileChange();
          hasteMapInstances.forEach(function (hasteMapInstance, index) {
            hasteMapInstance.on('change', function (_ref3) {
              var eventsQueue = _ref3.eventsQueue,
                  hasteFS = _ref3.hasteFS,
                  moduleMap = _ref3.moduleMap;
              var validPaths = eventsQueue.filter(function (_ref4) {
                var filePath = _ref4.filePath;
                return (0, _isValidPath["default"])(globalConfig, filePath);
              });

              if (validPaths.length) {
                var context = contexts[index] = (0, _createContext["default"])(contexts[index].config, {
                  hasteFS: hasteFS,
                  moduleMap: moduleMap
                });
                activePlugin = null;
                searchSources = searchSources.slice();
                searchSources[index] = {
                  context: context,
                  searchSource: new _SearchSource["default"](context)
                };
                emitFileChange();
                startRun(globalConfig);
              }
            });
          });

          if (!hasExitListener) {
            hasExitListener = true;
            process.on('exit', function () {
              if (activePlugin) {
                outputStream.write(_ansiEscapes()["default"].cursorDown());
                outputStream.write(_ansiEscapes()["default"].eraseDown);
              }
            });
          }

          startRun = function startRun(globalConfig) {
            if (isRunning) {
              return Promise.resolve(null);
            }

            testWatcher = new (_jestWatcher().TestWatcher)({
              isWatchMode: true
            });
            _jestUtil().isInteractive && outputStream.write(_jestUtil().specialChars.CLEAR);
            preRunMessagePrint(outputStream);
            isRunning = true;
            var configs = contexts.map(function (context) {
              return context.config;
            });
            var changedFilesPromise = (0, _getChangedFilesPromise["default"])(globalConfig, configs);
            return (0, _runJest["default"])({
              changedFilesPromise: changedFilesPromise,
              contexts: contexts,
              failedTestsCache: failedTestsCache,
              filter: filter,
              globalConfig: globalConfig,
              jestHooks: hooks.getEmitter(),
              onComplete: function onComplete(results) {
                isRunning = false;
                hooks.getEmitter().onTestRunComplete(results); // Create a new testWatcher instance so that re-runs won't be blocked.
                // The old instance that was passed to Jest will still be interrupted
                // and prevent test runs from the previous run.

                testWatcher = new (_jestWatcher().TestWatcher)({
                  isWatchMode: true
                }); // Do not show any Watch Usage related stuff when running in a
                // non-interactive environment

                if (_jestUtil().isInteractive) {
                  if (shouldDisplayWatchUsage) {
                    outputStream.write(usage(globalConfig, watchPlugins));
                    shouldDisplayWatchUsage = false; // hide Watch Usage after first run

                    isWatchUsageDisplayed = true;
                  } else {
                    outputStream.write(showToggleUsagePrompt());
                    shouldDisplayWatchUsage = false;
                    isWatchUsageDisplayed = false;
                  }
                } else {
                  outputStream.write('\n');
                }

                failedTestsCache.setTestResults(results.testResults);
              },
              outputStream: outputStream,
              startRun: startRun,
              testWatcher: testWatcher
            })["catch"](function (error // Errors thrown inside `runJest`, e.g. by resolvers, are caught here for
            ) {
              return (// continuous watch mode execution. We need to reprint them to the
                // terminal and give just a little bit of extra space so they fit below
                // `preRunMessagePrint` message nicely.
                console.error("\n\n".concat((0, _jestMessageUtil().formatExecError)(error, contexts[0].config, {
                  noStackTrace: false
                })))
              );
            });
          };

          onKeypress = function onKeypress(key) {
            if (key === _jestWatcher().KEYS.CONTROL_C || key === _jestWatcher().KEYS.CONTROL_D) {
              if (typeof stdin.setRawMode === 'function') {
                stdin.setRawMode(false);
              }

              outputStream.write('\n');
              (0, _exit()["default"])(0);
              return;
            }

            if (activePlugin != null && activePlugin.onKey) {
              // if a plugin is activate, Jest should let it handle keystrokes, so ignore
              // them here
              activePlugin.onKey(key);
              return;
            } // Abort test run


            var pluginKeys = (0, _watchPluginsHelpers.getSortedUsageRows)(watchPlugins, globalConfig).map(function (usage) {
              return Number(usage.key).toString(16);
            });

            if (isRunning && testWatcher && ['q', _jestWatcher().KEYS.ENTER, 'a', 'o', 'f'].concat(pluginKeys).includes(key)) {
              testWatcher.setState({
                interrupted: true
              });
              return;
            }

            var matchingWatchPlugin = (0, _watchPluginsHelpers.filterInteractivePlugins)(watchPlugins, globalConfig).find(function (plugin) {
              return getPluginKey(plugin, globalConfig) === key;
            });

            if (matchingWatchPlugin != null) {
              if (isRunning) {
                testWatcher.setState({
                  interrupted: true
                });
                return;
              } // "activate" the plugin, which has jest ignore keystrokes so the plugin
              // can handle them


              activePlugin = matchingWatchPlugin;

              if (activePlugin.run) {
                activePlugin.run(globalConfig, updateConfigAndRun).then(function (shouldRerun) {
                  activePlugin = null;

                  if (shouldRerun) {
                    updateConfigAndRun();
                  }
                }, function () {
                  activePlugin = null;
                  onCancelPatternPrompt();
                });
              } else {
                activePlugin = null;
              }
            }

            switch (key) {
              case _jestWatcher().KEYS.ENTER:
                startRun(globalConfig);
                break;

              case 'a':
                globalConfig = (0, _updateGlobalConfig["default"])(globalConfig, {
                  mode: 'watchAll',
                  testNamePattern: '',
                  testPathPattern: ''
                });
                startRun(globalConfig);
                break;

              case 'c':
                updateConfigAndRun({
                  mode: 'watch',
                  testNamePattern: '',
                  testPathPattern: ''
                });
                break;

              case 'f':
                globalConfig = (0, _updateGlobalConfig["default"])(globalConfig, {
                  onlyFailures: !globalConfig.onlyFailures
                });
                startRun(globalConfig);
                break;

              case 'o':
                globalConfig = (0, _updateGlobalConfig["default"])(globalConfig, {
                  mode: 'watch',
                  testNamePattern: '',
                  testPathPattern: ''
                });
                startRun(globalConfig);
                break;

              case '?':
                break;

              case 'w':
                if (!shouldDisplayWatchUsage && !isWatchUsageDisplayed) {
                  outputStream.write(_ansiEscapes()["default"].cursorUp());
                  outputStream.write(_ansiEscapes()["default"].eraseDown);
                  outputStream.write(usage(globalConfig, watchPlugins));
                  isWatchUsageDisplayed = true;
                  shouldDisplayWatchUsage = false;
                }

                break;
            }
          };

          onCancelPatternPrompt = function onCancelPatternPrompt() {
            outputStream.write(_ansiEscapes()["default"].cursorHide);
            outputStream.write(_jestUtil().specialChars.CLEAR);
            outputStream.write(usage(globalConfig, watchPlugins));
            outputStream.write(_ansiEscapes()["default"].cursorShow);
          };

          if (typeof stdin.setRawMode === 'function') {
            stdin.setRawMode(true);
            stdin.resume();
            stdin.setEncoding('utf8');
            stdin.on('data', onKeypress);
          }

          startRun(globalConfig);
          return _context.abrupt("return", Promise.resolve());

        case 96:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[13, 28, 32, 40], [33,, 35, 39], [43, 69, 73, 81], [48, 55], [74,, 76, 80]]);
}

var checkForConflicts = function checkForConflicts(watchPluginKeys, plugin, globalConfig) {
  var key = getPluginKey(plugin, globalConfig);

  if (!key) {
    return;
  }

  var conflictor = watchPluginKeys.get(key);

  if (!conflictor || conflictor.overwritable) {
    watchPluginKeys.set(key, {
      overwritable: false,
      plugin: plugin
    });
    return;
  }

  var error;

  if (conflictor.forbiddenOverwriteMessage) {
    error = "\n  Watch plugin ".concat(_chalk()["default"].bold.red(getPluginIdentifier(plugin)), " attempted to register key ").concat(_chalk()["default"].bold.red("<".concat(key, ">")), ",\n  that is reserved internally for ").concat(_chalk()["default"].bold.red(conflictor.forbiddenOverwriteMessage), ".\n  Please change the configuration key for this plugin.").trim();
  } else {
    var plugins = [conflictor.plugin, plugin].map(function (p) {
      return _chalk()["default"].bold.red(getPluginIdentifier(p));
    }).join(' and ');
    error = "\n  Watch plugins ".concat(plugins, " both attempted to register key ").concat(_chalk()["default"].bold.red("<".concat(key, ">")), ".\n  Please change the key configuration for one of the conflicting plugins to avoid overlap.").trim();
  }

  throw new (_jestValidate().ValidationError)('Watch plugin configuration error', error);
};

var getPluginIdentifier = function getPluginIdentifier(plugin // This breaks as `displayName` is not defined as a static, but since
) {
  return (// WatchPlugin is an interface, and it is my understanding interface
    // static fields are not definable anymore, no idea how to circumvent
    // this :-(
    // @ts-expect-error: leave `displayName` be.
    plugin.constructor.displayName || plugin.constructor.name
  );
};

var getPluginKey = function getPluginKey(plugin, globalConfig) {
  if (typeof plugin.getUsageInfo === 'function') {
    return (plugin.getUsageInfo(globalConfig) || {
      key: null
    }).key;
  }

  return null;
};

var usage = function usage(globalConfig, watchPlugins) {
  var delimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '\n';
  var messages = [(0, _activeFiltersMessage["default"])(globalConfig), globalConfig.testPathPattern || globalConfig.testNamePattern ? "".concat(_chalk()["default"].dim(" \u203A Press "), "c").concat(_chalk()["default"].dim(' to clear filters.')) : null, "\n".concat(_chalk()["default"].bold('Watch Usage')), globalConfig.watch ? "".concat(_chalk()["default"].dim(" \u203A Press "), "a").concat(_chalk()["default"].dim(' to run all tests.')) : null, globalConfig.onlyFailures ? "".concat(_chalk()["default"].dim(" \u203A Press "), "f").concat(_chalk()["default"].dim(' to quit "only failed tests" mode.')) : "".concat(_chalk()["default"].dim(" \u203A Press "), "f").concat(_chalk()["default"].dim(' to run only failed tests.')), (globalConfig.watchAll || globalConfig.testPathPattern || globalConfig.testNamePattern) && !globalConfig.noSCM ? "".concat(_chalk()["default"].dim(" \u203A Press "), "o").concat(_chalk()["default"].dim(' to only run tests related to changed files.')) : null].concat(_toConsumableArray((0, _watchPluginsHelpers.getSortedUsageRows)(watchPlugins, globalConfig).map(function (plugin) {
    return "".concat(_chalk()["default"].dim(" \u203A Press"), " ").concat(plugin.key, " ").concat(_chalk()["default"].dim("to ".concat(plugin.prompt, ".")));
  })), ["".concat(_chalk()["default"].dim(" \u203A Press "), "Enter").concat(_chalk()["default"].dim(' to trigger a test run.'))]);
  return "".concat(messages.filter(function (message) {
    return !!message;
  }).join(delimiter), "\n");
};

var showToggleUsagePrompt = function showToggleUsagePrompt() {
  return '\n' + "".concat(_chalk()["default"].bold('Watch Usage: ')).concat(_chalk()["default"].dim('Press '), "w").concat(_chalk()["default"].dim(' to show more.'));
};