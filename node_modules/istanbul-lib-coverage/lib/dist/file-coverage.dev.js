/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var percent = require('./percent');

var dataProperties = require('./data-properties');

var _require = require('./coverage-summary'),
    CoverageSummary = _require.CoverageSummary; // returns a data object that represents empty coverage


function emptyCoverage(filePath, reportLogic) {
  var cov = {
    path: filePath,
    statementMap: {},
    fnMap: {},
    branchMap: {},
    s: {},
    f: {},
    b: {}
  };
  if (reportLogic) cov.bT = {};
  return cov;
} // asserts that a data object "looks like" a coverage object


function assertValidObject(obj) {
  var valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;

  if (!valid) {
    throw new Error('Invalid file coverage object, missing keys, found:' + Object.keys(obj).join(','));
  }
}

var keyFromLoc = function keyFromLoc(_ref) {
  var start = _ref.start,
      end = _ref.end;
  return "".concat(start.line, "|").concat(start.column, "|").concat(end.line, "|").concat(end.column);
};

var mergeProp = function mergeProp(aHits, aMap, bHits, bMap) {
  var itemKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : keyFromLoc;
  var aItems = {};

  for (var _i = 0, _Object$entries = Object.entries(aHits); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        itemHits = _Object$entries$_i[1];

    var item = aMap[key];
    aItems[itemKey(item)] = [itemHits, item];
  }

  for (var _i2 = 0, _Object$entries2 = Object.entries(bHits); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        _key = _Object$entries2$_i[0],
        bItemHits = _Object$entries2$_i[1];

    var bItem = bMap[_key];
    var k = itemKey(bItem);

    if (aItems[k]) {
      (function () {
        var aPair = aItems[k];

        if (bItemHits.forEach) {
          // should this throw an exception if aPair[0] is not an array?
          bItemHits.forEach(function (hits, h) {
            if (aPair[0][h] !== undefined) aPair[0][h] += hits;else aPair[0][h] = hits;
          });
        } else {
          aPair[0] += bItemHits;
        }
      })();
    } else {
      aItems[k] = [bItemHits, bItem];
    }
  }

  var hits = {};
  var map = {};
  Object.values(aItems).forEach(function (_ref2, i) {
    var _ref3 = _slicedToArray(_ref2, 2),
        itemHits = _ref3[0],
        item = _ref3[1];

    hits[i] = itemHits;
    map[i] = item;
  });
  return [hits, map];
};
/**
 * provides a read-only view of coverage for a single file.
 * The deep structure of this object is documented elsewhere. It has the following
 * properties:
 *
 * * `path` - the file path for which coverage is being tracked
 * * `statementMap` - map of statement locations keyed by statement index
 * * `fnMap` - map of function metadata keyed by function index
 * * `branchMap` - map of branch metadata keyed by branch index
 * * `s` - hit counts for statements
 * * `f` - hit count for functions
 * * `b` - hit count for branches
 */


var FileCoverage =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Object|FileCoverage|String} pathOrObj is a string that initializes
   * and empty coverage object with the specified file path or a data object that
   * has all the required properties for a file coverage object.
   */
  function FileCoverage(pathOrObj) {
    var reportLogic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, FileCoverage);

    if (!pathOrObj) {
      throw new Error('Coverage must be initialized with a path or an object');
    }

    if (typeof pathOrObj === 'string') {
      this.data = emptyCoverage(pathOrObj, reportLogic);
    } else if (pathOrObj instanceof FileCoverage) {
      this.data = pathOrObj.data;
    } else if (_typeof(pathOrObj) === 'object') {
      this.data = pathOrObj;
    } else {
      throw new Error('Invalid argument to coverage constructor');
    }

    assertValidObject(this.data);
  }
  /**
   * returns computed line coverage from statement coverage.
   * This is a map of hits keyed by line number in the source.
   */


  _createClass(FileCoverage, [{
    key: "getLineCoverage",
    value: function getLineCoverage() {
      var statementMap = this.data.statementMap;
      var statements = this.data.s;
      var lineMap = Object.create(null);
      Object.entries(statements).forEach(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
            st = _ref5[0],
            count = _ref5[1];

        /* istanbul ignore if: is this even possible? */
        if (!statementMap[st]) {
          return;
        }

        var line = statementMap[st].start.line;
        var prevVal = lineMap[line];

        if (prevVal === undefined || prevVal < count) {
          lineMap[line] = count;
        }
      });
      return lineMap;
    }
    /**
     * returns an array of uncovered line numbers.
     * @returns {Array} an array of line numbers for which no hits have been
     *  collected.
     */

  }, {
    key: "getUncoveredLines",
    value: function getUncoveredLines() {
      var lc = this.getLineCoverage();
      var ret = [];
      Object.entries(lc).forEach(function (_ref6) {
        var _ref7 = _slicedToArray(_ref6, 2),
            l = _ref7[0],
            hits = _ref7[1];

        if (hits === 0) {
          ret.push(l);
        }
      });
      return ret;
    }
    /**
     * returns a map of branch coverage by source line number.
     * @returns {Object} an object keyed by line number. Each object
     * has a `covered`, `total` and `coverage` (percentage) property.
     */

  }, {
    key: "getBranchCoverageByLine",
    value: function getBranchCoverageByLine() {
      var branchMap = this.branchMap;
      var branches = this.b;
      var ret = {};
      Object.entries(branchMap).forEach(function (_ref8) {
        var _ret$line;

        var _ref9 = _slicedToArray(_ref8, 2),
            k = _ref9[0],
            map = _ref9[1];

        var line = map.line || map.loc.start.line;
        var branchData = branches[k];
        ret[line] = ret[line] || [];

        (_ret$line = ret[line]).push.apply(_ret$line, _toConsumableArray(branchData));
      });
      Object.entries(ret).forEach(function (_ref10) {
        var _ref11 = _slicedToArray(_ref10, 2),
            k = _ref11[0],
            dataArray = _ref11[1];

        var covered = dataArray.filter(function (item) {
          return item > 0;
        });
        var coverage = covered.length / dataArray.length * 100;
        ret[k] = {
          covered: covered.length,
          total: dataArray.length,
          coverage: coverage
        };
      });
      return ret;
    }
    /**
     * return a JSON-serializable POJO for this file coverage object
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
    /**
     * merges a second coverage object into this one, updating hit counts
     * @param {FileCoverage} other - the coverage object to be merged into this one.
     *  Note that the other object should have the same structure as this one (same file).
     */

  }, {
    key: "merge",
    value: function merge(other) {
      if (other.all === true) {
        return;
      }

      if (this.all === true) {
        this.data = other.data;
        return;
      }

      var _mergeProp = mergeProp(this.s, this.statementMap, other.s, other.statementMap),
          _mergeProp2 = _slicedToArray(_mergeProp, 2),
          hits = _mergeProp2[0],
          map = _mergeProp2[1];

      this.data.s = hits;
      this.data.statementMap = map;

      var keyFromLocProp = function keyFromLocProp(x) {
        return keyFromLoc(x.loc);
      };

      var keyFromLocationsProp = function keyFromLocationsProp(x) {
        return keyFromLoc(x.locations[0]);
      };

      var _mergeProp3 = mergeProp(this.f, this.fnMap, other.f, other.fnMap, keyFromLocProp);

      var _mergeProp4 = _slicedToArray(_mergeProp3, 2);

      hits = _mergeProp4[0];
      map = _mergeProp4[1];
      this.data.f = hits;
      this.data.fnMap = map;

      var _mergeProp5 = mergeProp(this.b, this.branchMap, other.b, other.branchMap, keyFromLocationsProp);

      var _mergeProp6 = _slicedToArray(_mergeProp5, 2);

      hits = _mergeProp6[0];
      map = _mergeProp6[1];
      this.data.b = hits;
      this.data.branchMap = map; // Tracking additional information about branch truthiness
      // can be optionally enabled:

      if (this.bT && other.bT) {
        var _mergeProp7 = mergeProp(this.bT, this.branchMap, other.bT, other.branchMap, keyFromLocationsProp);

        var _mergeProp8 = _slicedToArray(_mergeProp7, 2);

        hits = _mergeProp8[0];
        map = _mergeProp8[1];
        this.data.bT = hits;
      }
    }
  }, {
    key: "computeSimpleTotals",
    value: function computeSimpleTotals(property) {
      var stats = this[property];

      if (typeof stats === 'function') {
        stats = stats.call(this);
      }

      var ret = {
        total: Object.keys(stats).length,
        covered: Object.values(stats).filter(function (v) {
          return !!v;
        }).length,
        skipped: 0
      };
      ret.pct = percent(ret.covered, ret.total);
      return ret;
    }
  }, {
    key: "computeBranchTotals",
    value: function computeBranchTotals(property) {
      var stats = this[property];
      var ret = {
        total: 0,
        covered: 0,
        skipped: 0
      };
      Object.values(stats).forEach(function (branches) {
        ret.covered += branches.filter(function (hits) {
          return hits > 0;
        }).length;
        ret.total += branches.length;
      });
      ret.pct = percent(ret.covered, ret.total);
      return ret;
    }
    /**
     * resets hit counts for all statements, functions and branches
     * in this coverage object resulting in zero coverage.
     */

  }, {
    key: "resetHits",
    value: function resetHits() {
      var statements = this.s;
      var functions = this.f;
      var branches = this.b;
      var branchesTrue = this.bT;
      Object.keys(statements).forEach(function (s) {
        statements[s] = 0;
      });
      Object.keys(functions).forEach(function (f) {
        functions[f] = 0;
      });
      Object.keys(branches).forEach(function (b) {
        branches[b].fill(0);
      }); // Tracking additional information about branch truthiness
      // can be optionally enabled:

      if (branchesTrue) {
        Object.keys(branchesTrue).forEach(function (bT) {
          branchesTrue[bT].fill(0);
        });
      }
    }
    /**
     * returns a CoverageSummary for this file coverage object
     * @returns {CoverageSummary}
     */

  }, {
    key: "toSummary",
    value: function toSummary() {
      var ret = {};
      ret.lines = this.computeSimpleTotals('getLineCoverage');
      ret.functions = this.computeSimpleTotals('f', 'fnMap');
      ret.statements = this.computeSimpleTotals('s', 'statementMap');
      ret.branches = this.computeBranchTotals('b'); // Tracking additional information about branch truthiness
      // can be optionally enabled:

      if (this['bt']) {
        ret.branchesTrue = this.computeBranchTotals('bT');
      }

      return new CoverageSummary(ret);
    }
  }]);

  return FileCoverage;
}(); // expose coverage data attributes


dataProperties(FileCoverage, ['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b', 'bT', 'all']);
module.exports = {
  FileCoverage: FileCoverage
};