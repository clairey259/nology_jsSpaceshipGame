'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.runAndTransformResultsToJestFormat = exports.initialize = void 0;

var _expect = require('@jest/expect');

var _testResult = require('@jest/test-result');

var _jestMessageUtil = require('jest-message-util');

var _jestSnapshot = require('jest-snapshot');

var _ = _interopRequireDefault(require('..'));

var _run = _interopRequireDefault(require('../run'));

var _state = require('../state');

var _testCaseReportHandler = _interopRequireDefault(require('../testCaseReportHandler'));

var _utils = require('../utils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var initialize = function initialize(_ref) {
  var config, environment, globalConfig, localRequire, parentProcess, sendMessageToJest, setGlobalsForRuntime, testPath, globalsObject, runtimeGlobals, snapshotResolver, snapshotPath, snapshotState;
  return regeneratorRuntime.async(function initialize$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          config = _ref.config, environment = _ref.environment, globalConfig = _ref.globalConfig, localRequire = _ref.localRequire, parentProcess = _ref.parentProcess, sendMessageToJest = _ref.sendMessageToJest, setGlobalsForRuntime = _ref.setGlobalsForRuntime, testPath = _ref.testPath;

          if (globalConfig.testTimeout) {
            (0, _state.getState)().testTimeout = globalConfig.testTimeout;
          }

          (0, _state.getState)().maxConcurrency = globalConfig.maxConcurrency; // @ts-expect-error: missing `concurrent` which is added later

          globalsObject = _objectSpread({}, _["default"], {
            fdescribe: _["default"].describe.only,
            fit: _["default"].it.only,
            xdescribe: _["default"].describe.skip,
            xit: _["default"].it.skip,
            xtest: _["default"].it.skip
          });
          (0, _state.addEventHandler)(eventHandler);

          if (environment.handleTestEvent) {
            (0, _state.addEventHandler)(environment.handleTestEvent.bind(environment));
          }

          _expect.jestExpect.setState({
            expand: globalConfig.expand
          });

          runtimeGlobals = _objectSpread({}, globalsObject, {
            expect: _expect.jestExpect
          });
          setGlobalsForRuntime(runtimeGlobals);

          if (config.injectGlobals) {
            Object.assign(environment.global, runtimeGlobals);
          }

          _context.next = 12;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'setup',
            parentProcess: parentProcess,
            runtimeGlobals: runtimeGlobals,
            testNamePattern: globalConfig.testNamePattern
          }));

        case 12:
          if (!config.testLocationInResults) {
            _context.next = 15;
            break;
          }

          _context.next = 15;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'include_test_location_in_result'
          }));

        case 15:
          // Jest tests snapshotSerializers in order preceding built-in serializers.
          // Therefore, add in reverse because the last added is the first tested.
          config.snapshotSerializers.concat().reverse().forEach(function (path) {
            return (0, _jestSnapshot.addSerializer)(localRequire(path));
          });
          _context.next = 18;
          return regeneratorRuntime.awrap((0, _jestSnapshot.buildSnapshotResolver)(config, localRequire));

        case 18:
          snapshotResolver = _context.sent;
          snapshotPath = snapshotResolver.resolveSnapshotPath(testPath);
          snapshotState = new _jestSnapshot.SnapshotState(snapshotPath, {
            expand: globalConfig.expand,
            prettierPath: config.prettierPath,
            rootDir: config.rootDir,
            snapshotFormat: config.snapshotFormat,
            updateSnapshot: globalConfig.updateSnapshot
          });

          _expect.jestExpect.setState({
            snapshotState: snapshotState,
            testPath: testPath
          });

          (0, _state.addEventHandler)(handleSnapshotStateAfterRetry(snapshotState));

          if (sendMessageToJest) {
            (0, _state.addEventHandler)((0, _testCaseReportHandler["default"])(testPath, sendMessageToJest));
          } // Return it back to the outer scope (test runner outside the VM).


          return _context.abrupt("return", {
            globals: globalsObject,
            snapshotState: snapshotState
          });

        case 25:
        case "end":
          return _context.stop();
      }
    }
  });
};

exports.initialize = initialize;

var runAndTransformResultsToJestFormat = function runAndTransformResultsToJestFormat(_ref2) {
  var config, globalConfig, testPath, runResult, numFailingTests, numPassingTests, numPendingTests, numTodoTests, assertionResults, failureMessage, testExecError;
  return regeneratorRuntime.async(function runAndTransformResultsToJestFormat$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          config = _ref2.config, globalConfig = _ref2.globalConfig, testPath = _ref2.testPath;
          _context2.next = 3;
          return regeneratorRuntime.awrap((0, _run["default"])());

        case 3:
          runResult = _context2.sent;
          numFailingTests = 0;
          numPassingTests = 0;
          numPendingTests = 0;
          numTodoTests = 0;
          assertionResults = runResult.testResults.map(function (testResult) {
            var status;

            if (testResult.status === 'skip') {
              status = 'pending';
              numPendingTests += 1;
            } else if (testResult.status === 'todo') {
              status = 'todo';
              numTodoTests += 1;
            } else if (testResult.errors.length) {
              status = 'failed';
              numFailingTests += 1;
            } else {
              status = 'passed';
              numPassingTests += 1;
            }

            var ancestorTitles = testResult.testPath.filter(function (name) {
              return name !== _state.ROOT_DESCRIBE_BLOCK_NAME;
            });
            var title = ancestorTitles.pop();
            return {
              ancestorTitles: ancestorTitles,
              duration: testResult.duration,
              failureDetails: testResult.errorsDetailed,
              failureMessages: testResult.errors,
              fullName: title ? ancestorTitles.concat(title).join(' ') : ancestorTitles.join(' '),
              invocations: testResult.invocations,
              location: testResult.location,
              numPassingAsserts: 0,
              retryReasons: testResult.retryReasons,
              status: status,
              title: testResult.testPath[testResult.testPath.length - 1]
            };
          });
          failureMessage = (0, _jestMessageUtil.formatResultsErrors)(assertionResults, config, globalConfig, testPath);

          if (runResult.unhandledErrors.length) {
            testExecError = {
              message: '',
              stack: runResult.unhandledErrors.join('\n')
            };
            failureMessage = "".concat(failureMessage || '', "\n\n").concat(runResult.unhandledErrors.map(function (err) {
              return (0, _jestMessageUtil.formatExecError)(err, config, globalConfig);
            }).join('\n'));
          }

          _context2.next = 13;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'teardown'
          }));

        case 13:
          return _context2.abrupt("return", _objectSpread({}, (0, _testResult.createEmptyTestResult)(), {
            console: undefined,
            displayName: config.displayName,
            failureMessage: failureMessage,
            numFailingTests: numFailingTests,
            numPassingTests: numPassingTests,
            numPendingTests: numPendingTests,
            numTodoTests: numTodoTests,
            testExecError: testExecError,
            testFilePath: testPath,
            testResults: assertionResults
          }));

        case 14:
        case "end":
          return _context2.stop();
      }
    }
  });
};

exports.runAndTransformResultsToJestFormat = runAndTransformResultsToJestFormat;

var handleSnapshotStateAfterRetry = function handleSnapshotStateAfterRetry(snapshotState) {
  return function (event) {
    switch (event.name) {
      case 'test_retry':
        {
          // Clear any snapshot data that occurred in previous test run
          snapshotState.clear();
        }
    }
  };
};

var eventHandler = function eventHandler(event) {
  return regeneratorRuntime.async(function eventHandler$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.t0 = event.name;
          _context3.next = _context3.t0 === 'test_start' ? 3 : _context3.t0 === 'test_done' ? 5 : 8;
          break;

        case 3:
          _expect.jestExpect.setState({
            currentTestName: (0, _utils.getTestID)(event.test)
          });

          return _context3.abrupt("break", 8);

        case 5:
          _addSuppressedErrors(event.test);

          _addExpectedAssertionErrors(event.test);

          return _context3.abrupt("break", 8);

        case 8:
        case "end":
          return _context3.stop();
      }
    }
  });
};

var _addExpectedAssertionErrors = function _addExpectedAssertionErrors(test) {
  var failures = _expect.jestExpect.extractExpectedAssertionsErrors();

  var errors = failures.map(function (failure) {
    return failure.error;
  });
  test.errors = test.errors.concat(errors);
}; // Get suppressed errors from ``jest-matchers`` that weren't throw during
// test execution and add them to the test result, potentially failing
// a passing test.


var _addSuppressedErrors = function _addSuppressedErrors(test) {
  var _expect$jestExpect$ge = _expect.jestExpect.getState(),
      suppressedErrors = _expect$jestExpect$ge.suppressedErrors;

  _expect.jestExpect.setState({
    suppressedErrors: []
  });

  if (suppressedErrors.length) {
    test.errors = test.errors.concat(suppressedErrors);
  }
};