'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.describe = exports["default"] = exports.beforeEach = exports.beforeAll = exports.afterEach = exports.afterAll = void 0;
Object.defineProperty(exports, 'getState', {
  enumerable: true,
  get: function get() {
    return _state.getState;
  }
});
exports.it = void 0;
Object.defineProperty(exports, 'resetState', {
  enumerable: true,
  get: function get() {
    return _state.resetState;
  }
});
Object.defineProperty(exports, 'run', {
  enumerable: true,
  get: function get() {
    return _run["default"];
  }
});
Object.defineProperty(exports, 'setState', {
  enumerable: true,
  get: function get() {
    return _state.setState;
  }
});
exports.test = void 0;

var _jestEach = require('jest-each');

var _jestUtil = require('jest-util');

var _state = require('./state');

var _run = _interopRequireDefault(require('./run'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var describe = function () {
  var describe = function describe(blockName, blockFn) {
    return _dispatchDescribe(blockFn, blockName, describe);
  };

  var only = function only(blockName, blockFn) {
    return _dispatchDescribe(blockFn, blockName, only, 'only');
  };

  var skip = function skip(blockName, blockFn) {
    return _dispatchDescribe(blockFn, blockName, skip, 'skip');
  };

  describe.each = (0, _jestEach.bind)(describe, false);
  only.each = (0, _jestEach.bind)(only, false);
  skip.each = (0, _jestEach.bind)(skip, false);
  describe.only = only;
  describe.skip = skip;
  return describe;
}();

exports.describe = describe;

var _dispatchDescribe = function _dispatchDescribe(blockFn, blockName, describeFn, mode) {
  var asyncError = new _jestUtil.ErrorWithStack(undefined, describeFn);

  if (blockFn === undefined) {
    asyncError.message = 'Missing second argument. It must be a callback function.';
    throw asyncError;
  }

  if (typeof blockFn !== 'function') {
    asyncError.message = "Invalid second argument, ".concat(blockFn, ". It must be a callback function.");
    throw asyncError;
  }

  try {
    blockName = (0, _jestUtil.convertDescriptorToString)(blockName);
  } catch (error) {
    asyncError.message = error.message;
    throw asyncError;
  }

  (0, _state.dispatchSync)({
    asyncError: asyncError,
    blockName: blockName,
    mode: mode,
    name: 'start_describe_definition'
  });
  var describeReturn = blockFn();

  if ((0, _jestUtil.isPromise)(describeReturn)) {
    throw new _jestUtil.ErrorWithStack('Returning a Promise from "describe" is not supported. Tests must be defined synchronously.', describeFn);
  } else if (describeReturn !== undefined) {
    throw new _jestUtil.ErrorWithStack('A "describe" callback must not return a value.', describeFn);
  }

  (0, _state.dispatchSync)({
    blockName: blockName,
    mode: mode,
    name: 'finish_describe_definition'
  });
};

var _addHook = function _addHook(fn, hookType, hookFn, timeout) {
  var asyncError = new _jestUtil.ErrorWithStack(undefined, hookFn);

  if (typeof fn !== 'function') {
    asyncError.message = 'Invalid first argument. It must be a callback function.';
    throw asyncError;
  }

  (0, _state.dispatchSync)({
    asyncError: asyncError,
    fn: fn,
    hookType: hookType,
    name: 'add_hook',
    timeout: timeout
  });
}; // Hooks have to pass themselves to the HOF in order for us to trim stack traces.


var beforeEach = function beforeEach(fn, timeout) {
  return _addHook(fn, 'beforeEach', beforeEach, timeout);
};

exports.beforeEach = beforeEach;

var beforeAll = function beforeAll(fn, timeout) {
  return _addHook(fn, 'beforeAll', beforeAll, timeout);
};

exports.beforeAll = beforeAll;

var afterEach = function afterEach(fn, timeout) {
  return _addHook(fn, 'afterEach', afterEach, timeout);
};

exports.afterEach = afterEach;

var afterAll = function afterAll(fn, timeout) {
  return _addHook(fn, 'afterAll', afterAll, timeout);
};

exports.afterAll = afterAll;

var test = function () {
  var test = function test(testName, fn, timeout) {
    return _addTest(testName, undefined, false, fn, test, timeout);
  };

  var skip = function skip(testName, fn, timeout) {
    return _addTest(testName, 'skip', false, fn, skip, timeout);
  };

  var only = function only(testName, fn, timeout) {
    return _addTest(testName, 'only', false, fn, test.only, timeout);
  };

  var concurrentTest = function concurrentTest(testName, fn, timeout) {
    return _addTest(testName, undefined, true, fn, concurrentTest, timeout);
  };

  var concurrentOnly = function concurrentOnly(testName, fn, timeout) {
    return _addTest(testName, 'only', true, fn, concurrentOnly, timeout);
  };

  var bindFailing = function bindFailing(concurrent, mode) {
    var failing = function failing(testName, fn, timeout) {
      return _addTest(testName, mode, concurrent, fn, failing, timeout, true);
    };

    failing.each = (0, _jestEach.bind)(failing, false);
    return failing;
  };

  test.todo = function (testName) {
    if ((arguments.length <= 1 ? 0 : arguments.length - 1) > 0 || typeof testName !== 'string') {
      throw new _jestUtil.ErrorWithStack('Todo must be called with only a description.', test.todo);
    } // eslint-disable-next-line @typescript-eslint/no-empty-function


    return _addTest(testName, 'todo', false, function () {}, test.todo);
  };

  var _addTest = function _addTest(testName, mode, concurrent, fn, testFn, timeout, failing) {
    var asyncError = new _jestUtil.ErrorWithStack(undefined, testFn);

    try {
      testName = (0, _jestUtil.convertDescriptorToString)(testName);
    } catch (error) {
      asyncError.message = error.message;
      throw asyncError;
    }

    if (fn === undefined) {
      asyncError.message = 'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.';
      throw asyncError;
    }

    if (typeof fn !== 'function') {
      asyncError.message = "Invalid second argument, ".concat(fn, ". It must be a callback function.");
      throw asyncError;
    }

    return (0, _state.dispatchSync)({
      asyncError: asyncError,
      concurrent: concurrent,
      failing: failing === undefined ? false : failing,
      fn: fn,
      mode: mode,
      name: 'add_test',
      testName: testName,
      timeout: timeout
    });
  };

  test.each = (0, _jestEach.bind)(test);
  only.each = (0, _jestEach.bind)(only);
  skip.each = (0, _jestEach.bind)(skip);
  concurrentTest.each = (0, _jestEach.bind)(concurrentTest, false);
  concurrentOnly.each = (0, _jestEach.bind)(concurrentOnly, false);
  only.failing = bindFailing(false, 'only');
  skip.failing = bindFailing(false, 'skip');
  test.failing = bindFailing(false);
  test.only = only;
  test.skip = skip;
  test.concurrent = concurrentTest;
  concurrentTest.only = concurrentOnly;
  concurrentTest.skip = skip;
  concurrentTest.failing = bindFailing(true);
  concurrentOnly.failing = bindFailing(true, 'only');
  return test;
}();

exports.test = test;
var it = test;
exports.it = it;
var _default = {
  afterAll: afterAll,
  afterEach: afterEach,
  beforeAll: beforeAll,
  beforeEach: beforeEach,
  describe: describe,
  it: it,
  test: test
};
exports["default"] = _default;