'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

var _pLimit = _interopRequireDefault(require('p-limit'));

var _state = require('./state');

var _types = require('./types');

var _utils = require('./utils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var run = function run() {
  var _ref, rootDescribeBlock;

  return regeneratorRuntime.async(function run$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _ref = (0, _state.getState)(), rootDescribeBlock = _ref.rootDescribeBlock;
          _context.next = 3;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'run_start'
          }));

        case 3:
          _context.next = 5;
          return regeneratorRuntime.awrap(_runTestsForDescribeBlock(rootDescribeBlock, true));

        case 5:
          _context.next = 7;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'run_finish'
          }));

        case 7:
          return _context.abrupt("return", (0, _utils.makeRunResult)((0, _state.getState)().rootDescribeBlock, (0, _state.getState)().unhandledErrors));

        case 8:
        case "end":
          return _context.stop();
      }
    }
  });
};

var _runTestsForDescribeBlock = function _runTestsForDescribeBlock(describeBlock) {
  var isRootBlock,
      _ref2,
      beforeAll,
      afterAll,
      isSkipped,
      _iteratorNormalCompletion,
      _didIteratorError,
      _iteratorError,
      _iterator,
      _step,
      hook,
      concurrentTests,
      mutex,
      _iteratorNormalCompletion2,
      _didIteratorError2,
      _iteratorError2,
      _iterator2,
      _step2,
      test,
      retryTimes,
      deferredRetryTests,
      _iteratorNormalCompletion3,
      _didIteratorError3,
      _iteratorError3,
      _iterator3,
      _step3,
      child,
      hasErrorsBeforeTestRun,
      _i,
      _deferredRetryTests,
      _test,
      numRetriesAvailable,
      _iteratorNormalCompletion4,
      _didIteratorError4,
      _iteratorError4,
      _iterator4,
      _step4,
      _hook,
      _args2 = arguments;

  return regeneratorRuntime.async(function _runTestsForDescribeBlock$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          isRootBlock = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;
          _context2.next = 3;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            describeBlock: describeBlock,
            name: 'run_describe_start'
          }));

        case 3:
          _ref2 = (0, _utils.getAllHooksForDescribe)(describeBlock), beforeAll = _ref2.beforeAll, afterAll = _ref2.afterAll;
          isSkipped = describeBlock.mode === 'skip';

          if (isSkipped) {
            _context2.next = 32;
            break;
          }

          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context2.prev = 9;
          _iterator = beforeAll[Symbol.iterator]();

        case 11:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context2.next = 18;
            break;
          }

          hook = _step.value;
          _context2.next = 15;
          return regeneratorRuntime.awrap(_callCircusHook({
            describeBlock: describeBlock,
            hook: hook
          }));

        case 15:
          _iteratorNormalCompletion = true;
          _context2.next = 11;
          break;

        case 18:
          _context2.next = 24;
          break;

        case 20:
          _context2.prev = 20;
          _context2.t0 = _context2["catch"](9);
          _didIteratorError = true;
          _iteratorError = _context2.t0;

        case 24:
          _context2.prev = 24;
          _context2.prev = 25;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 27:
          _context2.prev = 27;

          if (!_didIteratorError) {
            _context2.next = 30;
            break;
          }

          throw _iteratorError;

        case 30:
          return _context2.finish(27);

        case 31:
          return _context2.finish(24);

        case 32:
          if (!isRootBlock) {
            _context2.next = 54;
            break;
          }

          concurrentTests = collectConcurrentTests(describeBlock);
          mutex = (0, _pLimit["default"])((0, _state.getState)().maxConcurrency);
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context2.prev = 38;

          for (_iterator2 = concurrentTests[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            test = _step2.value;

            try {
              (function () {
                var promise = mutex(test.fn); // Avoid triggering the uncaught promise rejection handler in case the
                // test errors before being awaited on.
                // eslint-disable-next-line @typescript-eslint/no-empty-function

                promise["catch"](function () {});

                test.fn = function () {
                  return promise;
                };
              })();
            } catch (err) {
              test.fn = function () {
                throw err;
              };
            }
          }

          _context2.next = 46;
          break;

        case 42:
          _context2.prev = 42;
          _context2.t1 = _context2["catch"](38);
          _didIteratorError2 = true;
          _iteratorError2 = _context2.t1;

        case 46:
          _context2.prev = 46;
          _context2.prev = 47;

          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }

        case 49:
          _context2.prev = 49;

          if (!_didIteratorError2) {
            _context2.next = 52;
            break;
          }

          throw _iteratorError2;

        case 52:
          return _context2.finish(49);

        case 53:
          return _context2.finish(46);

        case 54:
          // Tests that fail and are retried we run after other tests
          // eslint-disable-next-line no-restricted-globals
          retryTimes = parseInt(global[_types.RETRY_TIMES], 10) || 0;
          deferredRetryTests = [];
          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context2.prev = 59;
          _iterator3 = describeBlock.children[Symbol.iterator]();

        case 61:
          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
            _context2.next = 77;
            break;
          }

          child = _step3.value;
          _context2.t2 = child.type;
          _context2.next = _context2.t2 === 'describeBlock' ? 66 : _context2.t2 === 'test' ? 69 : 74;
          break;

        case 66:
          _context2.next = 68;
          return regeneratorRuntime.awrap(_runTestsForDescribeBlock(child));

        case 68:
          return _context2.abrupt("break", 74);

        case 69:
          hasErrorsBeforeTestRun = child.errors.length > 0;
          _context2.next = 72;
          return regeneratorRuntime.awrap(_runTest(child, isSkipped));

        case 72:
          if (hasErrorsBeforeTestRun === false && retryTimes > 0 && child.errors.length > 0) {
            deferredRetryTests.push(child);
          }

          return _context2.abrupt("break", 74);

        case 74:
          _iteratorNormalCompletion3 = true;
          _context2.next = 61;
          break;

        case 77:
          _context2.next = 83;
          break;

        case 79:
          _context2.prev = 79;
          _context2.t3 = _context2["catch"](59);
          _didIteratorError3 = true;
          _iteratorError3 = _context2.t3;

        case 83:
          _context2.prev = 83;
          _context2.prev = 84;

          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }

        case 86:
          _context2.prev = 86;

          if (!_didIteratorError3) {
            _context2.next = 89;
            break;
          }

          throw _iteratorError3;

        case 89:
          return _context2.finish(86);

        case 90:
          return _context2.finish(83);

        case 91:
          _i = 0, _deferredRetryTests = deferredRetryTests;

        case 92:
          if (!(_i < _deferredRetryTests.length)) {
            _context2.next = 106;
            break;
          }

          _test = _deferredRetryTests[_i];
          numRetriesAvailable = retryTimes;

        case 95:
          if (!(numRetriesAvailable > 0 && _test.errors.length > 0)) {
            _context2.next = 103;
            break;
          }

          _context2.next = 98;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'test_retry',
            test: _test
          }));

        case 98:
          _context2.next = 100;
          return regeneratorRuntime.awrap(_runTest(_test, isSkipped));

        case 100:
          numRetriesAvailable--;
          _context2.next = 95;
          break;

        case 103:
          _i++;
          _context2.next = 92;
          break;

        case 106:
          if (isSkipped) {
            _context2.next = 133;
            break;
          }

          _iteratorNormalCompletion4 = true;
          _didIteratorError4 = false;
          _iteratorError4 = undefined;
          _context2.prev = 110;
          _iterator4 = afterAll[Symbol.iterator]();

        case 112:
          if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
            _context2.next = 119;
            break;
          }

          _hook = _step4.value;
          _context2.next = 116;
          return regeneratorRuntime.awrap(_callCircusHook({
            describeBlock: describeBlock,
            hook: _hook
          }));

        case 116:
          _iteratorNormalCompletion4 = true;
          _context2.next = 112;
          break;

        case 119:
          _context2.next = 125;
          break;

        case 121:
          _context2.prev = 121;
          _context2.t4 = _context2["catch"](110);
          _didIteratorError4 = true;
          _iteratorError4 = _context2.t4;

        case 125:
          _context2.prev = 125;
          _context2.prev = 126;

          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }

        case 128:
          _context2.prev = 128;

          if (!_didIteratorError4) {
            _context2.next = 131;
            break;
          }

          throw _iteratorError4;

        case 131:
          return _context2.finish(128);

        case 132:
          return _context2.finish(125);

        case 133:
          _context2.next = 135;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            describeBlock: describeBlock,
            name: 'run_describe_finish'
          }));

        case 135:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[9, 20, 24, 32], [25,, 27, 31], [38, 42, 46, 54], [47,, 49, 53], [59, 79, 83, 91], [84,, 86, 90], [110, 121, 125, 133], [126,, 128, 132]]);
};

function collectConcurrentTests(describeBlock) {
  if (describeBlock.mode === 'skip') {
    return [];
  }

  var _ref3 = (0, _state.getState)(),
      hasFocusedTests = _ref3.hasFocusedTests,
      testNamePattern = _ref3.testNamePattern;

  return describeBlock.children.flatMap(function (child) {
    switch (child.type) {
      case 'describeBlock':
        return collectConcurrentTests(child);

      case 'test':
        var skip = !child.concurrent || child.mode === 'skip' || hasFocusedTests && child.mode !== 'only' || testNamePattern && !testNamePattern.test((0, _utils.getTestID)(child));
        return skip ? [] : [child];
    }
  });
}

var _runTest = function _runTest(test, parentSkipped) {
  var testContext, _ref4, hasFocusedTests, testNamePattern, isSkipped, _ref5, afterEach, beforeEach, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, hook, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, _hook2;

  return regeneratorRuntime.async(function _runTest$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'test_start',
            test: test
          }));

        case 2:
          testContext = Object.create(null);
          _ref4 = (0, _state.getState)(), hasFocusedTests = _ref4.hasFocusedTests, testNamePattern = _ref4.testNamePattern;
          isSkipped = parentSkipped || test.mode === 'skip' || hasFocusedTests && test.mode !== 'only' || testNamePattern && !testNamePattern.test((0, _utils.getTestID)(test));

          if (!isSkipped) {
            _context3.next = 9;
            break;
          }

          _context3.next = 8;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'test_skip',
            test: test
          }));

        case 8:
          return _context3.abrupt("return");

        case 9:
          if (!(test.mode === 'todo')) {
            _context3.next = 13;
            break;
          }

          _context3.next = 12;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'test_todo',
            test: test
          }));

        case 12:
          return _context3.abrupt("return");

        case 13:
          _ref5 = (0, _utils.getEachHooksForTest)(test), afterEach = _ref5.afterEach, beforeEach = _ref5.beforeEach;
          _iteratorNormalCompletion5 = true;
          _didIteratorError5 = false;
          _iteratorError5 = undefined;
          _context3.prev = 17;
          _iterator5 = beforeEach[Symbol.iterator]();

        case 19:
          if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
            _context3.next = 28;
            break;
          }

          hook = _step5.value;

          if (!test.errors.length) {
            _context3.next = 23;
            break;
          }

          return _context3.abrupt("break", 28);

        case 23:
          _context3.next = 25;
          return regeneratorRuntime.awrap(_callCircusHook({
            hook: hook,
            test: test,
            testContext: testContext
          }));

        case 25:
          _iteratorNormalCompletion5 = true;
          _context3.next = 19;
          break;

        case 28:
          _context3.next = 34;
          break;

        case 30:
          _context3.prev = 30;
          _context3.t0 = _context3["catch"](17);
          _didIteratorError5 = true;
          _iteratorError5 = _context3.t0;

        case 34:
          _context3.prev = 34;
          _context3.prev = 35;

          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }

        case 37:
          _context3.prev = 37;

          if (!_didIteratorError5) {
            _context3.next = 40;
            break;
          }

          throw _iteratorError5;

        case 40:
          return _context3.finish(37);

        case 41:
          return _context3.finish(34);

        case 42:
          _context3.next = 44;
          return regeneratorRuntime.awrap(_callCircusTest(test, testContext));

        case 44:
          _iteratorNormalCompletion6 = true;
          _didIteratorError6 = false;
          _iteratorError6 = undefined;
          _context3.prev = 47;
          _iterator6 = afterEach[Symbol.iterator]();

        case 49:
          if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
            _context3.next = 56;
            break;
          }

          _hook2 = _step6.value;
          _context3.next = 53;
          return regeneratorRuntime.awrap(_callCircusHook({
            hook: _hook2,
            test: test,
            testContext: testContext
          }));

        case 53:
          _iteratorNormalCompletion6 = true;
          _context3.next = 49;
          break;

        case 56:
          _context3.next = 62;
          break;

        case 58:
          _context3.prev = 58;
          _context3.t1 = _context3["catch"](47);
          _didIteratorError6 = true;
          _iteratorError6 = _context3.t1;

        case 62:
          _context3.prev = 62;
          _context3.prev = 63;

          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }

        case 65:
          _context3.prev = 65;

          if (!_didIteratorError6) {
            _context3.next = 68;
            break;
          }

          throw _iteratorError6;

        case 68:
          return _context3.finish(65);

        case 69:
          return _context3.finish(62);

        case 70:
          _context3.next = 72;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'test_done',
            test: test
          }));

        case 72:
        case "end":
          return _context3.stop();
      }
    }
  }, null, null, [[17, 30, 34, 42], [35,, 37, 41], [47, 58, 62, 70], [63,, 65, 69]]);
};

var _callCircusHook = function _callCircusHook(_ref6) {
  var hook, test, describeBlock, _ref6$testContext, testContext, timeout;

  return regeneratorRuntime.async(function _callCircusHook$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          hook = _ref6.hook, test = _ref6.test, describeBlock = _ref6.describeBlock, _ref6$testContext = _ref6.testContext, testContext = _ref6$testContext === void 0 ? {} : _ref6$testContext;
          _context4.next = 3;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            hook: hook,
            name: 'hook_start'
          }));

        case 3:
          timeout = hook.timeout || (0, _state.getState)().testTimeout;
          _context4.prev = 4;
          _context4.next = 7;
          return regeneratorRuntime.awrap((0, _utils.callAsyncCircusFn)(hook, testContext, {
            isHook: true,
            timeout: timeout
          }));

        case 7:
          _context4.next = 9;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            describeBlock: describeBlock,
            hook: hook,
            name: 'hook_success',
            test: test
          }));

        case 9:
          _context4.next = 15;
          break;

        case 11:
          _context4.prev = 11;
          _context4.t0 = _context4["catch"](4);
          _context4.next = 15;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            describeBlock: describeBlock,
            error: _context4.t0,
            hook: hook,
            name: 'hook_failure',
            test: test
          }));

        case 15:
        case "end":
          return _context4.stop();
      }
    }
  }, null, null, [[4, 11]]);
};

var _callCircusTest = function _callCircusTest(test, testContext) {
  var timeout;
  return regeneratorRuntime.async(function _callCircusTest$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'test_fn_start',
            test: test
          }));

        case 2:
          timeout = test.timeout || (0, _state.getState)().testTimeout;
          (0, _utils.invariant)(test.fn, "Tests with no 'fn' should have 'mode' set to 'skipped'");

          if (!test.errors.length) {
            _context5.next = 6;
            break;
          }

          return _context5.abrupt("return");

        case 6:
          _context5.prev = 6;
          _context5.next = 9;
          return regeneratorRuntime.awrap((0, _utils.callAsyncCircusFn)(test, testContext, {
            isHook: false,
            timeout: timeout
          }));

        case 9:
          if (!test.failing) {
            _context5.next = 15;
            break;
          }

          test.asyncError.message = 'Failing test passed even though it was supposed to fail. Remove `.failing` to remove error.';
          _context5.next = 13;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            error: test.asyncError,
            name: 'test_fn_failure',
            test: test
          }));

        case 13:
          _context5.next = 17;
          break;

        case 15:
          _context5.next = 17;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'test_fn_success',
            test: test
          }));

        case 17:
          _context5.next = 28;
          break;

        case 19:
          _context5.prev = 19;
          _context5.t0 = _context5["catch"](6);

          if (!test.failing) {
            _context5.next = 26;
            break;
          }

          _context5.next = 24;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            name: 'test_fn_success',
            test: test
          }));

        case 24:
          _context5.next = 28;
          break;

        case 26:
          _context5.next = 28;
          return regeneratorRuntime.awrap((0, _state.dispatch)({
            error: _context5.t0,
            name: 'test_fn_failure',
            test: test
          }));

        case 28:
        case "end":
          return _context5.stop();
      }
    }
  }, null, null, [[6, 19]]);
};

var _default = run;
exports["default"] = _default;