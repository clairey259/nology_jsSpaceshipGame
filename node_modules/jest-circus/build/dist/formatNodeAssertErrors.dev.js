'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

var _assert = require('assert');

var _chalk = _interopRequireDefault(require('chalk'));

var _jestMatcherUtils = require('jest-matcher-utils');

var _prettyFormat = require('pretty-format');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var assertOperatorsMap = {
  '!=': 'notEqual',
  '!==': 'notStrictEqual',
  '==': 'equal',
  '===': 'strictEqual'
};
var humanReadableOperators = {
  deepEqual: 'to deeply equal',
  deepStrictEqual: 'to deeply and strictly equal',
  equal: 'to be equal',
  notDeepEqual: 'not to deeply equal',
  notDeepStrictEqual: 'not to deeply and strictly equal',
  notEqual: 'to not be equal',
  notStrictEqual: 'not be strictly equal',
  strictEqual: 'to strictly be equal'
};

var formatNodeAssertErrors = function formatNodeAssertErrors(event, state) {
  if (event.name === 'test_done') {
    event.test.errors = event.test.errors.map(function (errors) {
      var error;

      if (Array.isArray(errors)) {
        var _errors = _slicedToArray(errors, 2),
            originalError = _errors[0],
            asyncError = _errors[1];

        if (originalError == null) {
          error = asyncError;
        } else if (!originalError.stack) {
          error = asyncError;
          error.message = originalError.message ? originalError.message : "thrown: ".concat((0, _prettyFormat.format)(originalError, {
            maxDepth: 3
          }));
        } else {
          error = originalError;
        }
      } else {
        error = errors;
      }

      return isAssertionError(error) ? {
        message: assertionErrorMessage(error, {
          expand: state.expand
        })
      } : errors;
    });
  }
};

var getOperatorName = function getOperatorName(operator, stack) {
  if (typeof operator === 'string') {
    return assertOperatorsMap[operator] || operator;
  }

  if (stack.match('.doesNotThrow')) {
    return 'doesNotThrow';
  }

  if (stack.match('.throws')) {
    return 'throws';
  }

  return '';
};

var operatorMessage = function operatorMessage(operator) {
  var niceOperatorName = getOperatorName(operator, '');
  var humanReadableOperator = humanReadableOperators[niceOperatorName];
  return typeof operator === 'string' ? "".concat(humanReadableOperator || niceOperatorName, " to:\n") : '';
};

var assertThrowingMatcherHint = function assertThrowingMatcherHint(operatorName) {
  return operatorName ? _chalk["default"].dim('assert') + _chalk["default"].dim(".".concat(operatorName, "(")) + _chalk["default"].red('function') + _chalk["default"].dim(')') : '';
};

var assertMatcherHint = function assertMatcherHint(operator, operatorName, expected) {
  var message = '';

  if (operator === '==' && expected === true) {
    message = _chalk["default"].dim('assert') + _chalk["default"].dim('(') + _chalk["default"].red('received') + _chalk["default"].dim(')');
  } else if (operatorName) {
    message = _chalk["default"].dim('assert') + _chalk["default"].dim(".".concat(operatorName, "(")) + _chalk["default"].red('received') + _chalk["default"].dim(', ') + _chalk["default"].green('expected') + _chalk["default"].dim(')');
  }

  return message;
};

function assertionErrorMessage(error, options) {
  var expected = error.expected,
      actual = error.actual,
      generatedMessage = error.generatedMessage,
      message = error.message,
      operator = error.operator,
      stack = error.stack;
  var diffString = (0, _jestMatcherUtils.diff)(expected, actual, options);
  var hasCustomMessage = !generatedMessage;
  var operatorName = getOperatorName(operator, stack);
  var trimmedStack = stack.replace(message, '').replace(/AssertionError(.*)/g, '');

  if (operatorName === 'doesNotThrow') {
    return (// eslint-disable-next-line prefer-template
      buildHintString(assertThrowingMatcherHint(operatorName)) + _chalk["default"].reset('Expected the function not to throw an error.\n') + _chalk["default"].reset('Instead, it threw:\n') + "  ".concat((0, _jestMatcherUtils.printReceived)(actual)) + _chalk["default"].reset(hasCustomMessage ? "\n\nMessage:\n  ".concat(message) : '') + trimmedStack
    );
  }

  if (operatorName === 'throws') {
    if (error.generatedMessage) {
      return buildHintString(assertThrowingMatcherHint(operatorName)) + _chalk["default"].reset(error.message) + _chalk["default"].reset(hasCustomMessage ? "\n\nMessage:\n  ".concat(message) : '') + trimmedStack;
    }

    return buildHintString(assertThrowingMatcherHint(operatorName)) + _chalk["default"].reset('Expected the function to throw an error.\n') + _chalk["default"].reset("But it didn't throw anything.") + _chalk["default"].reset(hasCustomMessage ? "\n\nMessage:\n  ".concat(message) : '') + trimmedStack;
  }

  if (operatorName === 'fail') {
    return buildHintString(assertMatcherHint(operator, operatorName, expected)) + _chalk["default"].reset(hasCustomMessage ? "Message:\n  ".concat(message) : '') + trimmedStack;
  }

  return (// eslint-disable-next-line prefer-template
    buildHintString(assertMatcherHint(operator, operatorName, expected)) + _chalk["default"].reset("Expected value ".concat(operatorMessage(operator))) + "  ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + _chalk["default"].reset('Received:\n') + "  ".concat((0, _jestMatcherUtils.printReceived)(actual)) + _chalk["default"].reset(hasCustomMessage ? "\n\nMessage:\n  ".concat(message) : '') + (diffString ? "\n\nDifference:\n\n".concat(diffString) : '') + trimmedStack
  );
}

function isAssertionError(error) {
  return error && (error instanceof _assert.AssertionError || error.name === _assert.AssertionError.name || error.code === 'ERR_ASSERTION');
}

function buildHintString(hint) {
  return hint ? "".concat(hint, "\n\n") : '';
}

var _default = formatNodeAssertErrors;
exports["default"] = _default;