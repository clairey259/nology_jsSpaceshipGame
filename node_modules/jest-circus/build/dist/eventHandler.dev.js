'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

var _globalErrorHandlers = require('./globalErrorHandlers');

var _types = require('./types');

var _utils = require('./utils');

var _Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;

var _Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;

var jestNow = globalThis[_Symbol["for"]('jest-native-now')] || globalThis.Date.now;

var eventHandler = function eventHandler(event, state) {
  switch (event.name) {
    case 'include_test_location_in_result':
      {
        state.includeTestLocationInResult = true;
        break;
      }

    case 'hook_start':
      {
        event.hook.seenDone = false;
        break;
      }

    case 'start_describe_definition':
      {
        var blockName = event.blockName,
            mode = event.mode;
        var currentDescribeBlock = state.currentDescribeBlock,
            currentlyRunningTest = state.currentlyRunningTest;

        if (currentlyRunningTest) {
          currentlyRunningTest.errors.push(new Error("Cannot nest a describe inside a test. Describe block \"".concat(blockName, "\" cannot run because it is nested within \"").concat(currentlyRunningTest.name, "\".")));
          break;
        }

        var describeBlock = (0, _utils.makeDescribe)(blockName, currentDescribeBlock, mode);
        currentDescribeBlock.children.push(describeBlock);
        state.currentDescribeBlock = describeBlock;
        break;
      }

    case 'finish_describe_definition':
      {
        var _currentDescribeBlock = state.currentDescribeBlock;
        (0, _utils.invariant)(_currentDescribeBlock, 'currentDescribeBlock must be there');

        if (!(0, _utils.describeBlockHasTests)(_currentDescribeBlock)) {
          _currentDescribeBlock.hooks.forEach(function (hook) {
            hook.asyncError.message = "Invalid: ".concat(hook.type, "() may not be used in a describe block containing no tests.");
            state.unhandledErrors.push(hook.asyncError);
          });
        } // pass mode of currentDescribeBlock to tests
        // but do not when there is already a single test with "only" mode


        var shouldPassMode = !(_currentDescribeBlock.mode === 'only' && _currentDescribeBlock.children.some(function (child) {
          return child.type === 'test' && child.mode === 'only';
        }));

        if (shouldPassMode) {
          _currentDescribeBlock.children.forEach(function (child) {
            if (child.type === 'test' && !child.mode) {
              child.mode = _currentDescribeBlock.mode;
            }
          });
        }

        if (!state.hasFocusedTests && _currentDescribeBlock.mode !== 'skip' && _currentDescribeBlock.children.some(function (child) {
          return child.type === 'test' && child.mode === 'only';
        })) {
          state.hasFocusedTests = true;
        }

        if (_currentDescribeBlock.parent) {
          state.currentDescribeBlock = _currentDescribeBlock.parent;
        }

        break;
      }

    case 'add_hook':
      {
        var _currentDescribeBlock2 = state.currentDescribeBlock,
            _currentlyRunningTest = state.currentlyRunningTest,
            hasStarted = state.hasStarted;
        var asyncError = event.asyncError,
            fn = event.fn,
            type = event.hookType,
            timeout = event.timeout;

        if (_currentlyRunningTest) {
          _currentlyRunningTest.errors.push(new Error("Hooks cannot be defined inside tests. Hook of type \"".concat(type, "\" is nested within \"").concat(_currentlyRunningTest.name, "\".")));

          break;
        } else if (hasStarted) {
          state.unhandledErrors.push(new Error('Cannot add a hook after tests have started running. Hooks must be defined synchronously.'));
          break;
        }

        var parent = _currentDescribeBlock2;

        _currentDescribeBlock2.hooks.push({
          asyncError: asyncError,
          fn: fn,
          parent: parent,
          seenDone: false,
          timeout: timeout,
          type: type
        });

        break;
      }

    case 'add_test':
      {
        var _currentDescribeBlock3 = state.currentDescribeBlock,
            _currentlyRunningTest2 = state.currentlyRunningTest,
            _hasStarted = state.hasStarted;
        var _asyncError = event.asyncError,
            _fn = event.fn,
            _mode = event.mode,
            name = event.testName,
            _timeout = event.timeout,
            concurrent = event.concurrent,
            failing = event.failing;

        if (_currentlyRunningTest2) {
          _currentlyRunningTest2.errors.push(new Error("Tests cannot be nested. Test \"".concat(name, "\" cannot run because it is nested within \"").concat(_currentlyRunningTest2.name, "\".")));

          break;
        } else if (_hasStarted) {
          state.unhandledErrors.push(new Error('Cannot add a test after tests have started running. Tests must be defined synchronously.'));
          break;
        }

        var test = (0, _utils.makeTest)(_fn, _mode, concurrent, name, _currentDescribeBlock3, _timeout, _asyncError, failing);

        if (_currentDescribeBlock3.mode !== 'skip' && test.mode === 'only') {
          state.hasFocusedTests = true;
        }

        _currentDescribeBlock3.children.push(test);

        _currentDescribeBlock3.tests.push(test);

        break;
      }

    case 'hook_failure':
      {
        var _test = event.test,
            _describeBlock = event.describeBlock,
            error = event.error,
            hook = event.hook;
        var _asyncError2 = hook.asyncError,
            _type = hook.type;

        if (_type === 'beforeAll') {
          (0, _utils.invariant)(_describeBlock, 'always present for `*All` hooks');
          (0, _utils.addErrorToEachTestUnderDescribe)(_describeBlock, error, _asyncError2);
        } else if (_type === 'afterAll') {
          // Attaching `afterAll` errors to each test makes execution flow
          // too complicated, so we'll consider them to be global.
          state.unhandledErrors.push([error, _asyncError2]);
        } else {
          (0, _utils.invariant)(_test, 'always present for `*Each` hooks');

          _test.errors.push([error, _asyncError2]);
        }

        break;
      }

    case 'test_skip':
      {
        event.test.status = 'skip';
        break;
      }

    case 'test_todo':
      {
        event.test.status = 'todo';
        break;
      }

    case 'test_done':
      {
        event.test.duration = (0, _utils.getTestDuration)(event.test);
        event.test.status = 'done';
        state.currentlyRunningTest = null;
        break;
      }

    case 'test_start':
      {
        state.currentlyRunningTest = event.test;
        event.test.startedAt = jestNow();
        event.test.invocations += 1;
        break;
      }

    case 'test_fn_start':
      {
        event.test.seenDone = false;
        break;
      }

    case 'test_fn_failure':
      {
        var _error = event.error,
            _asyncError3 = event.test.asyncError;
        event.test.errors.push([_error, _asyncError3]);
        break;
      }

    case 'test_retry':
      {
        var logErrorsBeforeRetry = // eslint-disable-next-line no-restricted-globals
        global[_types.LOG_ERRORS_BEFORE_RETRY] || false;

        if (logErrorsBeforeRetry) {
          var _event$test$retryReas;

          (_event$test$retryReas = event.test.retryReasons).push.apply(_event$test$retryReas, _toConsumableArray(event.test.errors));
        }

        event.test.errors = [];
        break;
      }

    case 'run_start':
      {
        state.hasStarted = true;
        /* eslint-disable no-restricted-globals */

        global[_types.TEST_TIMEOUT_SYMBOL] && (state.testTimeout = global[_types.TEST_TIMEOUT_SYMBOL]);
        /* eslint-enable */

        break;
      }

    case 'run_finish':
      {
        break;
      }

    case 'setup':
      {
        // Uncaught exception handlers should be defined on the parent process
        // object. If defined on the VM's process object they just no op and let
        // the parent process crash. It might make sense to return a `dispatch`
        // function to the parent process and register handlers there instead, but
        // i'm not sure if this is works. For now i just replicated whatever
        // jasmine was doing -- dabramov
        state.parentProcess = event.parentProcess;
        (0, _utils.invariant)(state.parentProcess);
        state.originalGlobalErrorHandlers = (0, _globalErrorHandlers.injectGlobalErrorHandlers)(state.parentProcess);

        if (event.testNamePattern) {
          state.testNamePattern = new RegExp(event.testNamePattern, 'i');
        }

        break;
      }

    case 'teardown':
      {
        (0, _utils.invariant)(state.originalGlobalErrorHandlers);
        (0, _utils.invariant)(state.parentProcess);
        (0, _globalErrorHandlers.restoreGlobalErrorHandlers)(state.parentProcess, state.originalGlobalErrorHandlers);
        break;
      }

    case 'error':
      {
        // It's very likely for long-running async tests to throw errors. In this
        // case we want to catch them and fail the current test. At the same time
        // there's a possibility that one test sets a long timeout, that will
        // eventually throw after this test finishes but during some other test
        // execution, which will result in one test's error failing another test.
        // In any way, it should be possible to track where the error was thrown
        // from.
        state.currentlyRunningTest ? state.currentlyRunningTest.errors.push(event.error) : state.unhandledErrors.push(event.error);
        break;
      }
  }
};

var _default = eventHandler;
exports["default"] = _default;