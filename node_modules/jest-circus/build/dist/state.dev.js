'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.setState = exports.resetState = exports.getState = exports.dispatchSync = exports.dispatch = exports.addEventHandler = exports.ROOT_DESCRIBE_BLOCK_NAME = void 0;

var _eventHandler = _interopRequireDefault(require('./eventHandler'));

var _formatNodeAssertErrors = _interopRequireDefault(require('./formatNodeAssertErrors'));

var _types = require('./types');

var _utils = require('./utils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var eventHandlers = [_eventHandler["default"], _formatNodeAssertErrors["default"]];
var ROOT_DESCRIBE_BLOCK_NAME = 'ROOT_DESCRIBE_BLOCK';
exports.ROOT_DESCRIBE_BLOCK_NAME = ROOT_DESCRIBE_BLOCK_NAME;

var createState = function createState() {
  var ROOT_DESCRIBE_BLOCK = (0, _utils.makeDescribe)(ROOT_DESCRIBE_BLOCK_NAME);
  return {
    currentDescribeBlock: ROOT_DESCRIBE_BLOCK,
    currentlyRunningTest: null,
    expand: undefined,
    hasFocusedTests: false,
    hasStarted: false,
    includeTestLocationInResult: false,
    maxConcurrency: 5,
    parentProcess: null,
    rootDescribeBlock: ROOT_DESCRIBE_BLOCK,
    testNamePattern: null,
    testTimeout: 5000,
    unhandledErrors: []
  };
};
/* eslint-disable no-restricted-globals */


var resetState = function resetState() {
  global[_types.STATE_SYM] = createState();
};

exports.resetState = resetState;
resetState();

var getState = function getState() {
  return global[_types.STATE_SYM];
};

exports.getState = getState;

var setState = function setState(state) {
  return global[_types.STATE_SYM] = state;
};
/* eslint-enable */


exports.setState = setState;

var dispatch = function dispatch(event) {
  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, handler;

  return regeneratorRuntime.async(function dispatch$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 3;
          _iterator = eventHandlers[Symbol.iterator]();

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 12;
            break;
          }

          handler = _step.value;
          _context.next = 9;
          return regeneratorRuntime.awrap(handler(event, getState()));

        case 9:
          _iteratorNormalCompletion = true;
          _context.next = 5;
          break;

        case 12:
          _context.next = 18;
          break;

        case 14:
          _context.prev = 14;
          _context.t0 = _context["catch"](3);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 18:
          _context.prev = 18;
          _context.prev = 19;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 21:
          _context.prev = 21;

          if (!_didIteratorError) {
            _context.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return _context.finish(21);

        case 25:
          return _context.finish(18);

        case 26:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[3, 14, 18, 26], [19,, 21, 25]]);
};

exports.dispatch = dispatch;

var dispatchSync = function dispatchSync(event) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = eventHandlers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var handler = _step2.value;
      handler(event, getState());
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
};

exports.dispatchSync = dispatchSync;

var addEventHandler = function addEventHandler(handler) {
  eventHandlers.push(handler);
};

exports.addEventHandler = addEventHandler;