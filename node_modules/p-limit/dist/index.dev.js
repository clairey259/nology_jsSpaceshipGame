'use strict';

var Queue = require('yocto-queue');

var pLimit = function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    throw new TypeError('Expected `concurrency` to be a number from 1 and up');
  }

  var queue = new Queue();
  var activeCount = 0;

  var next = function next() {
    activeCount--;

    if (queue.size > 0) {
      queue.dequeue()();
    }
  };

  var run = function run(fn, resolve) {
    var _len,
        args,
        _key,
        result,
        _args2 = arguments;

    return regeneratorRuntime.async(function run$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            for (_len = _args2.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = _args2[_key];
            }

            activeCount++;

            result = function _callee() {
              return regeneratorRuntime.async(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      return _context.abrupt("return", fn.apply(void 0, args));

                    case 1:
                    case "end":
                      return _context.stop();
                  }
                }
              });
            }();

            resolve(result);
            _context2.prev = 4;
            _context2.next = 7;
            return regeneratorRuntime.awrap(result);

          case 7:
            _context2.next = 11;
            break;

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](4);

          case 11:
            next();

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, null, null, [[4, 9]]);
  };

  var enqueue = function enqueue(fn, resolve) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }

    queue.enqueue(run.bind.apply(run, [null, fn, resolve].concat(args)));

    (function _callee2() {
      return regeneratorRuntime.async(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return regeneratorRuntime.awrap(Promise.resolve());

            case 2:
              if (activeCount < concurrency && queue.size > 0) {
                queue.dequeue()();
              }

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      });
    })();
  };

  var generator = function generator(fn) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    return new Promise(function (resolve) {
      enqueue.apply(void 0, [fn, resolve].concat(args));
    });
  };

  Object.defineProperties(generator, {
    activeCount: {
      get: function get() {
        return activeCount;
      }
    },
    pendingCount: {
      get: function get() {
        return queue.size;
      }
    },
    clearQueue: {
      value: function value() {
        queue.clear();
      }
    }
  });
  return generator;
};

module.exports = pLimit;