'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _path() {
  var data = require('path');

  _path = function _path() {
    return data;
  };

  return data;
}

function _jestPnpResolver() {
  var data = _interopRequireDefault(require('jest-pnp-resolver'));

  _jestPnpResolver = function _jestPnpResolver() {
    return data;
  };

  return data;
}

function _resolve() {
  var data = require('resolve');

  _resolve = function _resolve() {
    return data;
  };

  return data;
}

var _resolve2 = require('resolve.exports');

var _fileWalkers = require('./fileWalkers');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var defaultResolver = function defaultResolver(path, options) {
  // Yarn 2 adds support to `resolve` automatically so the pnpResolver is only
  // needed for Yarn 1 which implements version 1 of the pnp spec
  if (process.versions.pnp === '1') {
    return (0, _jestPnpResolver()["default"])(path, options);
  }

  var resolveOptions = _objectSpread({}, options, {
    isDirectory: _fileWalkers.isDirectory,
    isFile: _fileWalkers.isFile,
    preserveSymlinks: false,
    readPackageSync: readPackageSync,
    realpathSync: _fileWalkers.realpathSync
  });

  var pathToResolve = getPathInModule(path, resolveOptions);
  var result = (0, _resolve().sync)(pathToResolve, resolveOptions); // Dereference symlinks to ensure we don't create a separate
  // module instance depending on how it was referenced.

  return (0, _fileWalkers.realpathSync)(result);
};

var _default = defaultResolver;
/*
 * helper functions
 */

exports["default"] = _default;

function readPackageSync(_, file) {
  return (0, _fileWalkers.readPackageCached)(file);
}

function getPathInModule(path, options) {
  if (shouldIgnoreRequestForExports(path)) {
    return path;
  }

  var segments = path.split('/');
  var moduleName = segments.shift();

  if (moduleName) {
    // TODO: handle `#` here: https://github.com/facebook/jest/issues/12270
    if (moduleName.startsWith('@')) {
      moduleName = "".concat(moduleName, "/").concat(segments.shift());
    } // self-reference


    var closestPackageJson = (0, _fileWalkers.findClosestPackageJson)(options.basedir);

    if (closestPackageJson) {
      var pkg = (0, _fileWalkers.readPackageCached)(closestPackageJson);

      if (pkg.name === moduleName && pkg.exports) {
        var subpath = segments.join('/') || '.';
        var resolved = (0, _resolve2.resolve)(pkg, subpath, createResolveOptions(options.conditions));

        if (!resolved) {
          throw new Error('`exports` exists, but no results - this is a bug in Jest. Please report an issue');
        }

        return (0, _path().resolve)((0, _path().dirname)(closestPackageJson), resolved);
      }
    }

    var packageJsonPath = '';

    try {
      packageJsonPath = (0, _resolve().sync)("".concat(moduleName, "/package.json"), options);
    } catch (_unused) {// ignore if package.json cannot be found
    }

    if (packageJsonPath && (0, _fileWalkers.isFile)(packageJsonPath)) {
      var _pkg = (0, _fileWalkers.readPackageCached)(packageJsonPath);

      if (_pkg.exports) {
        var _subpath = segments.join('/') || '.';

        var _resolved = (0, _resolve2.resolve)(_pkg, _subpath, createResolveOptions(options.conditions));

        if (!_resolved) {
          throw new Error('`exports` exists, but no results - this is a bug in Jest. Please report an issue');
        }

        return (0, _path().resolve)((0, _path().dirname)(packageJsonPath), _resolved);
      }
    }
  }

  return path;
}

function createResolveOptions(conditions) {
  return conditions ? {
    conditions: conditions,
    unsafe: true
  } // no conditions were passed - let's assume this is Jest internal and it should be `require`
  : {
    browser: false,
    require: true
  };
} // if it's a relative import or an absolute path, exports are ignored


var shouldIgnoreRequestForExports = function shouldIgnoreRequestForExports(path) {
  return path.startsWith('.') || (0, _path().isAbsolute)(path);
};