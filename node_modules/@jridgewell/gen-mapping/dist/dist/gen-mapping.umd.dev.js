"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/set-array'), require('@jridgewell/sourcemap-codec')) : typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/set-array', '@jridgewell/sourcemap-codec'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec));
})(void 0, function (exports, setArray, sourcemapCodec) {
  'use strict';
  /**
   * A low-level API to associate a generated position with an original source position. Line and
   * column here are 0-based, unlike `addMapping`.
   */

  exports.addSegment = void 0;
  /**
   * A high-level API to associate a generated position with an original source position. Line is
   * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.
   */

  exports.addMapping = void 0;
  /**
   * Adds/removes the content of the source file to the source map.
   */

  exports.setSourceContent = void 0;
  /**
   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
   * a sourcemap, or to JSON.stringify.
   */

  exports.decodedMap = void 0;
  /**
   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
   * a sourcemap, or to JSON.stringify.
   */

  exports.encodedMap = void 0;
  /**
   * Returns an array of high-level mapping objects for every recorded segment, which could then be
   * passed to the `source-map` library.
   */

  exports.allMappings = void 0;
  /**
   * Provides the state to generate a sourcemap.
   */

  var GenMapping = function GenMapping() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        file = _ref.file,
        sourceRoot = _ref.sourceRoot;

    _classCallCheck(this, GenMapping);

    this._names = new setArray.SetArray();
    this._sources = new setArray.SetArray();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
  };

  (function () {
    exports.addSegment = function (map, genLine, genColumn, source, sourceLine, sourceColumn, name) {
      var mappings = map._mappings,
          sources = map._sources,
          sourcesContent = map._sourcesContent,
          names = map._names;
      var line = getLine(mappings, genLine);

      if (source == null) {
        var _seg = [genColumn];

        var _index = getColumnIndex(line, genColumn, _seg);

        return insert(line, _index, _seg);
      }

      var sourcesIndex = setArray.put(sources, source);
      var seg = name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, setArray.put(names, name)] : [genColumn, sourcesIndex, sourceLine, sourceColumn];
      var index = getColumnIndex(line, genColumn, seg);
      if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = null;
      insert(line, index, seg);
    };

    exports.addMapping = function (map, mapping) {
      var generated = mapping.generated,
          source = mapping.source,
          original = mapping.original,
          name = mapping.name;
      return exports.addSegment(map, generated.line - 1, generated.column, source, original == null ? undefined : original.line - 1, original === null || original === void 0 ? void 0 : original.column, name);
    };

    exports.setSourceContent = function (map, source, content) {
      var sources = map._sources,
          sourcesContent = map._sourcesContent;
      sourcesContent[setArray.put(sources, source)] = content;
    };

    exports.decodedMap = function (map) {
      var file = map.file,
          sourceRoot = map.sourceRoot,
          mappings = map._mappings,
          sources = map._sources,
          sourcesContent = map._sourcesContent,
          names = map._names;
      return {
        version: 3,
        file: file,
        names: names.array,
        sourceRoot: sourceRoot || undefined,
        sources: sources.array,
        sourcesContent: sourcesContent,
        mappings: mappings
      };
    };

    exports.encodedMap = function (map) {
      var decoded = exports.decodedMap(map);
      return Object.assign(Object.assign({}, decoded), {
        mappings: sourcemapCodec.encode(decoded.mappings)
      });
    };

    exports.allMappings = function (map) {
      var out = [];
      var mappings = map._mappings,
          sources = map._sources,
          names = map._names;

      for (var i = 0; i < mappings.length; i++) {
        var line = mappings[i];

        for (var j = 0; j < line.length; j++) {
          var seg = line[j];
          var generated = {
            line: i + 1,
            column: seg[0]
          };
          var source = undefined;
          var original = undefined;
          var name = undefined;

          if (seg.length !== 1) {
            source = sources.array[seg[1]];
            original = {
              line: seg[2] + 1,
              column: seg[3]
            };
            if (seg.length === 5) name = names.array[seg[4]];
          }

          out.push({
            generated: generated,
            source: source,
            original: original,
            name: name
          });
        }
      }

      return out;
    };
  })();

  function getLine(mappings, index) {
    for (var i = mappings.length; i <= index; i++) {
      mappings[i] = [];
    }

    return mappings[index];
  }

  function getColumnIndex(line, column, seg) {
    var index = line.length;

    for (var i = index - 1; i >= 0; i--, index--) {
      var current = line[i];
      var col = current[0];
      if (col > column) continue;
      if (col < column) break;
      var cmp = compare(current, seg);
      if (cmp === 0) return index;
      if (cmp < 0) break;
    }

    return index;
  }

  function compare(a, b) {
    var cmp = compareNum(a.length, b.length);
    if (cmp !== 0) return cmp; // We've already checked genColumn

    if (a.length === 1) return 0;
    cmp = compareNum(a[1], b[1]);
    if (cmp !== 0) return cmp;
    cmp = compareNum(a[2], b[2]);
    if (cmp !== 0) return cmp;
    cmp = compareNum(a[3], b[3]);
    if (cmp !== 0) return cmp;
    if (a.length === 4) return 0;
    return compareNum(a[4], b[4]);
  }

  function compareNum(a, b) {
    return a - b;
  }

  function insert(array, index, value) {
    if (index === -1) return;

    for (var i = array.length; i > index; i--) {
      array[i] = array[i - 1];
    }

    array[index] = value;
  }

  exports.GenMapping = GenMapping;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});