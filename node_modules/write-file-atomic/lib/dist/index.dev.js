'use strict';

module.exports = writeFile;
module.exports.sync = writeFileSync;
module.exports._getTmpname = getTmpname; // for testing

module.exports._cleanupOnExit = cleanupOnExit;

var fs = require('fs');

var MurmurHash3 = require('imurmurhash');

var onExit = require('signal-exit');

var path = require('path');

var _require = require('util'),
    promisify = _require.promisify;

var activeFiles = {}; // if we run inside of a worker_thread, `process.pid` is not unique

/* istanbul ignore next */

var threadId = function getId() {
  try {
    var workerThreads = require('worker_threads'); /// if we are in main thread, this is set to `0`


    return workerThreads.threadId;
  } catch (e) {
    // worker_threads are not available, fallback to 0
    return 0;
  }
}();

var invocations = 0;

function getTmpname(filename) {
  return filename + '.' + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
}

function cleanupOnExit(tmpfile) {
  return function () {
    try {
      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile);
    } catch (_unused) {// ignore errors
    }
  };
}

function serializeActiveFile(absoluteName) {
  return new Promise(function (resolve) {
    // make a queue if it doesn't already exist
    if (!activeFiles[absoluteName]) {
      activeFiles[absoluteName] = [];
    }

    activeFiles[absoluteName].push(resolve); // add this job to the queue

    if (activeFiles[absoluteName].length === 1) {
      resolve();
    } // kick off the first one

  });
} // https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342


function isChownErrOk(err) {
  if (err.code === 'ENOSYS') {
    return true;
  }

  var nonroot = !process.getuid || process.getuid() !== 0;

  if (nonroot) {
    if (err.code === 'EINVAL' || err.code === 'EPERM') {
      return true;
    }
  }

  return false;
}

function writeFileAsync(filename, data) {
  var options,
      fd,
      tmpfile,
      removeOnExitHandler,
      absoluteName,
      truename,
      stats,
      _args = arguments;
  return regeneratorRuntime.async(function writeFileAsync$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};

          if (typeof options === 'string') {
            options = {
              encoding: options
            };
          }

          /* istanbul ignore next -- The closure only gets called when onExit triggers */
          removeOnExitHandler = onExit(cleanupOnExit(function () {
            return tmpfile;
          }));
          absoluteName = path.resolve(filename);
          _context.prev = 4;
          _context.next = 7;
          return regeneratorRuntime.awrap(serializeActiveFile(absoluteName));

        case 7:
          _context.next = 9;
          return regeneratorRuntime.awrap(promisify(fs.realpath)(filename)["catch"](function () {
            return filename;
          }));

        case 9:
          truename = _context.sent;
          tmpfile = getTmpname(truename);

          if (!(!options.mode || !options.chown)) {
            _context.next = 16;
            break;
          }

          _context.next = 14;
          return regeneratorRuntime.awrap(promisify(fs.stat)(truename)["catch"](function () {}));

        case 14:
          stats = _context.sent;

          if (stats) {
            if (options.mode == null) {
              options.mode = stats.mode;
            }

            if (options.chown == null && process.getuid) {
              options.chown = {
                uid: stats.uid,
                gid: stats.gid
              };
            }
          }

        case 16:
          _context.next = 18;
          return regeneratorRuntime.awrap(promisify(fs.open)(tmpfile, 'w', options.mode));

        case 18:
          fd = _context.sent;

          if (!options.tmpfileCreated) {
            _context.next = 22;
            break;
          }

          _context.next = 22;
          return regeneratorRuntime.awrap(options.tmpfileCreated(tmpfile));

        case 22:
          if (!ArrayBuffer.isView(data)) {
            _context.next = 27;
            break;
          }

          _context.next = 25;
          return regeneratorRuntime.awrap(promisify(fs.write)(fd, data, 0, data.length, 0));

        case 25:
          _context.next = 30;
          break;

        case 27:
          if (!(data != null)) {
            _context.next = 30;
            break;
          }

          _context.next = 30;
          return regeneratorRuntime.awrap(promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8')));

        case 30:
          if (!(options.fsync !== false)) {
            _context.next = 33;
            break;
          }

          _context.next = 33;
          return regeneratorRuntime.awrap(promisify(fs.fsync)(fd));

        case 33:
          _context.next = 35;
          return regeneratorRuntime.awrap(promisify(fs.close)(fd));

        case 35:
          fd = null;

          if (!options.chown) {
            _context.next = 39;
            break;
          }

          _context.next = 39;
          return regeneratorRuntime.awrap(promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid)["catch"](function (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }));

        case 39:
          if (!options.mode) {
            _context.next = 42;
            break;
          }

          _context.next = 42;
          return regeneratorRuntime.awrap(promisify(fs.chmod)(tmpfile, options.mode)["catch"](function (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }));

        case 42:
          _context.next = 44;
          return regeneratorRuntime.awrap(promisify(fs.rename)(tmpfile, truename));

        case 44:
          _context.prev = 44;

          if (!fd) {
            _context.next = 48;
            break;
          }

          _context.next = 48;
          return regeneratorRuntime.awrap(promisify(fs.close)(fd)["catch"](
          /* istanbul ignore next */
          function () {}));

        case 48:
          removeOnExitHandler();
          _context.next = 51;
          return regeneratorRuntime.awrap(promisify(fs.unlink)(tmpfile)["catch"](function () {}));

        case 51:
          activeFiles[absoluteName].shift(); // remove the element added by serializeSameFile

          if (activeFiles[absoluteName].length > 0) {
            activeFiles[absoluteName][0](); // start next job if one is pending
          } else {
            delete activeFiles[absoluteName];
          }

          return _context.finish(44);

        case 54:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[4,, 44, 54]]);
}

function writeFile(filename, data, options, callback) {
  var promise, result;
  return regeneratorRuntime.async(function writeFile$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (options instanceof Function) {
            callback = options;
            options = {};
          }

          promise = writeFileAsync(filename, data, options);

          if (!callback) {
            _context2.next = 13;
            break;
          }

          _context2.prev = 3;
          _context2.next = 6;
          return regeneratorRuntime.awrap(promise);

        case 6:
          result = _context2.sent;
          return _context2.abrupt("return", callback(result));

        case 10:
          _context2.prev = 10;
          _context2.t0 = _context2["catch"](3);
          return _context2.abrupt("return", callback(_context2.t0));

        case 13:
          return _context2.abrupt("return", promise);

        case 14:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[3, 10]]);
}

function writeFileSync(filename, data, options) {
  if (typeof options === 'string') {
    options = {
      encoding: options
    };
  } else if (!options) {
    options = {};
  }

  try {
    filename = fs.realpathSync(filename);
  } catch (ex) {// it's ok, it'll happen on a not yet existing file
  }

  var tmpfile = getTmpname(filename);

  if (!options.mode || !options.chown) {
    // Either mode or chown is not explicitly set
    // Default behavior is to copy it from original file
    try {
      var stats = fs.statSync(filename);
      options = Object.assign({}, options);

      if (!options.mode) {
        options.mode = stats.mode;
      }

      if (!options.chown && process.getuid) {
        options.chown = {
          uid: stats.uid,
          gid: stats.gid
        };
      }
    } catch (ex) {// ignore stat errors
    }
  }

  var fd;
  var cleanup = cleanupOnExit(tmpfile);
  var removeOnExitHandler = onExit(cleanup);
  var threw = true;

  try {
    fd = fs.openSync(tmpfile, 'w', options.mode || 438);

    if (options.tmpfileCreated) {
      options.tmpfileCreated(tmpfile);
    }

    if (ArrayBuffer.isView(data)) {
      fs.writeSync(fd, data, 0, data.length, 0);
    } else if (data != null) {
      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));
    }

    if (options.fsync !== false) {
      fs.fsyncSync(fd);
    }

    fs.closeSync(fd);
    fd = null;

    if (options.chown) {
      try {
        fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);
      } catch (err) {
        if (!isChownErrOk(err)) {
          throw err;
        }
      }
    }

    if (options.mode) {
      try {
        fs.chmodSync(tmpfile, options.mode);
      } catch (err) {
        if (!isChownErrOk(err)) {
          throw err;
        }
      }
    }

    fs.renameSync(tmpfile, filename);
    threw = false;
  } finally {
    if (fd) {
      try {
        fs.closeSync(fd);
      } catch (ex) {// ignore close errors at this stage, error may have closed fd already.
      }
    }

    removeOnExitHandler();

    if (threw) {
      cleanup();
    }
  }
}