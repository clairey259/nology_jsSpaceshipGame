"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.y18n = y18n;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var shim;

var Y18N =
/*#__PURE__*/
function () {
  function Y18N(opts) {
    _classCallCheck(this, Y18N);

    // configurable options.
    opts = opts || {};
    this.directory = opts.directory || './locales';
    this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;
    this.locale = opts.locale || 'en';
    this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true; // internal stuff.

    this.cache = Object.create(null);
    this.writeQueue = [];
  }

  _createClass(Y18N, [{
    key: "__",
    value: function __() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (typeof arguments[0] !== 'string') {
        return this._taggedLiteral.apply(this, [arguments[0]].concat(Array.prototype.slice.call(arguments)));
      }

      var str = args.shift();

      var cb = function cb() {}; // start with noop.


      if (typeof args[args.length - 1] === 'function') cb = args.pop();

      cb = cb || function () {}; // noop.


      if (!this.cache[this.locale]) this._readLocaleFile(); // we've observed a new string, update the language file.

      if (!this.cache[this.locale][str] && this.updateFiles) {
        this.cache[this.locale][str] = str; // include the current directory and locale,
        // since these values could change before the
        // write is performed.

        this._enqueueWrite({
          directory: this.directory,
          locale: this.locale,
          cb: cb
        });
      } else {
        cb();
      }

      return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
    }
  }, {
    key: "__n",
    value: function __n() {
      var args = Array.prototype.slice.call(arguments);
      var singular = args.shift();
      var plural = args.shift();
      var quantity = args.shift();

      var cb = function cb() {}; // start with noop.


      if (typeof args[args.length - 1] === 'function') cb = args.pop();
      if (!this.cache[this.locale]) this._readLocaleFile();
      var str = quantity === 1 ? singular : plural;

      if (this.cache[this.locale][singular]) {
        var entry = this.cache[this.locale][singular];
        str = entry[quantity === 1 ? 'one' : 'other'];
      } // we've observed a new string, update the language file.


      if (!this.cache[this.locale][singular] && this.updateFiles) {
        this.cache[this.locale][singular] = {
          one: singular,
          other: plural
        }; // include the current directory and locale,
        // since these values could change before the
        // write is performed.

        this._enqueueWrite({
          directory: this.directory,
          locale: this.locale,
          cb: cb
        });
      } else {
        cb();
      } // if a %d placeholder is provided, add quantity
      // to the arguments expanded by util.format.


      var values = [str];
      if (~str.indexOf('%d')) values.push(quantity);
      return shim.format.apply(shim.format, values.concat(args));
    }
  }, {
    key: "setLocale",
    value: function setLocale(locale) {
      this.locale = locale;
    }
  }, {
    key: "getLocale",
    value: function getLocale() {
      return this.locale;
    }
  }, {
    key: "updateLocale",
    value: function updateLocale(obj) {
      if (!this.cache[this.locale]) this._readLocaleFile();

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          this.cache[this.locale][key] = obj[key];
        }
      }
    }
  }, {
    key: "_taggedLiteral",
    value: function _taggedLiteral(parts) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var str = '';
      parts.forEach(function (part, i) {
        var arg = args[i + 1];
        str += part;

        if (typeof arg !== 'undefined') {
          str += '%s';
        }
      });
      return this.__.apply(this, [str].concat([].slice.call(args, 1)));
    }
  }, {
    key: "_enqueueWrite",
    value: function _enqueueWrite(work) {
      this.writeQueue.push(work);
      if (this.writeQueue.length === 1) this._processWriteQueue();
    }
  }, {
    key: "_processWriteQueue",
    value: function _processWriteQueue() {
      var _this = this;

      var work = this.writeQueue[0]; // destructure the enqueued work.

      var directory = work.directory;
      var locale = work.locale;
      var cb = work.cb;

      var languageFile = this._resolveLocaleFile(directory, locale);

      var serializedLocale = JSON.stringify(this.cache[locale], null, 2);
      shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
        _this.writeQueue.shift();

        if (_this.writeQueue.length > 0) _this._processWriteQueue();
        cb(err);
      });
    }
  }, {
    key: "_readLocaleFile",
    value: function _readLocaleFile() {
      var localeLookup = {};

      var languageFile = this._resolveLocaleFile(this.directory, this.locale);

      try {
        // When using a bundler such as webpack, readFileSync may not be defined:
        if (shim.fs.readFileSync) {
          localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));
        }
      } catch (err) {
        if (err instanceof SyntaxError) {
          err.message = 'syntax error in ' + languageFile;
        }

        if (err.code === 'ENOENT') localeLookup = {};else throw err;
      }

      this.cache[this.locale] = localeLookup;
    }
  }, {
    key: "_resolveLocaleFile",
    value: function _resolveLocaleFile(directory, locale) {
      var file = shim.resolve(directory, './', locale + '.json');

      if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
        // attempt fallback to language only
        var languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');
        if (this._fileExistsSync(languageFile)) file = languageFile;
      }

      return file;
    }
  }, {
    key: "_fileExistsSync",
    value: function _fileExistsSync(file) {
      return shim.exists(file);
    }
  }]);

  return Y18N;
}();

function y18n(opts, _shim) {
  shim = _shim;
  var y18n = new Y18N(opts);
  return {
    __: y18n.__.bind(y18n),
    __n: y18n.__n.bind(y18n),
    setLocale: y18n.setLocale.bind(y18n),
    getLocale: y18n.getLocale.bind(y18n),
    updateLocale: y18n.updateLocale.bind(y18n),
    locale: y18n.locale
  };
}