"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validation = validation;

var _argsert = require("./argsert.js");

var _commonTypes = require("./typings/common-types.js");

var _levenshtein = require("./utils/levenshtein.js");

var _objFilter = require("./utils/obj-filter.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var specialKeys = ['$0', '--', '_'];

function validation(yargs, usage, shim) {
  var __ = shim.y18n.__;
  var __n = shim.y18n.__n;
  var self = {};

  self.nonOptionCount = function nonOptionCount(argv) {
    var demandedCommands = yargs.getDemandedCommands();
    var positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);

    var _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;

    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
      if (_s < demandedCommands._.min) {
        if (demandedCommands._.minMsg !== undefined) {
          usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
        } else {
          usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));
        }
      } else if (_s > demandedCommands._.max) {
        if (demandedCommands._.maxMsg !== undefined) {
          usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
        } else {
          usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));
        }
      }
    }
  };

  self.positionalCount = function positionalCount(required, observed) {
    if (observed < required) {
      usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));
    }
  };

  self.requiredArguments = function requiredArguments(argv, demandedOptions) {
    var missing = null;

    for (var _i = 0, _Object$keys = Object.keys(demandedOptions); _i < _Object$keys.length; _i++) {
      var _key = _Object$keys[_i];

      if (!Object.prototype.hasOwnProperty.call(argv, _key) || typeof argv[_key] === 'undefined') {
        missing = missing || {};
        missing[_key] = demandedOptions[_key];
      }
    }

    if (missing) {
      var customMsgs = [];

      for (var _i2 = 0, _Object$keys2 = Object.keys(missing); _i2 < _Object$keys2.length; _i2++) {
        var key = _Object$keys2[_i2];
        var msg = missing[key];

        if (msg && customMsgs.indexOf(msg) < 0) {
          customMsgs.push(msg);
        }
      }

      var customMsg = customMsgs.length ? "\n".concat(customMsgs.join('\n')) : '';
      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));
    }
  };

  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {
    var checkPositionals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

    var _a;

    var commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    var unknown = [];
    var currentContext = yargs.getInternalMethods().getContext();
    Object.keys(argv).forEach(function (key) {
      if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
        unknown.push(key);
      }
    });

    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
      argv._.slice(currentContext.commands.length).forEach(function (key) {
        if (!commandKeys.includes('' + key)) {
          unknown.push('' + key);
        }
      });
    }

    if (checkPositionals) {
      var demandedCommands = yargs.getDemandedCommands();
      var maxNonOptDemanded = ((_a = demandedCommands._) === null || _a === void 0 ? void 0 : _a.max) || 0;
      var expected = currentContext.commands.length + maxNonOptDemanded;

      if (expected < argv._.length) {
        argv._.slice(expected).forEach(function (key) {
          key = String(key);

          if (!currentContext.commands.includes(key) && !unknown.includes(key)) {
            unknown.push(key);
          }
        });
      }
    }

    if (unknown.length) {
      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.map(function (s) {
        return s.trim() ? s : "\"".concat(s, "\"");
      }).join(', ')));
    }
  };

  self.unknownCommands = function unknownCommands(argv) {
    var commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    var unknown = [];
    var currentContext = yargs.getInternalMethods().getContext();

    if (currentContext.commands.length > 0 || commandKeys.length > 0) {
      argv._.slice(currentContext.commands.length).forEach(function (key) {
        if (!commandKeys.includes('' + key)) {
          unknown.push('' + key);
        }
      });
    }

    if (unknown.length > 0) {
      usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));
      return true;
    } else {
      return false;
    }
  };

  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
      return false;
    }

    var newAliases = yargs.parsed.newAliases;
    return [key].concat(_toConsumableArray(aliases[key])).some(function (a) {
      return !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key];
    });
  };

  self.limitedChoices = function limitedChoices(argv) {
    var options = yargs.getOptions();
    var invalid = {};
    if (!Object.keys(options.choices).length) return;
    Object.keys(argv).forEach(function (key) {
      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
        [].concat(argv[key]).forEach(function (value) {
          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {
            invalid[key] = (invalid[key] || []).concat(value);
          }
        });
      }
    });
    var invalidKeys = Object.keys(invalid);
    if (!invalidKeys.length) return;

    var msg = __('Invalid values:');

    invalidKeys.forEach(function (key) {
      msg += "\n  ".concat(__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key])));
    });
    usage.fail(msg);
  };

  var implied = {};

  self.implies = function implies(key, value) {
    (0, _argsert.argsert)('<string|object> [array|number|string]', [key, value], arguments.length);

    if (_typeof(key) === 'object') {
      Object.keys(key).forEach(function (k) {
        self.implies(k, key[k]);
      });
    } else {
      yargs.global(key);

      if (!implied[key]) {
        implied[key] = [];
      }

      if (Array.isArray(value)) {
        value.forEach(function (i) {
          return self.implies(key, i);
        });
      } else {
        (0, _commonTypes.assertNotStrictEqual)(value, undefined, shim);
        implied[key].push(value);
      }
    }
  };

  self.getImplied = function getImplied() {
    return implied;
  };

  function keyExists(argv, val) {
    var num = Number(val);
    val = isNaN(num) ? val : num;

    if (typeof val === 'number') {
      val = argv._.length >= val;
    } else if (val.match(/^--no-.+/)) {
      val = val.match(/^--no-(.+)/)[1];
      val = !Object.prototype.hasOwnProperty.call(argv, val);
    } else {
      val = Object.prototype.hasOwnProperty.call(argv, val);
    }

    return val;
  }

  self.implications = function implications(argv) {
    var implyFail = [];
    Object.keys(implied).forEach(function (key) {
      var origKey = key;
      (implied[key] || []).forEach(function (value) {
        var key = origKey;
        var origValue = value;
        key = keyExists(argv, key);
        value = keyExists(argv, value);

        if (key && !value) {
          implyFail.push(" ".concat(origKey, " -> ").concat(origValue));
        }
      });
    });

    if (implyFail.length) {
      var msg = "".concat(__('Implications failed:'), "\n");
      implyFail.forEach(function (value) {
        msg += value;
      });
      usage.fail(msg);
    }
  };

  var conflicting = {};

  self.conflicts = function conflicts(key, value) {
    (0, _argsert.argsert)('<string|object> [array|string]', [key, value], arguments.length);

    if (_typeof(key) === 'object') {
      Object.keys(key).forEach(function (k) {
        self.conflicts(k, key[k]);
      });
    } else {
      yargs.global(key);

      if (!conflicting[key]) {
        conflicting[key] = [];
      }

      if (Array.isArray(value)) {
        value.forEach(function (i) {
          return self.conflicts(key, i);
        });
      } else {
        conflicting[key].push(value);
      }
    }
  };

  self.getConflicting = function () {
    return conflicting;
  };

  self.conflicting = function conflictingFn(argv) {
    Object.keys(argv).forEach(function (key) {
      if (conflicting[key]) {
        conflicting[key].forEach(function (value) {
          if (value && argv[key] !== undefined && argv[value] !== undefined) {
            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
          }
        });
      }
    });

    if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) {
      Object.keys(conflicting).forEach(function (key) {
        conflicting[key].forEach(function (value) {
          if (value && argv[shim.Parser.camelCase(key)] !== undefined && argv[shim.Parser.camelCase(value)] !== undefined) {
            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
          }
        });
      });
    }
  };

  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
    var threshold = 3;
    potentialCommands = potentialCommands.sort(function (a, b) {
      return b.length - a.length;
    });
    var recommended = null;
    var bestDistance = Infinity;

    for (var i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {
      var d = (0, _levenshtein.levenshtein)(cmd, candidate);

      if (d <= threshold && d < bestDistance) {
        bestDistance = d;
        recommended = candidate;
      }
    }

    if (recommended) usage.fail(__('Did you mean %s?', recommended));
  };

  self.reset = function reset(localLookup) {
    implied = (0, _objFilter.objFilter)(implied, function (k) {
      return !localLookup[k];
    });
    conflicting = (0, _objFilter.objFilter)(conflicting, function (k) {
      return !localLookup[k];
    });
    return self;
  };

  var frozens = [];

  self.freeze = function freeze() {
    frozens.push({
      implied: implied,
      conflicting: conflicting
    });
  };

  self.unfreeze = function unfreeze() {
    var frozen = frozens.pop();
    (0, _commonTypes.assertNotStrictEqual)(frozen, undefined, shim);
    implied = frozen.implied;
    conflicting = frozen.conflicting;
  };

  return self;
}