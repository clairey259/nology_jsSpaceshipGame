"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usage = usage;

var _objFilter = require("./utils/obj-filter.js");

var _yerror = require("./yerror.js");

var _setBlocking = _interopRequireDefault(require("./utils/set-blocking.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function isBoolean(fail) {
  return typeof fail === 'boolean';
}

function usage(yargs, shim) {
  var __ = shim.y18n.__;
  var self = {};
  var fails = [];

  self.failFn = function failFn(f) {
    fails.push(f);
  };

  var failMessage = null;
  var globalFailMessage = null;
  var showHelpOnFail = true;

  self.showHelpOnFail = function showHelpOnFailFn() {
    var arg1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var arg2 = arguments.length > 1 ? arguments[1] : undefined;

    var _ref = typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2],
        _ref2 = _slicedToArray(_ref, 2),
        enabled = _ref2[0],
        message = _ref2[1];

    if (yargs.getInternalMethods().isGlobalContext()) {
      globalFailMessage = message;
    }

    failMessage = message;
    showHelpOnFail = enabled;
    return self;
  };

  var failureOutput = false;

  self.fail = function fail(msg, err) {
    var logger = yargs.getInternalMethods().getLoggerInstance();

    if (fails.length) {
      for (var i = fails.length - 1; i >= 0; --i) {
        var _fail = fails[i];

        if (isBoolean(_fail)) {
          if (err) throw err;else if (msg) throw Error(msg);
        } else {
          _fail(msg, err, self);
        }
      }
    } else {
      if (yargs.getExitProcess()) (0, _setBlocking["default"])(true);

      if (!failureOutput) {
        failureOutput = true;

        if (showHelpOnFail) {
          yargs.showHelp('error');
          logger.error();
        }

        if (msg || err) logger.error(msg || err);
        var globalOrCommandFailMessage = failMessage || globalFailMessage;

        if (globalOrCommandFailMessage) {
          if (msg || err) logger.error('');
          logger.error(globalOrCommandFailMessage);
        }
      }

      err = err || new _yerror.YError(msg);

      if (yargs.getExitProcess()) {
        return yargs.exit(1);
      } else if (yargs.getInternalMethods().hasParseCallback()) {
        return yargs.exit(1, err);
      } else {
        throw err;
      }
    }
  };

  var usages = [];
  var usageDisabled = false;

  self.usage = function (msg, description) {
    if (msg === null) {
      usageDisabled = true;
      usages = [];
      return self;
    }

    usageDisabled = false;
    usages.push([msg, description || '']);
    return self;
  };

  self.getUsage = function () {
    return usages;
  };

  self.getUsageDisabled = function () {
    return usageDisabled;
  };

  self.getPositionalGroupName = function () {
    return __('Positionals:');
  };

  var examples = [];

  self.example = function (cmd, description) {
    examples.push([cmd, description || '']);
  };

  var commands = [];

  self.command = function command(cmd, description, isDefault, aliases) {
    var deprecated = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    if (isDefault) {
      commands = commands.map(function (cmdArray) {
        cmdArray[2] = false;
        return cmdArray;
      });
    }

    commands.push([cmd, description || '', isDefault, aliases, deprecated]);
  };

  self.getCommands = function () {
    return commands;
  };

  var descriptions = {};

  self.describe = function describe(keyOrKeys, desc) {
    if (Array.isArray(keyOrKeys)) {
      keyOrKeys.forEach(function (k) {
        self.describe(k, desc);
      });
    } else if (_typeof(keyOrKeys) === 'object') {
      Object.keys(keyOrKeys).forEach(function (k) {
        self.describe(k, keyOrKeys[k]);
      });
    } else {
      descriptions[keyOrKeys] = desc;
    }
  };

  self.getDescriptions = function () {
    return descriptions;
  };

  var epilogs = [];

  self.epilog = function (msg) {
    epilogs.push(msg);
  };

  var wrapSet = false;
  var wrap;

  self.wrap = function (cols) {
    wrapSet = true;
    wrap = cols;
  };

  self.getWrap = function () {
    if (shim.getEnv('YARGS_DISABLE_WRAP')) {
      return null;
    }

    if (!wrapSet) {
      wrap = windowWidth();
      wrapSet = true;
    }

    return wrap;
  };

  var deferY18nLookupPrefix = '__yargsString__:';

  self.deferY18nLookup = function (str) {
    return deferY18nLookupPrefix + str;
  };

  self.help = function help() {
    if (cachedHelpMessage) return cachedHelpMessage;
    normalizeAliases();
    var base$0 = yargs.customScriptName ? yargs.$0 : shim.path.basename(yargs.$0);
    var demandedOptions = yargs.getDemandedOptions();
    var demandedCommands = yargs.getDemandedCommands();
    var deprecatedOptions = yargs.getDeprecatedOptions();
    var groups = yargs.getGroups();
    var options = yargs.getOptions();
    var keys = [];
    keys = keys.concat(Object.keys(descriptions));
    keys = keys.concat(Object.keys(demandedOptions));
    keys = keys.concat(Object.keys(demandedCommands));
    keys = keys.concat(Object.keys(options["default"]));
    keys = keys.filter(filterHiddenOptions);
    keys = Object.keys(keys.reduce(function (acc, key) {
      if (key !== '_') acc[key] = true;
      return acc;
    }, {}));
    var theWrap = self.getWrap();
    var ui = shim.cliui({
      width: theWrap,
      wrap: !!theWrap
    });

    if (!usageDisabled) {
      if (usages.length) {
        usages.forEach(function (usage) {
          ui.div({
            text: "".concat(usage[0].replace(/\$0/g, base$0))
          });

          if (usage[1]) {
            ui.div({
              text: "".concat(usage[1]),
              padding: [1, 0, 0, 0]
            });
          }
        });
        ui.div();
      } else if (commands.length) {
        var u = null;

        if (demandedCommands._) {
          u = "".concat(base$0, " <").concat(__('command'), ">\n");
        } else {
          u = "".concat(base$0, " [").concat(__('command'), "]\n");
        }

        ui.div("".concat(u));
      }
    }

    if (commands.length > 1 || commands.length === 1 && !commands[0][2]) {
      ui.div(__('Commands:'));
      var context = yargs.getInternalMethods().getContext();
      var parentCommands = context.commands.length ? "".concat(context.commands.join(' '), " ") : '';

      if (yargs.getInternalMethods().getParserConfiguration()['sort-commands'] === true) {
        commands = commands.sort(function (a, b) {
          return a[0].localeCompare(b[0]);
        });
      }

      var prefix = base$0 ? "".concat(base$0, " ") : '';
      commands.forEach(function (command) {
        var commandString = "".concat(prefix).concat(parentCommands).concat(command[0].replace(/^\$0 ?/, ''));
        ui.span({
          text: commandString,
          padding: [0, 2, 0, 2],
          width: maxWidth(commands, theWrap, "".concat(base$0).concat(parentCommands)) + 4
        }, {
          text: command[1]
        });
        var hints = [];
        if (command[2]) hints.push("[".concat(__('default'), "]"));

        if (command[3] && command[3].length) {
          hints.push("[".concat(__('aliases:'), " ").concat(command[3].join(', '), "]"));
        }

        if (command[4]) {
          if (typeof command[4] === 'string') {
            hints.push("[".concat(__('deprecated: %s', command[4]), "]"));
          } else {
            hints.push("[".concat(__('deprecated'), "]"));
          }
        }

        if (hints.length) {
          ui.div({
            text: hints.join(' '),
            padding: [0, 0, 0, 2],
            align: 'right'
          });
        } else {
          ui.div();
        }
      });
      ui.div();
    }

    var aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
    keys = keys.filter(function (key) {
      return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) {
        return (options.alias[alias] || []).indexOf(key) === -1;
      });
    });

    var defaultGroup = __('Options:');

    if (!groups[defaultGroup]) groups[defaultGroup] = [];
    addUngroupedKeys(keys, options.alias, groups, defaultGroup);

    var isLongSwitch = function isLongSwitch(sw) {
      return /^--/.test(getText(sw));
    };

    var displayedGroups = Object.keys(groups).filter(function (groupName) {
      return groups[groupName].length > 0;
    }).map(function (groupName) {
      var normalizedKeys = groups[groupName].filter(filterHiddenOptions).map(function (key) {
        if (aliasKeys.includes(key)) return key;

        for (var i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {
          if ((options.alias[aliasKey] || []).includes(key)) return aliasKey;
        }

        return key;
      });
      return {
        groupName: groupName,
        normalizedKeys: normalizedKeys
      };
    }).filter(function (_ref3) {
      var normalizedKeys = _ref3.normalizedKeys;
      return normalizedKeys.length > 0;
    }).map(function (_ref4) {
      var groupName = _ref4.groupName,
          normalizedKeys = _ref4.normalizedKeys;
      var switches = normalizedKeys.reduce(function (acc, key) {
        acc[key] = [key].concat(options.alias[key] || []).map(function (sw) {
          if (groupName === self.getPositionalGroupName()) return sw;else {
            return (/^[0-9]$/.test(sw) ? options["boolean"].includes(key) ? '-' : '--' : sw.length > 1 ? '--' : '-') + sw;
          }
        }).sort(function (sw1, sw2) {
          return isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1;
        }).join(', ');
        return acc;
      }, {});
      return {
        groupName: groupName,
        normalizedKeys: normalizedKeys,
        switches: switches
      };
    });
    var shortSwitchesUsed = displayedGroups.filter(function (_ref5) {
      var groupName = _ref5.groupName;
      return groupName !== self.getPositionalGroupName();
    }).some(function (_ref6) {
      var normalizedKeys = _ref6.normalizedKeys,
          switches = _ref6.switches;
      return !normalizedKeys.every(function (key) {
        return isLongSwitch(switches[key]);
      });
    });

    if (shortSwitchesUsed) {
      displayedGroups.filter(function (_ref7) {
        var groupName = _ref7.groupName;
        return groupName !== self.getPositionalGroupName();
      }).forEach(function (_ref8) {
        var normalizedKeys = _ref8.normalizedKeys,
            switches = _ref8.switches;
        normalizedKeys.forEach(function (key) {
          if (isLongSwitch(switches[key])) {
            switches[key] = addIndentation(switches[key], '-x, '.length);
          }
        });
      });
    }

    displayedGroups.forEach(function (_ref9) {
      var groupName = _ref9.groupName,
          normalizedKeys = _ref9.normalizedKeys,
          switches = _ref9.switches;
      ui.div(groupName);
      normalizedKeys.forEach(function (key) {
        var kswitch = switches[key];
        var desc = descriptions[key] || '';
        var type = null;
        if (desc.includes(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length));
        if (options["boolean"].includes(key)) type = "[".concat(__('boolean'), "]");
        if (options.count.includes(key)) type = "[".concat(__('count'), "]");
        if (options.string.includes(key)) type = "[".concat(__('string'), "]");
        if (options.normalize.includes(key)) type = "[".concat(__('string'), "]");
        if (options.array.includes(key)) type = "[".concat(__('array'), "]");
        if (options.number.includes(key)) type = "[".concat(__('number'), "]");

        var deprecatedExtra = function deprecatedExtra(deprecated) {
          return typeof deprecated === 'string' ? "[".concat(__('deprecated: %s', deprecated), "]") : "[".concat(__('deprecated'), "]");
        };

        var extra = [key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null, type, key in demandedOptions ? "[".concat(__('required'), "]") : null, options.choices && options.choices[key] ? "[".concat(__('choices:'), " ").concat(self.stringifiedValues(options.choices[key]), "]") : null, defaultString(options["default"][key], options.defaultDescription[key])].filter(Boolean).join(' ');
        ui.span({
          text: getText(kswitch),
          padding: [0, 2, 0, 2 + getIndentation(kswitch)],
          width: maxWidth(switches, theWrap) + 4
        }, desc);
        if (extra) ui.div({
          text: extra,
          padding: [0, 0, 0, 2],
          align: 'right'
        });else ui.div();
      });
      ui.div();
    });

    if (examples.length) {
      ui.div(__('Examples:'));
      examples.forEach(function (example) {
        example[0] = example[0].replace(/\$0/g, base$0);
      });
      examples.forEach(function (example) {
        if (example[1] === '') {
          ui.div({
            text: example[0],
            padding: [0, 2, 0, 2]
          });
        } else {
          ui.div({
            text: example[0],
            padding: [0, 2, 0, 2],
            width: maxWidth(examples, theWrap) + 4
          }, {
            text: example[1]
          });
        }
      });
      ui.div();
    }

    if (epilogs.length > 0) {
      var e = epilogs.map(function (epilog) {
        return epilog.replace(/\$0/g, base$0);
      }).join('\n');
      ui.div("".concat(e, "\n"));
    }

    return ui.toString().replace(/\s*$/, '');
  };

  function maxWidth(table, theWrap, modifier) {
    var width = 0;

    if (!Array.isArray(table)) {
      table = Object.values(table).map(function (v) {
        return [v];
      });
    }

    table.forEach(function (v) {
      width = Math.max(shim.stringWidth(modifier ? "".concat(modifier, " ").concat(getText(v[0])) : getText(v[0])) + getIndentation(v[0]), width);
    });
    if (theWrap) width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
    return width;
  }

  function normalizeAliases() {
    var demandedOptions = yargs.getDemandedOptions();
    var options = yargs.getOptions();
    (Object.keys(options.alias) || []).forEach(function (key) {
      options.alias[key].forEach(function (alias) {
        if (descriptions[alias]) self.describe(key, descriptions[alias]);
        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias]);
        if (options["boolean"].includes(alias)) yargs["boolean"](key);
        if (options.count.includes(alias)) yargs.count(key);
        if (options.string.includes(alias)) yargs.string(key);
        if (options.normalize.includes(alias)) yargs.normalize(key);
        if (options.array.includes(alias)) yargs.array(key);
        if (options.number.includes(alias)) yargs.number(key);
      });
    });
  }

  var cachedHelpMessage;

  self.cacheHelpMessage = function () {
    cachedHelpMessage = this.help();
  };

  self.clearCachedHelpMessage = function () {
    cachedHelpMessage = undefined;
  };

  self.hasCachedHelpMessage = function () {
    return !!cachedHelpMessage;
  };

  function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
    var groupedKeys = [];
    var toCheck = null;
    Object.keys(groups).forEach(function (group) {
      groupedKeys = groupedKeys.concat(groups[group]);
    });
    keys.forEach(function (key) {
      toCheck = [key].concat(aliases[key]);

      if (!toCheck.some(function (k) {
        return groupedKeys.indexOf(k) !== -1;
      })) {
        groups[defaultGroup].push(key);
      }
    });
    return groupedKeys;
  }

  function filterHiddenOptions(key) {
    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
  }

  self.showHelp = function (level) {
    var logger = yargs.getInternalMethods().getLoggerInstance();
    if (!level) level = 'error';
    var emit = typeof level === 'function' ? level : logger[level];
    emit(self.help());
  };

  self.functionDescription = function (fn) {
    var description = fn.name ? shim.Parser.decamelize(fn.name, '-') : __('generated-value');
    return ['(', description, ')'].join('');
  };

  self.stringifiedValues = function stringifiedValues(values, separator) {
    var string = '';
    var sep = separator || ', ';
    var array = [].concat(values);
    if (!values || !array.length) return string;
    array.forEach(function (value) {
      if (string.length) string += sep;
      string += JSON.stringify(value);
    });
    return string;
  };

  function defaultString(value, defaultDescription) {
    var string = "[".concat(__('default:'), " ");
    if (value === undefined && !defaultDescription) return null;

    if (defaultDescription) {
      string += defaultDescription;
    } else {
      switch (_typeof(value)) {
        case 'string':
          string += "\"".concat(value, "\"");
          break;

        case 'object':
          string += JSON.stringify(value);
          break;

        default:
          string += value;
      }
    }

    return "".concat(string, "]");
  }

  function windowWidth() {
    var maxWidth = 80;

    if (shim.process.stdColumns) {
      return Math.min(maxWidth, shim.process.stdColumns);
    } else {
      return maxWidth;
    }
  }

  var version = null;

  self.version = function (ver) {
    version = ver;
  };

  self.showVersion = function (level) {
    var logger = yargs.getInternalMethods().getLoggerInstance();
    if (!level) level = 'error';
    var emit = typeof level === 'function' ? level : logger[level];
    emit(version);
  };

  self.reset = function reset(localLookup) {
    failMessage = null;
    failureOutput = false;
    usages = [];
    usageDisabled = false;
    epilogs = [];
    examples = [];
    commands = [];
    descriptions = (0, _objFilter.objFilter)(descriptions, function (k) {
      return !localLookup[k];
    });
    return self;
  };

  var frozens = [];

  self.freeze = function freeze() {
    frozens.push({
      failMessage: failMessage,
      failureOutput: failureOutput,
      usages: usages,
      usageDisabled: usageDisabled,
      epilogs: epilogs,
      examples: examples,
      commands: commands,
      descriptions: descriptions
    });
  };

  self.unfreeze = function unfreeze() {
    var defaultCommand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var frozen = frozens.pop();
    if (!frozen) return;

    if (defaultCommand) {
      descriptions = _objectSpread({}, frozen.descriptions, {}, descriptions);
      commands = [].concat(_toConsumableArray(frozen.commands), _toConsumableArray(commands));
      usages = [].concat(_toConsumableArray(frozen.usages), _toConsumableArray(usages));
      examples = [].concat(_toConsumableArray(frozen.examples), _toConsumableArray(examples));
      epilogs = [].concat(_toConsumableArray(frozen.epilogs), _toConsumableArray(epilogs));
    } else {
      failMessage = frozen.failMessage;
      failureOutput = frozen.failureOutput;
      usages = frozen.usages;
      usageDisabled = frozen.usageDisabled;
      epilogs = frozen.epilogs;
      examples = frozen.examples;
      commands = frozen.commands;
      descriptions = frozen.descriptions;
    }
  };

  return self;
}

function isIndentedText(text) {
  return _typeof(text) === 'object';
}

function addIndentation(text, indent) {
  return isIndentedText(text) ? {
    text: text.text,
    indentation: text.indentation + indent
  } : {
    text: text,
    indentation: indent
  };
}

function getIndentation(text) {
  return isIndentedText(text) ? text.indentation : 0;
}

function getText(text) {
  return isIndentedText(text) ? text.text : text;
}